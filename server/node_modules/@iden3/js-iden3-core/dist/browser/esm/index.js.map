{"version":3,"file":"index.js","sources":["../../../src/constants.ts","../../../src/utils.ts","../../../src/elemBytes.ts","../../../src/schemaHash.ts","../../../src/id.ts","../../../src/claim.ts","../../../src/did/did-helper.ts","../../../src/did/types.ts","../../../src/did/did-parser.ts","../../../src/did/did.ts","../../../src/registration.ts"],"sourcesContent":["export const Constants = Object.freeze({\n  ERRORS: {\n    // ErrDataOverflow means that given *big.Int value does not fit in Field Q\n    // e.g. greater than Q constant:\n    // Q constant: 21888242871839275222246405745257275088548364400416034343698204186575808495617\n    DATA_OVERFLOW: new Error('data does not fits SNARK size'),\n    // ErrIncorrectIDPosition means that passed position is not one of predefined:\n    // IDPositionIndex or IDPositionValue\n    INCORRECT_ID_POSITION: new Error('incorrect ID position'),\n    // throws when ID not found in the Claim.\n    NO_ID: new Error('ID is not set'),\n    // throws when subject position flags sets in invalid value.\n    INVALID_SUBJECT_POSITION: new Error('invalid subject position'),\n    // ErrIncorrectMerklizePosition means that passed position is not one of predefined:\n    // MerklizePositionIndex or MerklizePositionValue\n    INCORRECT_MERKLIZED_POSITION: new Error('incorrect Merklize position'),\n    // ErrNoMerklizedRoot returns when Merklized Root is not found in the Claim.\n    NO_MERKLIZED_ROOT: new Error('Merklized root is not set'),\n    NETWORK_NOT_SUPPORTED_FOR_DID: new Error('network in not supported for did'),\n    UNSUPPORTED_BLOCKCHAIN_FOR_DID: new Error('not supported blockchain for did'),\n    UNSUPPORTED_DID_METHOD: new Error('not supported DID method'),\n    UNKNOWN_DID_METHOD: new Error('unknown DID method'),\n    INCORRECT_DID: new Error('incorrect DID'),\n    UNSUPPORTED_ID: new Error('unsupported Id')\n  },\n  SCHEMA: {\n    HASH_LENGTH: 16\n  },\n  ETH_ADDRESS_LENGTH: 20,\n  BYTES_LENGTH: 32,\n  ELEM_BYTES_LENGTH: 4,\n  NONCE_BYTES_LENGTH: 8,\n  Q: BigInt('21888242871839275222246405745257275088548364400416034343698204186575808495617'),\n  ID: {\n    TYPE_DEFAULT: Uint8Array.from([0x00, 0x00]),\n    TYPE_READONLY: Uint8Array.from([0b00000000, 0b00000001]),\n    ID_LENGTH: 31\n  },\n  DID: {\n    DID_SCHEMA: 'did'\n  },\n  GENESIS_LENGTH: 27\n});\n\nexport const Blockchain: { [k: string]: string } = {\n  Ethereum: 'eth',\n  Polygon: 'polygon',\n  ZkEVM: 'zkevm',\n  Privado: 'privado',\n  Unknown: 'unknown',\n  NoChain: '',\n  ReadOnly: 'readonly'\n};\n\nexport const NetworkId: { [k: string]: string } = {\n  Main: 'main',\n  Mumbai: 'mumbai',\n  Amoy: 'amoy',\n  Goerli: 'goerli',\n  Sepolia: 'sepolia',\n  Test: 'test',\n  Unknown: 'unknown',\n  NoNetwork: ''\n};\n\nexport const DidMethod: { [k: string]: string } = {\n  Iden3: 'iden3',\n  PolygonId: 'polygonid',\n  Other: ''\n};\n\n/**\n * Object containing chain IDs for various blockchains and networks.\n * @type { [key: string]: number }\n */\nexport const ChainIds: { [key: string]: number } = {\n  [`${Blockchain.Ethereum}:${NetworkId.Main}`]: 1,\n  [`${Blockchain.Ethereum}:${NetworkId.Goerli}`]: 5,\n  [`${Blockchain.Ethereum}:${NetworkId.Sepolia}`]: 11155111,\n  [`${Blockchain.Polygon}:${NetworkId.Main}`]: 137,\n  [`${Blockchain.Polygon}:${NetworkId.Mumbai}`]: 80001,\n  [`${Blockchain.Polygon}:${NetworkId.Amoy}`]: 80002,\n  [`${Blockchain.ZkEVM}:${NetworkId.Main}`]: 1101,\n  [`${Blockchain.ZkEVM}:${NetworkId.Test}`]: 1442,\n  [`${Blockchain.Privado}:${NetworkId.Main}`]: 21000,\n  [`${Blockchain.Privado}:${NetworkId.Test}`]: 21001\n};\n\nexport const DidMethodByte: { [key: string]: number } = {\n  [DidMethod.Iden3]: 0b00000001,\n  [DidMethod.PolygonId]: 0b00000010,\n  [DidMethod.Other]: 0b11111111\n};\n\nconst blockchainNetworkMap = {\n  [`${Blockchain.ReadOnly}:${NetworkId.NoNetwork}`]: 0b00000000,\n  [`${Blockchain.Polygon}:${NetworkId.Main}`]: 0b0001_0000 | 0b0000_0001,\n  [`${Blockchain.Polygon}:${NetworkId.Mumbai}`]: 0b0001_0000 | 0b0000_0010,\n  [`${Blockchain.Polygon}:${NetworkId.Amoy}`]: 0b0001_0000 | 0b0000_0011,\n  [`${Blockchain.Ethereum}:${NetworkId.Main}`]: 0b0010_0000 | 0b0000_0001,\n  [`${Blockchain.Ethereum}:${NetworkId.Goerli}`]: 0b0010_0000 | 0b0000_0010,\n  [`${Blockchain.Ethereum}:${NetworkId.Sepolia}`]: 0b0010_0000 | 0b0000_0011,\n  [`${Blockchain.ZkEVM}:${NetworkId.Main}`]: 0b0011_0000 | 0b0000_0001,\n  [`${Blockchain.ZkEVM}:${NetworkId.Test}`]: 0b0011_0000 | 0b0000_0010,\n  [`${Blockchain.Privado}:${NetworkId.Main}`]: 0b1010_0000 | 0b0000_0001,\n  [`${Blockchain.Privado}:${NetworkId.Test}`]: 0b1010_0000 | 0b0000_0010\n};\n\n// DIDMethodNetwork is map for did methods and their blockchain networks\nexport const DidMethodNetwork: {\n  [k: string]: { [k: string]: number };\n} = {\n  [DidMethod.Iden3]: {\n    ...blockchainNetworkMap\n  },\n  [DidMethod.PolygonId]: {\n    ...blockchainNetworkMap\n  },\n  [DidMethod.Other]: {\n    [`${Blockchain.Unknown}:${NetworkId.Unknown}`]: 0b1111_1111\n  }\n};\n","import { poseidon } from '@iden3/js-crypto';\nimport { Constants } from './constants';\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nexport const encoder = new TextEncoder();\n\nexport function fromLittleEndian(bytes: Uint8Array): bigint {\n  const n256 = BigInt(256);\n  let result = BigInt(0);\n  let base = BigInt(1);\n  bytes.forEach((byte) => {\n    result += base * BigInt(byte);\n    base = base * n256;\n  });\n  return result;\n}\n\nexport function fromBigEndian(bytes: Uint8Array): bigint {\n  return fromLittleEndian(bytes.reverse());\n}\n\nexport function toLittleEndian(bigNumber: bigint, len = 31): Uint8Array {\n  const n256 = BigInt(256);\n  const result = new Uint8Array(len);\n  let i = 0;\n  while (bigNumber > BigInt(0)) {\n    result[i] = Number(bigNumber % n256);\n    bigNumber = bigNumber / n256;\n    i += 1;\n  }\n  return result;\n}\n\nexport function toBigEndian(bigNumber: bigint, len = 31): Uint8Array {\n  return toLittleEndian(bigNumber, len).reverse();\n}\n\nexport function putUint32(n: number): Uint8Array {\n  const buf = new ArrayBuffer(4);\n  const view = new DataView(buf);\n  view.setUint32(0, n, true);\n  return new Uint8Array(buf);\n}\n\nexport function getUint32(arr: Uint8Array): number {\n  const buf = arr.buffer.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);\n  return new DataView(buf).getUint32(0, true);\n}\n\nexport function putUint64(n: bigint): Uint8Array {\n  const buf = new ArrayBuffer(8);\n  const view = new DataView(buf);\n  view.setBigUint64(0, n, true);\n  return new Uint8Array(buf);\n}\n\nexport function getUint64(arr: Uint8Array): bigint {\n  const buf = arr.buffer.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);\n  return new DataView(buf).getBigUint64(0, true);\n}\n\nexport function getUnixTimestamp(d: Date): number {\n  return Math.floor(d.getTime() / 1000);\n}\nexport function getDateFromUnixTimestamp(n: number): Date {\n  return new Date(n * 1000);\n}\n\n// checkBigIntInField checks if given *big.Int fits in a Field Q element\nexport function checkBigIntInField(a: bigint): boolean {\n  return a < Constants.Q;\n}\n\nexport function checkBigIntArrayInField(arr: bigint[]): boolean {\n  return arr.every((n) => checkBigIntInField(n));\n}\n\n// IdenState calculates the Identity State from the Claims Tree Root,\n// Revocation Tree Root and Roots Tree Root.\nexport function idenState(clr: bigint, rer: bigint, ror: bigint): bigint {\n  return poseidon.hash([clr, rer, ror]);\n}\n\nexport class StringUtils {\n  static isNotValidIDChar(char: string): boolean {\n    return (\n      StringUtils.isNotAlpha(char) && StringUtils.isNotDigit(char) && char !== '.' && char !== '-'\n    );\n  }\n\n  static isNotValidParamChar(char: string): boolean {\n    return (\n      StringUtils.isNotAlpha(char) &&\n      StringUtils.isNotDigit(char) &&\n      char !== '.' &&\n      char !== '-' &&\n      char !== '_' &&\n      char !== ':'\n    );\n  }\n\n  static isNotValidQueryOrFragmentChar(char: string): boolean {\n    return StringUtils.isNotValidPathChar(char) && char !== '/' && char !== '?';\n  }\n\n  static isNotValidPathChar(char: string): boolean {\n    return StringUtils.isNotUnreservedOrSubdelim(char) && char !== ':' && char !== '@';\n  }\n\n  static isNotUnreservedOrSubdelim(char: string): boolean {\n    switch (char) {\n      case '-':\n      case '.':\n      case '_':\n      case '~':\n      case '!':\n      case '$':\n      case '&':\n      case \"'\":\n      case '(':\n      case ')':\n      case '*':\n      case '+':\n      case ',':\n      case ';':\n      case '=':\n        return false;\n      default:\n        if (StringUtils.isNotAlpha(char) && StringUtils.isNotDigit(char)) {\n          return true;\n        }\n        return false;\n    }\n  }\n\n  static isNotHexDigit(char: string): boolean {\n    return (\n      StringUtils.isNotDigit(char) &&\n      (char < '\\x41' || char > '\\x46') &&\n      (char < '\\x61' || char > '\\x66')\n    );\n  }\n\n  static isNotDigit(char: string): boolean {\n    // '\\x30' is digit 0, '\\x39' is digit 9\n    return char < '\\x30' || char > '\\x39';\n  }\n\n  // StringUtils.isNotAlpha returns true if a byte is not a big letter between A-Z or small letter between a-z\n  // https://tools.ietf.org/html/rfc5234#appendix-B.1\n  static isNotAlpha(char: string): boolean {\n    return StringUtils.isNotSmallLetter(char) && StringUtils.isNotBigLetter(char);\n  }\n\n  // isNotBigLetter returns true if a byte is not a big letter between A-Z\n  // in US-ASCII http://www.columbia.edu/kermit/ascii.html\n  // https://tools.ietf.org/html/rfc5234#appendix-B.1\n  static isNotBigLetter(char: string): boolean {\n    // '\\x41' is big letter A, '\\x5A' small letter Z\n    return char < '\\x41' || char > '\\x5A';\n  }\n\n  // isNotSmallLetter returns true if a byte is not a small letter between a-z\n  // in US-ASCII http://www.columbia.edu/kermit/ascii.html\n  // https://tools.ietf.org/html/rfc5234#appendix-B.1\n  static isNotSmallLetter(char: string): boolean {\n    // '\\x61' is small letter a, '\\x7A' small letter z\n    return char < '\\x61' || char > '\\x7A';\n  }\n}\n\nexport const genesisFromEthAddress = (addr: Uint8Array) => {\n  return Uint8Array.from([...new Uint8Array(7), ...addr]);\n};\n","import { Constants } from './constants';\nimport { checkBigIntInField, fromLittleEndian, toLittleEndian, encoder } from './utils';\nimport { Hex, sha256 } from '@iden3/js-crypto';\nexport class BytesHelper {\n  static intToBytes(int: bigint): Uint8Array {\n    return BytesHelper.intToNBytes(int, Constants.BYTES_LENGTH);\n  }\n\n  static intToNBytes(int: bigint, n: number): Uint8Array {\n    return Uint8Array.from(toLittleEndian(int, n));\n  }\n\n  static checkChecksum(bytes: Uint8Array): boolean {\n    const { typ, genesis, checksum } = BytesHelper.decomposeBytes(bytes);\n    if (!checksum.length || JSON.stringify(Uint8Array.from([0, 0])) === JSON.stringify(checksum)) {\n      return false;\n    }\n\n    const c = BytesHelper.calculateChecksum(typ, genesis);\n    return JSON.stringify(c) === JSON.stringify(checksum);\n  }\n\n  static decomposeBytes(b: Uint8Array): {\n    typ: Uint8Array;\n    genesis: Uint8Array;\n    checksum: Uint8Array;\n  } {\n    const offset = 2;\n    const len = b.length - offset;\n    return {\n      typ: b.slice(0, offset),\n      genesis: b.slice(offset, len),\n      checksum: b.slice(-offset)\n    };\n  }\n\n  static calculateChecksum(typ: Uint8Array, genesis: Uint8Array): Uint8Array {\n    const toChecksum = [...typ, ...genesis];\n    const s: number = toChecksum.reduce((acc, cur) => acc + cur, 0);\n    const checksum = [s >> 8, s & 0xff];\n    return Uint8Array.from(checksum.reverse());\n  }\n\n  static hashBytes(str: string): Uint8Array {\n    const hash = sha256(encoder.encode(str));\n    return new Uint8Array(hash);\n  }\n\n  static hexToBytes(str: string): Uint8Array {\n    return Hex.decodeString(str);\n  }\n\n  static bytesToHex(bytes: Uint8Array) {\n    const hex: string[] = [];\n    for (let i = 0; i < bytes.length; i++) {\n      const current = bytes[i] < 0 ? bytes[i] + 256 : bytes[i];\n      hex.push((current >>> 4).toString(16));\n      hex.push((current & 0xf).toString(16));\n    }\n    return hex.join('');\n  }\n\n  static bytesToInt(bytes: Uint8Array): bigint {\n    return fromLittleEndian(bytes);\n  }\n}\n\nexport class ElemBytes {\n  private _bytes = new Uint8Array(Constants.BYTES_LENGTH);\n\n  constructor(bytes?: Uint8Array | null) {\n    if (bytes) {\n      this._bytes = bytes;\n    }\n    if (this._bytes.length !== Constants.BYTES_LENGTH) {\n      throw new Error('Invalid bytes length');\n    }\n  }\n\n  get bytes(): Uint8Array {\n    return this._bytes;\n  }\n\n  set bytes(value: Uint8Array) {\n    this._bytes = value;\n  }\n\n  toBigInt(): bigint {\n    return BytesHelper.bytesToInt(this._bytes);\n  }\n\n  setBigInt(n: bigint): ElemBytes {\n    if (!checkBigIntInField(n)) {\n      throw Constants.ERRORS.DATA_OVERFLOW;\n    }\n    this._bytes = BytesHelper.intToBytes(n);\n    return this;\n  }\n\n  slotFromHex(hex: string): ElemBytes {\n    const bytes = Hex.decodeString(hex);\n    if (bytes.length !== Constants.BYTES_LENGTH) {\n      throw new Error('Invalid bytes length');\n    }\n    this._bytes.set(bytes, 0);\n    return this;\n  }\n\n  hex(): string {\n    return Hex.encodeString(this._bytes);\n  }\n\n  // ElemBytesToInts converts slice of ElemBytes to slice of *big.Int\n  static elemBytesToInts(elements: ElemBytes[]): bigint[] {\n    const result: bigint[] = [];\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      result.push(element.toBigInt());\n    }\n\n    return result;\n  }\n\n  static fromInt(i: bigint): ElemBytes {\n    if (!checkBigIntInField(i)) {\n      throw Constants.ERRORS.DATA_OVERFLOW;\n    }\n    const bytes = BytesHelper.intToBytes(i);\n    return new ElemBytes(bytes);\n  }\n}\n","import { Hex } from '@iden3/js-crypto';\nimport { Constants } from './constants';\nimport { BytesHelper } from './elemBytes';\n\nexport class SchemaHash {\n  // authSchemaHash predefined value of auth schema, used for auth claim during identity creation.\n  // This schema is hardcoded in the identity circuits and used to verify user's auth claim.\n  // Keccak256(https://schema.iden3.io/core/jsonld/auth.jsonld#AuthBJJCredential) last 16 bytes\n  // Hex: cca3371a6cb1b715004407e325bd993c\n  // BigInt: 80551937543569765027552589160822318028\n  static readonly authSchemaHash = new SchemaHash(\n    Uint8Array.from([204, 163, 55, 26, 108, 177, 183, 21, 0, 68, 7, 227, 37, 189, 153, 60])\n  );\n\n  private _bytes: Uint8Array = new Uint8Array(Constants.SCHEMA.HASH_LENGTH);\n  /**\n   * Constructor\n   * @param bytes\n   */\n  constructor(bytes?: Uint8Array) {\n    if (bytes) {\n      this._bytes = bytes;\n    }\n    if (this.bytes.length !== Constants.SCHEMA.HASH_LENGTH) {\n      throw new Error(`Schema hash must be ${Constants.SCHEMA.HASH_LENGTH} bytes long`);\n    }\n  }\n\n  get bytes(): Uint8Array {\n    return this._bytes;\n  }\n\n  /**\n   * MarshalText returns HEX representation of SchemaHash.\n   * @returns {Uint8Array} 32 bytes//\n   */\n  marshalTextBytes(): Uint8Array {\n    return Hex.encode(this.bytes);\n  }\n\n  marshalText(): string {\n    return Hex.encodeString(this.bytes);\n  }\n\n  /**\n   * NewSchemaHashFromHex creates new SchemaHash from hex string\n   * @param s\n   * @returns {SchemaHash}\n   */\n  static newSchemaHashFromHex(s: string): SchemaHash {\n    const schemaEncodedBytes = Hex.decodeString(s);\n\n    if (schemaEncodedBytes.length !== Constants.SCHEMA.HASH_LENGTH) {\n      throw new Error(`invalid schema hash length: ${schemaEncodedBytes.length}`);\n    }\n\n    return new SchemaHash(schemaEncodedBytes);\n  }\n\n  /**\n   * NewSchemaHashFromInt creates new SchemaHash from big.Int\n   * @param i\n   * @returns\n   */\n  static newSchemaHashFromInt(i: bigint): SchemaHash {\n    const bytes = BytesHelper.intToNBytes(i, Constants.SCHEMA.HASH_LENGTH);\n    const start = Constants.SCHEMA.HASH_LENGTH - bytes.length;\n    return new SchemaHash(BytesHelper.intToBytes(i).slice(start, Constants.SCHEMA.HASH_LENGTH));\n  }\n\n  /**\n   * Convert SchemaHash to big.Int\n   * @returns {bigint}\n   */\n  bigInt(): bigint {\n    return BytesHelper.bytesToInt(this.bytes);\n  }\n}\n","import { Constants } from './constants';\nimport { fromLittleEndian } from './utils';\nimport { BytesHelper, ElemBytes } from './elemBytes';\nimport { poseidon, base58ToBytes, base58FromBytes } from '@iden3/js-crypto';\n\n// ID is a byte array with\n// [  type  | root_genesis | checksum ]\n// [2 bytes |   27 bytes   | 2 bytes  ]\n// where the root_genesis are the first 28 bytes from the hash root_genesis\n\nexport class Id {\n  private _bytes: Uint8Array;\n  private readonly _checksum: Uint8Array;\n\n  constructor(typ: Uint8Array, genesis: Uint8Array) {\n    this._checksum = BytesHelper.calculateChecksum(typ, genesis);\n    this._bytes = Uint8Array.from([...typ, ...genesis, ...this._checksum]);\n  }\n\n  private static getFromBytes(bytes: Uint8Array): Id {\n    const { typ, genesis }: { typ: Uint8Array; genesis: Uint8Array } =\n      BytesHelper.decomposeBytes(bytes);\n    return new Id(typ, genesis);\n  }\n\n  checksum(): Uint8Array {\n    return this._checksum;\n  }\n\n  string(): string {\n    return base58FromBytes(this._bytes);\n  }\n\n  get bytes(): Uint8Array {\n    return this._bytes;\n  }\n\n  set bytes(b: Uint8Array) {\n    this._bytes = b;\n  }\n\n  type(): Uint8Array {\n    return this._bytes.slice(0, 2);\n  }\n\n  bigInt(): bigint {\n    return fromLittleEndian(this._bytes);\n  }\n\n  equal(id: Id): boolean {\n    return JSON.stringify(this._bytes) === JSON.stringify(id.bytes);\n  }\n\n  marshal(): Uint8Array {\n    return new TextEncoder().encode(this.string());\n  }\n\n  static unMarshal(b: Uint8Array): Id {\n    return Id.fromString(new TextDecoder().decode(b));\n  }\n\n  static fromBytes(b: Uint8Array): Id {\n    const bytes = b ?? Uint8Array.from([]);\n    if (bytes.length !== Constants.ID.ID_LENGTH) {\n      throw new Error('fromBytes error: byte array incorrect length');\n    }\n\n    if (bytes.every((i: number) => i === 0)) {\n      throw new Error('fromBytes error: byte array empty');\n    }\n\n    const id = Id.getFromBytes(bytes);\n\n    if (!BytesHelper.checkChecksum(bytes)) {\n      throw new Error('fromBytes error: checksum error');\n    }\n\n    return id;\n  }\n\n  static fromString(s: string): Id {\n    const bytes = base58ToBytes(s);\n    return Id.fromBytes(bytes);\n  }\n\n  static fromBigInt(bigInt: bigint): Id {\n    const b = BytesHelper.intToNBytes(bigInt, Constants.ID.ID_LENGTH);\n    return Id.fromBytes(b);\n  }\n\n  static profileId(id: Id, nonce: bigint): Id {\n    const bigIntHash = poseidon.hash([id.bigInt(), nonce]);\n    const { typ } = BytesHelper.decomposeBytes(id.bytes);\n    const genesis = BytesHelper.intToNBytes(bigIntHash, 27);\n    return new Id(typ, genesis);\n  }\n\n  // IdGenesisFromIdenState calculates the genesis ID from an Identity State.\n  static idGenesisFromIdenState(\n    typ: Uint8Array, //nolint:revive\n    state: bigint\n  ): Id {\n    const idenStateData = ElemBytes.fromInt(state);\n\n    // we take last 27 bytes, because of swapped endianness\n    const idGenesisBytes = idenStateData.bytes.slice(idenStateData.bytes.length - 27);\n    return new Id(typ, idGenesisBytes);\n  }\n\n  static ethAddressFromId(id: Id): Uint8Array {\n    const isZeros = id.bytes.slice(2, 2 + 7).every((i: number) => i === 0);\n    if (!isZeros) {\n      throw new Error(\"can't get Ethereum address: high bytes of genesis are not zero\");\n    }\n    return id.bytes.slice(2 + 7).slice(0, Constants.ETH_ADDRESS_LENGTH);\n  }\n}\n","import { SchemaHash } from './schemaHash';\nimport { ElemBytes } from './elemBytes';\nimport { Constants } from './constants';\nimport { Id } from './id';\nimport {\n  checkBigIntArrayInField,\n  checkBigIntInField,\n  getDateFromUnixTimestamp,\n  getUint32,\n  getUint64,\n  getUnixTimestamp,\n  putUint32,\n  putUint64 as getBytesFromUint64\n} from './utils';\nimport { Hex, poseidon } from '@iden3/js-crypto';\n\n/*\nClaim structure\n\nIndex:\n i_0: [ 128  bits ] claim schema\n      [ 32 bits ] option flags\n          [3] Subject:\n            000: A.1 Self\n            001: invalid\n            010: A.2.i OtherIden Index\n            011: A.2.v OtherIden Value\n            100: B.i Object Index\n            101: B.v Object Value\n          [1] Expiration: bool\n          [1] Updatable: bool\n          [3] Merklized: data is merklized root is stored in the:\n            000: none\n            001: C.i Root Index (root located in i_2)\n            010: C.v Root Value (root located in v_2)\n          [24] 0\n      [ 32 bits ] version (optional?)\n      [ 61 bits ] 0 - reserved for future use\n i_1: [ 248 bits] identity (case b) (optional)\n      [  5 bits ] 0\n i_2: [ 253 bits] 0\n i_3: [ 253 bits] 0\nValue:\n v_0: [ 64 bits ]  revocation nonce\n      [ 64 bits ]  expiration date (optional)\n      [ 125 bits] 0 - reserved\n v_1: [ 248 bits] identity (case c) (optional)\n      [  5 bits ] 0\n v_2: [ 253 bits] 0\n v_3: [ 253 bits] 0\n*/\n\nexport enum SlotName {\n  IndexA = 'IndexA',\n  IndexB = 'IndexB',\n  ValueA = 'ValueA',\n  ValueB = 'ValueB'\n}\n\n// ErrSlotOverflow means some ElemBytes overflows Q Field. And wraps the name\n// of overflowed slot.\nexport class ErrSlotOverflow extends Error {\n  constructor(msg: string) {\n    super(`Slot ${msg} not in field (too large)`);\n    Object.setPrototypeOf(this, ErrSlotOverflow.prototype);\n  }\n}\n\n// subjectFlag for the time being describes the location of Id (in index or value\n// slots or nowhere at all).\n//\n// Values subjectFlagInvalid presents for backward compatibility and for now means nothing.\n\nexport enum SubjectFlag {\n  Self = 0b0,\n  Invalid = 0b1,\n  OtherIdenIndex = 0b10,\n  OtherIdenValue = 0b11\n}\n\nexport enum IdPosition {\n  None = 0,\n  Index = 1,\n  Value = 2\n}\n\n// merklizedFlag for the time being describes the location of root (in index or value\n// slots or nowhere at all).\n//\n// Values merklizedFlagIndex indicates that root is located in index[2] slots.\n// Values merklizedFlagValue indicates that root is located in value[2] slots.\nexport enum MerklizedFlag {\n  None = 0b00000000,\n  Index = 0b00100000,\n  Value = 0b01000000,\n  Invalid = 0b10000000\n}\n\nexport enum MerklizedRootPosition {\n  None = 0,\n  Index = 1,\n  Value = 2\n}\n\nexport enum Flags {\n  ByteIdx = 16,\n  ExpirationBitIdx = 3,\n  UpdatableBitIdx = 4\n}\n\nexport class Claim {\n  private _index: ElemBytes[] = [];\n  private _value: ElemBytes[] = [];\n\n  constructor() {\n    for (let i = 0; i < Constants.ELEM_BYTES_LENGTH; i++) {\n      this._index[i] = new ElemBytes();\n      this._value[i] = new ElemBytes();\n    }\n  }\n\n  // NewClaim creates new Claim with specified SchemaHash and any number of\n  // options. Using options you can specify any field in claim.\n  static newClaim(sh: SchemaHash, ...args: ClaimOption[]): Claim {\n    const c = new Claim();\n    c.setSchemaHash(sh);\n    for (let i = 0; i < args.length; i++) {\n      const fn = args[i];\n      fn(c);\n    }\n    return c;\n  }\n\n  // GetSchemaHash return copy of claim's schema hash.\n  getSchemaHash(): SchemaHash {\n    return new SchemaHash(this._index[0].bytes.slice(0, Constants.SCHEMA.HASH_LENGTH));\n  }\n\n  get value(): ElemBytes[] {\n    return this._value;\n  }\n\n  set value(value: ElemBytes[]) {\n    this._value = value;\n  }\n\n  get index(): ElemBytes[] {\n    return this._index;\n  }\n\n  set index(value: ElemBytes[]) {\n    this._index = value;\n  }\n\n  // SetSchemaHash updates claim's schema hash.\n  setSchemaHash(sh: SchemaHash) {\n    this._index[0] = new ElemBytes(\n      Uint8Array.from([...sh.bytes, ...new Array(Constants.SCHEMA.HASH_LENGTH).fill(0)])\n    );\n  }\n\n  setSubject(s: SubjectFlag) {\n    // clean first 3 bits\n    this._index[0].bytes[Flags.ByteIdx] &= 0b11111000;\n    this._index[0].bytes[Flags.ByteIdx] |= s;\n  }\n\n  private getSubject(): SubjectFlag {\n    let sbj = this._index[0].bytes[Flags.ByteIdx];\n    // clean all except first 3 bits\n    sbj &= 0b00000111;\n    return sbj as SubjectFlag;\n  }\n\n  private setFlagExpiration(val: boolean) {\n    if (val) {\n      this._index[0].bytes[Flags.ByteIdx] |= 0b1 << Flags.ExpirationBitIdx;\n    } else {\n      this._index[0].bytes[Flags.ByteIdx] &= ~(0b1 << Flags.ExpirationBitIdx);\n    }\n  }\n\n  private getFlagExpiration(): boolean {\n    const mask = 0b1 << Flags.ExpirationBitIdx;\n    return (this._index[0].bytes[Flags.ByteIdx] & mask) > 0;\n  }\n\n  // GetIDPosition returns the position at which the Id is stored.\n  getIdPosition(): IdPosition {\n    switch (this.getSubject()) {\n      case SubjectFlag.Self:\n        return IdPosition.None;\n      case SubjectFlag.OtherIdenIndex:\n        return IdPosition.Index;\n      case SubjectFlag.OtherIdenValue:\n        return IdPosition.Value;\n      default:\n        throw Constants.ERRORS.INVALID_SUBJECT_POSITION;\n    }\n  }\n\n  // SetValueDataInts sets data to value slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  setValueDataInts(slotA: bigint | null, slotB: bigint | null): void {\n    this._value[2] = this.setSlotInt(slotA, SlotName.ValueA);\n    this._value[3] = this.setSlotInt(slotB, SlotName.ValueB);\n  }\n  // SetValueDataBytes sets data to value slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  setValueDataBytes(slotA: Uint8Array, slotB: Uint8Array): void {\n    this._value[2] = this.setSlotBytes(slotA, SlotName.ValueA);\n    this._value[3] = this.setSlotBytes(slotB, SlotName.ValueB);\n  }\n  // SetValueData sets data to value slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  setValueData(slotA: ElemBytes, slotB: ElemBytes): void {\n    const slotsAsInts: bigint[] = [slotA.toBigInt(), slotB.toBigInt()];\n    if (!checkBigIntArrayInField(slotsAsInts)) {\n      throw Constants.ERRORS.DATA_OVERFLOW;\n    }\n    this._value[2] = slotA;\n    this._value[3] = slotB;\n  }\n  // SetIndexDataInts sets data to index slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  setIndexDataInts(slotA: bigint | null, slotB: bigint | null): void {\n    this._index[2] = this.setSlotInt(slotA, SlotName.IndexA);\n    this._index[3] = this.setSlotInt(slotB, SlotName.IndexB);\n  }\n  // SetIndexDataBytes sets data to index slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  setIndexDataBytes(slotA: Uint8Array | null, slotB: Uint8Array | null): void {\n    this._index[2] = this.setSlotBytes(slotA, SlotName.IndexA);\n    this._index[3] = this.setSlotBytes(slotB, SlotName.IndexB);\n  }\n\n  private setSlotBytes(value: Uint8Array | null, slotName: SlotName): ElemBytes {\n    const slot = new ElemBytes(value);\n    if (!checkBigIntInField(slot.toBigInt())) {\n      throw new ErrSlotOverflow(slotName);\n    }\n    return slot;\n  }\n\n  setFlagMerklized(s: MerklizedRootPosition): void {\n    let f: number;\n    switch (s) {\n      case MerklizedRootPosition.Index:\n        f = MerklizedFlag.Index;\n        break;\n      case MerklizedRootPosition.Value:\n        f = MerklizedFlag.Value;\n        break;\n      default:\n        f = MerklizedFlag.None;\n    }\n    // clean last 3 bits\n    this.index[0].bytes[Flags.ByteIdx] &= 0b00011111;\n    this.index[0].bytes[Flags.ByteIdx] |= f;\n  }\n\n  private getMerklized(): MerklizedFlag {\n    let mt = this.index[0].bytes[Flags.ByteIdx];\n    // clean all except last 3 bits\n    mt &= 0b11100000;\n    return mt as MerklizedFlag;\n  }\n\n  // GetMerklizedPosition returns the position at which the Merklized flag is stored.\n  getMerklizedPosition(): MerklizedRootPosition {\n    switch (this.getMerklized()) {\n      case MerklizedFlag.None:\n        return MerklizedRootPosition.None;\n      case MerklizedFlag.Index:\n        return MerklizedRootPosition.Index;\n      case MerklizedFlag.Value:\n        return MerklizedRootPosition.Value;\n      default:\n        throw Constants.ERRORS.INCORRECT_MERKLIZED_POSITION;\n    }\n  }\n\n  public setSlotInt(value: bigint | null, slotName: SlotName): ElemBytes {\n    if (!value) {\n      value = BigInt(0);\n    }\n    if (!checkBigIntInField(value)) {\n      throw new ErrSlotOverflow(slotName);\n    }\n    return new ElemBytes().setBigInt(value);\n  }\n  // SetIndexData sets data to index slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  setIndexData(slotA: ElemBytes, slotB: ElemBytes) {\n    const slotsAsInts: bigint[] = [slotA.toBigInt(), slotB.toBigInt()];\n    if (!checkBigIntArrayInField(slotsAsInts)) {\n      throw Constants.ERRORS.DATA_OVERFLOW;\n    }\n    this._index[2] = slotA;\n    this._index[3] = slotB;\n  }\n\n  resetExpirationDate(): void {\n    this.setFlagExpiration(false);\n    const bytes = Array.from({ length: Constants.NONCE_BYTES_LENGTH }, () => 0);\n    const arr = Array.from(this._value[0].bytes);\n    arr.splice(Constants.NONCE_BYTES_LENGTH, Constants.NONCE_BYTES_LENGTH, ...bytes);\n    this._value[0] = new ElemBytes(Uint8Array.from(arr));\n  }\n\n  // GetExpirationDate returns expiration date and flag. Flag is true if\n  // expiration date is present, false if null.\n  getExpirationDate(): Date | null {\n    if (this.getFlagExpiration()) {\n      const unixTimestamp = getUint64(this._value[0].bytes.slice(8, 16));\n      return getDateFromUnixTimestamp(Number(unixTimestamp));\n    }\n    return null;\n  }\n\n  // SetExpirationDate sets expiration date to dt\n  setExpirationDate(dt: Date) {\n    this.setFlagExpiration(true);\n    const bytes = getBytesFromUint64(BigInt(getUnixTimestamp(dt)));\n    const arr = Array.from(this._value[0].bytes);\n    arr.splice(Constants.NONCE_BYTES_LENGTH, Constants.NONCE_BYTES_LENGTH, ...bytes);\n    this._value[0] = new ElemBytes(Uint8Array.from(arr));\n  }\n\n  // GetRevocationNonce returns revocation nonce\n  getRevocationNonce(): bigint {\n    return getUint64(this._value[0].bytes.slice(0, 8));\n  }\n  // SetRevocationNonce sets claim's revocation nonce\n  setRevocationNonce(nonce: bigint): void {\n    const bytes = getBytesFromUint64(nonce);\n    if (bytes.length > Constants.NONCE_BYTES_LENGTH) {\n      throw new Error('Nonce length is not valid');\n    }\n    const arr = Array.from(this._value[0].bytes);\n    arr.splice(0, Constants.NONCE_BYTES_LENGTH, ...bytes);\n    this._value[0] = new ElemBytes(Uint8Array.from(arr));\n  }\n\n  getValueId(): Id {\n    return Id.fromBytes(this._value[1].bytes.slice(0, -1));\n  }\n\n  // SetValueId sets id to value. Removes id from index if any.\n  setValueId(id: Id): void {\n    this.resetIndexId();\n    this.setSubject(SubjectFlag.OtherIdenValue);\n    const arr = Array.from(this._index[1].bytes);\n    arr.splice(0, id.bytes.length, ...id.bytes);\n    this._value[1] = new ElemBytes(Uint8Array.from(arr));\n  }\n\n  private resetIndexId() {\n    this._index[1] = new ElemBytes(new Uint8Array(Constants.BYTES_LENGTH).fill(0));\n  }\n\n  private resetValueId(): void {\n    this._value[1] = new ElemBytes(new Uint8Array(Constants.BYTES_LENGTH).fill(0));\n  }\n\n  getIndexId(): Id {\n    return Id.fromBytes(this._index[1].bytes.slice(0, -1));\n  }\n\n  // SetIndexId sets id to index. Removes id from value if any.\n  setIndexId(id: Id): void {\n    this.resetValueId();\n    this.setSubject(SubjectFlag.OtherIdenIndex);\n    const arr = Array.from(this._index[1].bytes);\n    arr.splice(0, id.bytes.length, ...id.bytes);\n    this._index[1] = new ElemBytes(Uint8Array.from(arr));\n  }\n  // SetVersion sets claim's version\n  setVersion(ver: number) {\n    const bytes = putUint32(ver);\n    this._index[0].bytes[20] = bytes[0];\n    this._index[0].bytes[21] = bytes[1];\n    this._index[0].bytes[22] = bytes[2];\n    this._index[0].bytes[23] = bytes[3];\n  }\n  // GetVersion returns claim's version\n  getVersion(): number {\n    return getUint32(this._index[0].bytes.slice(20, 24));\n  }\n  // SetFlagUpdatable sets claim's flag `updatable`\n  setFlagUpdatable(val: boolean) {\n    if (val) {\n      this._index[0].bytes[Flags.ByteIdx] |= 0b1 << Flags.UpdatableBitIdx;\n    } else {\n      this._index[0].bytes[Flags.ByteIdx] &= ~(0b1 << Flags.UpdatableBitIdx);\n    }\n  }\n\n  // HIndex calculates the hash of the Index of the Claim\n  hIndex(): bigint {\n    return poseidon.hash(ElemBytes.elemBytesToInts(this._index));\n  }\n\n  // GetFlagUpdatable returns claim's flag `updatable`\n  getFlagUpdatable(): boolean {\n    const mask = 0b1 << Flags.UpdatableBitIdx;\n    return (this._index[0].bytes[Flags.ByteIdx] & mask) > 0;\n  }\n\n  // HValue calculates the hash of the Value of the Claim\n  hValue(): bigint {\n    return poseidon.hash(ElemBytes.elemBytesToInts(this._value));\n  }\n\n  // HiHv returns the HIndex and HValue of the Claim\n  hiHv(): { hi: bigint; hv: bigint } {\n    return { hi: this.hIndex(), hv: this.hValue() };\n  }\n\n  // SetIndexMerklizedRoot sets merklized root to index. Removes root from value[2] if any.\n  setIndexMerklizedRoot(r: bigint): void {\n    this.resetValueMerklizedRoot();\n    this.setFlagMerklized(MerklizedRootPosition.Index);\n    this.index[2] = this.setSlotInt(r, SlotName.IndexA);\n  }\n\n  resetIndexMerklizedRoot() {\n    this._index[2] = new ElemBytes(new Uint8Array(Constants.BYTES_LENGTH).fill(0));\n  }\n\n  // SetValueMerklizedRoot sets merklized root to value. Removes root from index[2] if any.\n  setValueMerklizedRoot(r: bigint): void {\n    this.resetIndexMerklizedRoot();\n    this.setFlagMerklized(MerklizedRootPosition.Value);\n    this.value[2] = this.setSlotInt(r, SlotName.ValueA);\n  }\n  resetValueMerklizedRoot() {\n    this._value[2] = new ElemBytes(new Uint8Array(Constants.BYTES_LENGTH).fill(0));\n  }\n\n  // GetMerklizedRoot returns merklized root from claim's index of value.\n  // Returns error ErrNoMerklizedRoot if MerklizedRoot is not set.\n  getMerklizedRoot(): bigint {\n    switch (this.getMerklized()) {\n      case MerklizedFlag.Index:\n        return this.index[2].toBigInt();\n      case MerklizedFlag.Value:\n        return this.value[2].toBigInt();\n      default:\n        throw Constants.ERRORS.NO_MERKLIZED_ROOT;\n    }\n  }\n\n  // resetId deletes Id from index and from value.\n  resetId(): void {\n    this.resetIndexId();\n    this.resetValueId();\n    this.setSubject(SubjectFlag.Self);\n  }\n  // GetId returns Id from claim's index of value.\n  // Returns error ErrNoId if Id is not set.\n  getId(): Id {\n    switch (this.getSubject()) {\n      case SubjectFlag.OtherIdenIndex:\n        return this.getIndexId();\n      case SubjectFlag.OtherIdenValue:\n        return this.getValueId();\n      default:\n        throw Constants.ERRORS.NO_ID;\n    }\n  }\n  // RawSlots returns raw bytes of claim's index and value\n  rawSlots(): { index: ElemBytes[]; value: ElemBytes[] } {\n    return {\n      index: this._index,\n      value: this._value\n    };\n  }\n  // RawSlotsAsInts returns slots as []bigint\n  rawSlotsAsInts(): bigint[] {\n    return [...ElemBytes.elemBytesToInts(this._index), ...ElemBytes.elemBytesToInts(this._value)];\n  }\n\n  clone(): Claim {\n    return JSON.parse(JSON.stringify(this));\n  }\n\n  marshalJson(): string[] {\n    return this.rawSlotsAsInts().map((b) => b.toString());\n  }\n\n  unMarshalJson(b: string): Claim {\n    const ints: bigint[] = JSON.parse(b).map((s: string) => BigInt(s));\n\n    if (ints.length !== this._index.length + this._value.length) {\n      throw new Error(\"invalid number of claim's slots\");\n    }\n    this._index = [];\n    this._value = [];\n    for (let i = 0, j = Constants.ELEM_BYTES_LENGTH; i < ints.length / 2; i++, j++) {\n      this._index[i] = new ElemBytes();\n      this._index[i].setBigInt(ints[i]);\n      this._value[i] = new ElemBytes();\n      this._value[i].setBigInt(ints[j]);\n    }\n    return this;\n  }\n\n  marshalBinary(): Uint8Array {\n    const getBytes = (src: ElemBytes[]) =>\n      src.reduce((acc: number[], cur: ElemBytes) => {\n        return [...acc, ...cur.bytes];\n      }, []);\n    return Uint8Array.from(getBytes(this._index).concat(getBytes(this._value)));\n  }\n\n  // Hex returns hex representation of binary claim\n  hex(): string {\n    const b = this.marshalBinary();\n    return Hex.encodeString(b);\n  }\n\n  fromHex(hex: string): Claim {\n    const b = Hex.decodeString(hex);\n    this.unMarshalBinary(b);\n    return this;\n  }\n\n  unMarshalBinary(data: Uint8Array): void {\n    const wantLen = 2 * Constants.ELEM_BYTES_LENGTH * Constants.BYTES_LENGTH;\n    if (data.length !== wantLen) {\n      throw new Error('unexpected length of input data');\n    }\n    this._index = [];\n    this._value = [];\n    for (let i = 0, j = Constants.ELEM_BYTES_LENGTH; i < Constants.ELEM_BYTES_LENGTH; i++, j++) {\n      this._index[i] = new ElemBytes(\n        data.slice(i * Constants.BYTES_LENGTH, (i + 1) * Constants.BYTES_LENGTH)\n      );\n      this._value[i] = new ElemBytes(\n        data.slice(j * Constants.BYTES_LENGTH, (j + 1) * Constants.BYTES_LENGTH)\n      );\n    }\n  }\n}\n\n// Option provides the ability to set different Claim's fields on construction\nexport type ClaimOption = (c: Claim) => void;\nexport class ClaimOptions {\n  // WithFlagUpdatable sets claim's flag `updatable`\n  static withFlagUpdatable(val: boolean): ClaimOption {\n    return (c: Claim) => c.setFlagUpdatable(val);\n  }\n\n  // WithVersion sets claim's version\n  static withVersion(ver: number): ClaimOption {\n    return (c: Claim) => c.setVersion(ver);\n  }\n\n  // WithIndexId sets Id to claim's index\n  static withIndexId(id: Id): ClaimOption {\n    return (c: Claim) => c.setIndexId(id);\n  }\n\n  // WithValueId sets Id to claim's value\n  static withValueId(id: Id): ClaimOption {\n    return (c: Claim) => c.setValueId(id);\n  }\n\n  // WithFlagMerklized sets claim's flag `merklized`\n  static withFlagMerklized(p: MerklizedRootPosition): ClaimOption {\n    return (c: Claim) => c.setFlagMerklized(p);\n  }\n\n  // WithId sets Id to claim's index or value depending on `pos`.\n  static withId(id: Id, pos: IdPosition): ClaimOption {\n    return (c: Claim) => {\n      switch (pos) {\n        case IdPosition.Index:\n          c.setIndexId(id);\n          break;\n        case IdPosition.Value:\n          c.setValueId(id);\n          break;\n        default:\n          throw Constants.ERRORS.INCORRECT_ID_POSITION;\n      }\n    };\n  }\n\n  // WithRevocationNonce sets claim's revocation nonce.\n  static withRevocationNonce(nonce: bigint): ClaimOption {\n    return (c: Claim) => c.setRevocationNonce(nonce);\n  }\n\n  // WithExpirationDate sets claim's expiration date to `dt`.\n  static withExpirationDate(dt: Date): ClaimOption {\n    return (c: Claim) => c.setExpirationDate(dt);\n  }\n\n  // WithIndexData sets data to index slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  static withIndexData(slotA: ElemBytes, slotB: ElemBytes): ClaimOption {\n    return (c: Claim) => c.setIndexData(slotA, slotB);\n  }\n\n  // WithIndexDataBytes sets data to index slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  static withIndexDataBytes(slotA: Uint8Array | null, slotB: Uint8Array | null): ClaimOption {\n    return (c: Claim) => c.setIndexDataBytes(slotA, slotB);\n  }\n\n  // WithIndexDataInts sets data to index slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  static withIndexDataInts(slotA: bigint | null, slotB: bigint | null): ClaimOption {\n    return (c: Claim) => c.setIndexDataInts(slotA, slotB);\n  }\n\n  // WithValueData sets data to value slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  static withValueData(slotA: ElemBytes, slotB: ElemBytes): ClaimOption {\n    return (c: Claim) => c.setValueData(slotA, slotB);\n  }\n\n  // WithValueDataBytes sets data to value slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  static withValueDataBytes(slotA: Uint8Array, slotB: Uint8Array): ClaimOption {\n    return (c: Claim) => c.setValueDataBytes(slotA, slotB);\n  }\n\n  // WithValueDataInts sets data to value slots A & B.\n  // Returns ErrSlotOverflow if slotA or slotB value are too big.\n  static withValueDataInts(slotA: bigint | null, slotB: bigint | null): ClaimOption {\n    return (c: Claim) => c.setValueDataInts(slotA, slotB);\n  }\n\n  // WithIndexMerklizedRoot sets root to index i_2\n  // Returns ErrSlotOverflow if root value are too big.\n  static withIndexMerklizedRoot(r: bigint): ClaimOption {\n    return (c: Claim) => {\n      c.setFlagMerklized(MerklizedRootPosition.Index);\n      c.index[2] = c.setSlotInt(r, SlotName.IndexA);\n    };\n  }\n\n  // WithValueMerklizedRoot sets root to value v_2\n  // Returns ErrSlotOverflow if root value are too big.\n  static withValueMerklizedRoot(r: bigint): ClaimOption {\n    return (c: Claim) => {\n      c.setFlagMerklized(MerklizedRootPosition.Value);\n      c.value[2] = c.setSlotInt(r, SlotName.ValueA);\n    };\n  }\n\n  // WithMerklizedRoot sets root to value v_2 or index i_2\n  // Returns ErrSlotOverflow if root value are too big.\n  static withMerklizedRoot(r: bigint, pos: MerklizedRootPosition): ClaimOption {\n    return (c: Claim) => {\n      switch (pos) {\n        case MerklizedRootPosition.Index:\n          c.setFlagMerklized(MerklizedRootPosition.Index);\n          c.index[2] = c.setSlotInt(r, SlotName.IndexA);\n          break;\n        case MerklizedRootPosition.Value:\n          c.setFlagMerklized(MerklizedRootPosition.Value);\n          c.value[2] = c.setSlotInt(r, SlotName.ValueA);\n          break;\n        default:\n          throw Constants.ERRORS.INCORRECT_MERKLIZED_POSITION;\n      }\n    };\n  }\n}\n","import { Constants, DidMethodByte, DidMethodNetwork } from '../constants';\n\n// DIDNetworkFlag is a structure to represent DID blockchain and network id\nexport class DIDNetworkFlag {\n  constructor(public readonly blockchain: string, public readonly networkId: string) {}\n\n  toString(): string {\n    return `${this.blockchain}:${this.networkId}`;\n  }\n\n  static fromString(s: string): DIDNetworkFlag {\n    const [blockchain, networkId] = s.split(':');\n    return new DIDNetworkFlag(blockchain.replace('_', ''), networkId.replace('_', ''));\n  }\n}\n\n// BuildDIDType builds bytes type from chain and network\nexport function buildDIDType(method: string, blockchain: string, network: string): Uint8Array {\n  const fb = DidMethodByte[method];\n  if (!fb) {\n    throw Constants.ERRORS.UNSUPPORTED_DID_METHOD;\n  }\n  const methodFn = DidMethodNetwork[method];\n  if (!methodFn) {\n    throw Constants.ERRORS.NETWORK_NOT_SUPPORTED_FOR_DID;\n  }\n\n  const sb: number | undefined = methodFn[new DIDNetworkFlag(blockchain, network).toString()];\n\n  if (typeof sb !== 'number') {\n    throw new Error(\n      `blockchain ${blockchain.toString() ?? '-'} and network ${\n        network.toString() ?? '-'\n      } is not defined in core lib`\n    );\n  }\n\n  return Uint8Array.from([fb, sb]);\n}\n\n// FindNetworkIDForDIDMethodByValue finds network by byte value\nexport function findNetworkIDForDIDMethodByValue(method: string, byteNumber: number): string {\n  const methodMap = DidMethodNetwork[method];\n  if (!methodMap) {\n    throw Constants.ERRORS.UNSUPPORTED_DID_METHOD;\n  }\n  for (const [key, value] of Object.entries(methodMap)) {\n    if (value === byteNumber) {\n      return DIDNetworkFlag.fromString(key).networkId;\n    }\n  }\n  throw Constants.ERRORS.NETWORK_NOT_SUPPORTED_FOR_DID;\n}\n\n// findBlockchainForDIDMethodByValue finds blockchain type by byte value\nexport function findBlockchainForDIDMethodByValue(method: string, byteNumber: number): string {\n  const methodMap = DidMethodNetwork[method];\n  if (!methodMap) {\n    throw new Error(\n      `${Constants.ERRORS.NETWORK_NOT_SUPPORTED_FOR_DID}: did method ${method} is not defined in core lib`\n    );\n  }\n  for (const [key, value] of Object.entries(methodMap)) {\n    if (value === byteNumber) {\n      return DIDNetworkFlag.fromString(key).blockchain;\n    }\n  }\n  throw Constants.ERRORS.UNSUPPORTED_BLOCKCHAIN_FOR_DID;\n}\n\n// findDIDMethodByValue finds did method by its byte value\nexport function findDIDMethodByValue(byteNumber: number): string {\n  for (const [key, value] of Object.entries(DidMethodByte)) {\n    if (value === byteNumber) {\n      return key;\n    }\n  }\n  throw Constants.ERRORS.UNSUPPORTED_DID_METHOD;\n}\n","export class Param {\n  constructor(public name: string, public value: string) {}\n\n  toString(): string {\n    if (!this.name) {\n      return '';\n    }\n    if (!this.value) {\n      return this.name;\n    }\n    return `${this.name}=${this.value}`;\n  }\n}\n\nexport interface IDID {\n  method: string;\n  id: string;\n  idStrings: string[];\n  params: Param[];\n  path: string;\n  pathSegments: string[];\n  query: string;\n  fragment: string;\n}\n\nexport const initDIDParams: IDID = Object.freeze({\n  method: '',\n  id: '',\n  idStrings: [],\n  params: [],\n  path: '',\n  pathSegments: [],\n  query: '',\n  fragment: ''\n});\n","import { IDID, Param, initDIDParams } from './types';\nimport { StringUtils } from '../utils';\n\n// a step in the parser state machine that returns the next step\ntype ParserStep = () => ParserStep | null;\n\nexport class Parser {\n  currentIndex = 0; // index in the input which the parser is currently processing:\n  out: IDID = { ...initDIDParams }; // the output DID that the parser will assemble as it steps through its state machine  // an error in the parser state machine\n\n  constructor(private readonly input: string) {}\n\n  checkLength(): ParserStep | null {\n    const inputLength = this.input.length;\n\n    if (inputLength < 7) {\n      throw new Error('input length is less than 7');\n    }\n\n    return this.parseScheme.bind(this);\n  }\n\n  // parseScheme is a parserStep that validates that the input begins with 'did:'\n  parseScheme(): ParserStep | null {\n    const currentIndex = 3; // 4 bytes in 'did:', i.e index 3\n    // the grammar requires `did:` prefix\n    if (this.input.slice(0, currentIndex + 1) !== 'did:') {\n      throw new Error(\"input does not begin with 'did:' prefix\");\n    }\n\n    this.currentIndex = currentIndex;\n    return this.parseMethod.bind(this);\n  }\n\n  parseMethod(): ParserStep | null {\n    const input = this.input;\n    const inputLength = input.length;\n    let currentIndex = this.currentIndex + 1;\n    const startIndex = currentIndex;\n\n    for (;;) {\n      if (currentIndex === inputLength) {\n        // we got to the end of the input and didn't find a second ':'\n        throw new Error('input does not have a second `:` marking end of method name');\n      }\n\n      // read the input character at currentIndex\n      const char = input[currentIndex];\n\n      if (char === ':') {\n        // we've found the second : in the input that marks the end of the method\n        if (currentIndex === startIndex) {\n          // return error is method is empty, ex- did::1234\n          throw new Error(`method is empty, ${currentIndex}`);\n        }\n        break;\n      }\n\n      // as per the grammar method can only be made of digits 0-9 or small letters a-z\n      if (StringUtils.isNotDigit(char) && StringUtils.isNotSmallLetter(char)) {\n        throw new Error(`\"character is not a-z OR 0-9, ${currentIndex}`);\n      }\n\n      // move to the next char\n      currentIndex = currentIndex + 1;\n    }\n\n    // set parser state\n    this.currentIndex = currentIndex;\n    this.out.method = input.slice(startIndex, currentIndex);\n\n    // method is followed by specific-idstring, parse that next\n    return this.parseId.bind(this);\n  }\n\n  parseId(): ParserStep | null {\n    const input = this.input;\n    const inputLength = input.length;\n    let currentIndex = this.currentIndex + 1;\n    const startIndex = currentIndex;\n\n    let next: ParserStep | null = null;\n\n    for (;;) {\n      if (currentIndex === inputLength) {\n        // we've reached end of input, no next state\n        next = null;\n        break;\n      }\n\n      const char = input[currentIndex];\n\n      if (char === ':') {\n        // encountered : input may have another idstring, parse ID again\n        next = this.parseId;\n        break;\n      }\n\n      if (char === ';') {\n        // encountered ; input may have a parameter, parse that next\n        next = this.parseParamName;\n        break;\n      }\n\n      if (char === '/') {\n        // encountered / input may have a path following specific-idstring, parse that next\n        next = this.parsePath;\n        break;\n      }\n\n      if (char === '?') {\n        // encountered ? input may have a query following specific-idstring, parse that next\n        next = this.parseQuery;\n        break;\n      }\n\n      if (char === '#') {\n        // encountered # input may have a fragment following specific-idstring, parse that next\n        next = this.parseFragment;\n        break;\n      }\n\n      // make sure current char is a valid idchar\n      // idchar = ALPHA / DIGIT / \".\" / \"-\"\n      if (StringUtils.isNotValidIDChar(char)) {\n        throw new Error(`byte is not ALPHA OR DIGIT OR '.' OR '-', ${currentIndex}`);\n      }\n\n      // move to the next char\n      currentIndex = currentIndex + 1;\n    }\n\n    if (currentIndex === startIndex) {\n      // idstring length is zero\n      // from the grammar:\n      //   idstring = 1*idchar\n      // return error because idstring is empty, ex- did:a::123:456\n      throw new Error(`idstring must be atleast one char long, ${currentIndex}`);\n    }\n\n    // set parser state\n    this.currentIndex = currentIndex;\n    this.out.idStrings = [...this.out.idStrings, input.slice(startIndex, currentIndex)];\n\n    // return the next parser step\n    return next ? next.bind(this) : null;\n  }\n\n  parseParamName(): ParserStep | null {\n    const input = this.input;\n    const startIndex = this.currentIndex + 1;\n    const next = this.paramTransition();\n    const currentIndex = this.currentIndex;\n\n    if (currentIndex === startIndex) {\n      throw new Error(`Param name must be at least one char long, ${currentIndex}`);\n    }\n\n    // Create a new param with the name\n    this.out.params = [...this.out.params, new Param(input.slice(startIndex, currentIndex), '')];\n\n    // return the next parser step\n    return next ? next.bind(this) : null;\n  }\n\n  parseParamValue(): ParserStep | null {\n    const input = this.input;\n    const startIndex = this.currentIndex + 1;\n    const next = this.paramTransition();\n    const currentIndex = this.currentIndex;\n    this.out.params[this.out.params.length - 1].value = input.slice(startIndex, currentIndex);\n    return next ? next.bind(this) : null;\n  }\n\n  paramTransition(): ParserStep | null {\n    const input = this.input;\n    const inputLength = input.length;\n    let currentIndex = this.currentIndex + 1;\n\n    let indexIncrement: number;\n    let next: ParserStep | null;\n    let percentEncoded: boolean;\n\n    for (;;) {\n      if (currentIndex === inputLength) {\n        // we've reached end of input, no next state\n        next = null;\n        break;\n      }\n\n      const char = input[currentIndex];\n\n      if (char === ';') {\n        // encountered : input may have another param, parse paramName again\n        next = this.parseParamName;\n        break;\n      }\n\n      // Separate steps for name and value?\n      if (char === '=') {\n        // parse param value\n        next = this.parseParamValue;\n        break;\n      }\n\n      if (char === '/') {\n        // encountered / input may have a path following current param, parse that next\n        next = this.parsePath;\n        break;\n      }\n\n      if (char === '?') {\n        // encountered ? input may have a query following current param, parse that next\n        next = this.parseQuery;\n        break;\n      }\n\n      if (char == '#') {\n        // encountered # input may have a fragment following current param, parse that next\n        next = this.parseFragment;\n        break;\n      }\n\n      if (char == '%') {\n        // a % must be followed by 2 hex digits\n        if (\n          currentIndex + 2 >= inputLength ||\n          StringUtils.isNotHexDigit(input[currentIndex + 1]) ||\n          StringUtils.isNotHexDigit(input[currentIndex + 2])\n        ) {\n          throw new Error(`% is not followed by 2 hex digits', ${currentIndex}`);\n        }\n        // if we got here, we're dealing with percent encoded char, jump three chars\n        percentEncoded = true;\n        indexIncrement = 3;\n      } else {\n        // not percent encoded\n        percentEncoded = false;\n        indexIncrement = 1;\n      }\n\n      // make sure current char is a valid param-char\n      // idchar = ALPHA / DIGIT / \".\" / \"-\"\n      if (!percentEncoded && StringUtils.isNotValidParamChar(char)) {\n        throw new Error(`character is not allowed in param - ${char}',  ${currentIndex}`);\n      }\n\n      // move to the next char\n      currentIndex = currentIndex + indexIncrement;\n    }\n\n    // set parser state\n    this.currentIndex = currentIndex;\n\n    return next ? next.bind(this) : null;\n  }\n\n  parsePath(): ParserStep | null {\n    const input = this.input;\n    const inputLength = input.length;\n    let currentIndex = this.currentIndex + 1;\n    const startIndex = currentIndex;\n\n    let indexIncrement: number;\n    let next: ParserStep | null;\n    let percentEncoded: boolean;\n\n    for (;;) {\n      if (currentIndex === inputLength) {\n        next = null;\n        break;\n      }\n\n      const char = input[currentIndex];\n\n      if (char === '/') {\n        // encountered / input may have another path segment, try to parse that next\n        next = this.parsePath;\n        break;\n      }\n\n      if (char === '?') {\n        // encountered ? input may have a query following path, parse that next\n        next = this.parseQuery;\n        break;\n      }\n\n      if (char === '%') {\n        // a % must be followed by 2 hex digits\n        if (\n          currentIndex + 2 >= inputLength ||\n          StringUtils.isNotHexDigit(input[currentIndex + 1]) ||\n          StringUtils.isNotHexDigit(input[currentIndex + 2])\n        ) {\n          throw new Error(`% is not followed by 2 hex digits, ${currentIndex}`);\n        }\n        // if we got here, we're dealing with percent encoded char, jump three chars\n        percentEncoded = true;\n        indexIncrement = 3;\n      } else {\n        // not pecent encoded\n        percentEncoded = false;\n        indexIncrement = 1;\n      }\n\n      // pchar = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n      if (!percentEncoded && StringUtils.isNotValidPathChar(char)) {\n        throw new Error(`character is not allowed in path, ${currentIndex}`);\n      }\n\n      // move to the next char\n      currentIndex = currentIndex + indexIncrement;\n    }\n\n    if (currentIndex == startIndex && this.out.pathSegments.length === 0) {\n      throw new Error(`first path segment must have atleast one character, ${currentIndex}`);\n    }\n\n    // update parser state\n    this.currentIndex = currentIndex;\n    this.out.pathSegments = [...this.out.pathSegments, input.slice(startIndex, currentIndex)];\n\n    return next ? next.bind(this) : null;\n  }\n\n  parseQuery(): ParserStep | null {\n    const input = this.input;\n    const inputLength = input.length;\n    let currentIndex = this.currentIndex + 1;\n    const startIndex = currentIndex;\n\n    let indexIncrement: number;\n    let next: ParserStep | null = null;\n    let percentEncoded: boolean;\n\n    for (;;) {\n      if (currentIndex === inputLength) {\n        break;\n      }\n\n      const char = input[currentIndex];\n\n      if (char === '#') {\n        // encountered # input may have a fragment following the query, parse that next\n        next = this.parseFragment;\n        break;\n      }\n\n      if (char === '%') {\n        // a % must be followed by 2 hex digits\n        if (\n          currentIndex + 2 >= inputLength ||\n          StringUtils.isNotHexDigit(input[currentIndex + 1]) ||\n          StringUtils.isNotHexDigit(input[currentIndex + 2])\n        ) {\n          throw new Error(`% is not followed by 2 hex digits, ${currentIndex}`);\n        }\n        // if we got here, we're dealing with percent encoded char, jump three chars\n        percentEncoded = true;\n        indexIncrement = 3;\n      } else {\n        // not pecent encoded\n        percentEncoded = false;\n        indexIncrement = 1;\n      }\n      if (!percentEncoded && StringUtils.isNotValidQueryOrFragmentChar(char)) {\n        throw new Error(`character is not allowed in query - ${char}`);\n      }\n\n      // move to the next char\n      currentIndex = currentIndex + indexIncrement;\n    }\n\n    // update parser state\n    this.currentIndex = currentIndex;\n    this.out.query = input.slice(startIndex, currentIndex);\n\n    return next ? next.bind(this) : null;\n  }\n\n  parseFragment(): ParserStep | null {\n    const input = this.input;\n    const inputLength = this.input.length;\n    let currentIndex = this.currentIndex + 1;\n    const startIndex = currentIndex;\n\n    let indexIncrement: number;\n    let percentEncoded: boolean;\n\n    for (;;) {\n      if (currentIndex === inputLength) {\n        break;\n      }\n\n      const char = input[currentIndex];\n\n      if (char === '%') {\n        // a % must be followed by 2 hex digits\n        if (\n          currentIndex + 2 >= inputLength ||\n          StringUtils.isNotHexDigit(input[currentIndex + 1]) ||\n          StringUtils.isNotHexDigit(input[currentIndex + 2])\n        ) {\n          throw new Error(`% is not followed by 2 hex digits, ${currentIndex}`);\n        }\n        // if we got here, we're dealing with percent encoded char, jump three chars\n        percentEncoded = true;\n        indexIncrement = 3;\n      } else {\n        // not pecent encoded\n        percentEncoded = false;\n        indexIncrement = 1;\n      }\n\n      if (!percentEncoded && StringUtils.isNotValidQueryOrFragmentChar(char)) {\n        throw new Error(`character is not allowed in fragment - ${char}`);\n      }\n\n      // move to the next char\n      currentIndex = currentIndex + indexIncrement;\n    }\n\n    // update parser state\n    this.currentIndex = currentIndex;\n    this.out.fragment = input.slice(startIndex, currentIndex);\n\n    // no more parsing needed after a fragment,\n    // cause the state machine to exit by returning nil\n    return null;\n  }\n}\n","import { Id } from '../id';\nimport {\n  Blockchain,\n  Constants,\n  DidMethodByte,\n  DidMethodNetwork,\n  DidMethod,\n  NetworkId\n} from '../constants';\nimport { BytesHelper } from '../elemBytes';\nimport {\n  DIDNetworkFlag,\n  findBlockchainForDIDMethodByValue,\n  findDIDMethodByValue,\n  findNetworkIDForDIDMethodByValue\n} from './did-helper';\nimport { Parser } from './did-parser';\nimport { IDID, Param } from './types';\nimport { sha256 } from '@iden3/js-crypto';\nimport { encoder } from '../utils';\n// DID Decentralized Identifiers (DIDs)\n// https://w3c.github.io/did-core/#did-syntax\n\nexport class DID {\n  method = '';\n  id = '';\n  idStrings: string[] = [];\n  params: Param[] = [];\n  path = '';\n  pathSegments: string[] = [];\n  query = '';\n  fragment = '';\n\n  constructor(d?: Partial<IDID>) {\n    if (d) {\n      Object.assign(this, d);\n    }\n  }\n\n  isUrl(): boolean {\n    return (\n      this.params.length > 0 ||\n      !!this.path ||\n      this.pathSegments.length > 0 ||\n      !!this.query ||\n      !!this.fragment\n    );\n  }\n\n  string(): string {\n    const buff = ['did:'];\n    if (this.method) {\n      buff.push(`${this.method}:`);\n    } else {\n      return '';\n    }\n\n    if (this.id) {\n      buff.push(this.id);\n    } else if (this.idStrings.length) {\n      buff.push(this.idStrings.join(':'));\n    } else {\n      return '';\n    }\n\n    if (this.params.length) {\n      for (const param of this.params) {\n        const p = param.toString();\n        if (p) {\n          buff.push(`;${p}`);\n        } else {\n          return '';\n        }\n      }\n    }\n\n    if (this.path) {\n      buff.push(`/${this.path}`);\n    } else if (this.pathSegments.length) {\n      buff.push(`/${this.pathSegments.join('/')}`);\n    }\n\n    if (this.query) {\n      buff.push(`?${this.query}`);\n    }\n\n    if (this.fragment) {\n      buff.push(`#${this.fragment}`);\n    }\n\n    return buff.join('');\n  }\n\n  toJSON() {\n    return this.string();\n  }\n\n  static parse(s: string): DID {\n    const parser = new Parser(s);\n\n    let parserState = parser.checkLength();\n\n    while (parserState) {\n      parserState = parserState();\n    }\n\n    parser.out.id = parser.out.idStrings.join(':');\n    parser.out.path = parser.out.pathSegments.join('/');\n\n    return new DID(parser.out);\n  }\n\n  static decodePartsFromId(id: Id): {\n    method: string;\n    blockchain: string;\n    networkId: string;\n  } {\n    const method = findDIDMethodByValue(id.bytes[0]);\n    const blockchain = findBlockchainForDIDMethodByValue(method, id.bytes[1]);\n\n    const networkId = findNetworkIDForDIDMethodByValue(method, id.bytes[1]);\n\n    return { method, blockchain, networkId };\n  }\n\n  static networkIdFromId(id: Id): string {\n    return DID.throwIfDIDUnsupported(id).networkId;\n  }\n\n  static methodFromId(id: Id): string {\n    return DID.throwIfDIDUnsupported(id).method;\n  }\n\n  static blockchainFromId(id: Id): string {\n    return DID.throwIfDIDUnsupported(id).blockchain;\n  }\n\n  private static throwIfDIDUnsupported(id: Id): {\n    method: string;\n    blockchain: string;\n    networkId: string;\n  } {\n    const { method, blockchain, networkId } = DID.decodePartsFromId(id);\n\n    if (DID.isUnsupported(method, blockchain, networkId)) {\n      throw new Error(`${Constants.ERRORS.UNKNOWN_DID_METHOD.message}: unsupported DID`);\n    }\n\n    return { method, blockchain, networkId };\n  }\n\n  // DIDGenesisFromIdenState calculates the genesis ID from an Identity State and returns it as DID\n  static newFromIdenState(typ: Uint8Array, state: bigint): DID {\n    const id = Id.idGenesisFromIdenState(typ, state);\n\n    return DID.parseFromId(id);\n  }\n\n  // NewDID creates a new *w3c.DID from the type and the genesis\n  static new(typ: Uint8Array, genesis: Uint8Array): DID {\n    return DID.parseFromId(new Id(typ, genesis));\n  }\n\n  // ParseDIDFromID returns DID from ID\n  static parseFromId(id: Id): DID {\n    if (!BytesHelper.checkChecksum(id.bytes)) {\n      throw new Error(`${Constants.ERRORS.UNSUPPORTED_ID.message}: invalid checksum`);\n    }\n    const { method, blockchain, networkId } = DID.throwIfDIDUnsupported(id);\n\n    const didParts = [Constants.DID.DID_SCHEMA, method.toString(), blockchain.toString()];\n    if (networkId) {\n      didParts.push(networkId.toString());\n    }\n    didParts.push(id.string());\n\n    const didString = didParts.join(':');\n\n    const did = DID.parse(didString);\n\n    return did;\n  }\n\n  static idFromDID(did: DID): Id {\n    let id: Id;\n    try {\n      id = DID.getIdFromDID(did);\n    } catch (error) {\n      if ((error as Error).message === Constants.ERRORS.UNKNOWN_DID_METHOD.message) {\n        return DID.idFromUnsupportedDID(did);\n      }\n      throw error;\n    }\n\n    return id;\n  }\n\n  static isUnsupported(method: string, blockchain: string, networkId: string): boolean {\n    return (\n      method == DidMethod.Other &&\n      blockchain == Blockchain.Unknown &&\n      networkId == NetworkId.Unknown\n    );\n  }\n\n  static idFromUnsupportedDID(did: DID): Id {\n    const hash = sha256(encoder.encode(did.string()));\n\n    const genesis = new Uint8Array(27);\n    const idSlice = hash.slice(hash.length - Constants.GENESIS_LENGTH);\n    for (let i = 0; i < genesis.length; i++) {\n      genesis[i] = idSlice[i] ?? 0;\n    }\n    const flg = new DIDNetworkFlag(Blockchain.Unknown, NetworkId.Unknown);\n    const tp = Uint8Array.from([\n      DidMethodByte[DidMethod.Other],\n      DidMethodNetwork[DidMethod.Other][flg.toString()]\n    ]);\n    return new Id(tp, genesis);\n  }\n\n  private static getIdFromDID(did: DID): Id {\n    const method = did.method;\n    const methodByte = DidMethodByte[method];\n    if (!methodByte || method === DidMethod.Other) {\n      throw Constants.ERRORS.UNKNOWN_DID_METHOD;\n    }\n\n    if (did.idStrings.length > 3 || did.idStrings.length < 2) {\n      throw new Error(`${Constants.ERRORS.INCORRECT_DID}: unexpected number of ID strings`);\n    }\n\n    const id = Id.fromString(did.idStrings[did.idStrings.length - 1]);\n\n    if (!BytesHelper.checkChecksum(id.bytes)) {\n      throw new Error(`${Constants.ERRORS.INCORRECT_DID}: incorrect ID checksum`);\n    }\n\n    const { method: method2, blockchain, networkId } = DID.decodePartsFromId(id);\n\n    if (method2.toString() !== method.toString()) {\n      throw new Error(`${Constants.ERRORS.INCORRECT_DID}: methods in Id and DID are different`);\n    }\n\n    if (blockchain.toString() !== did.idStrings[0]) {\n      throw new Error(`${Constants.ERRORS.INCORRECT_DID}: blockchains in ID and DID are different`);\n    }\n\n    if (did.idStrings.length > 2 && networkId.toString() != did.idStrings[1]) {\n      throw new Error(`${Constants.ERRORS.INCORRECT_DID}: networkIDs in Id and DID are different`);\n    }\n\n    return id;\n  }\n}\n","import {\n  Blockchain,\n  ChainIds,\n  DidMethod,\n  DidMethodByte,\n  DidMethodNetwork,\n  NetworkId\n} from './constants';\nimport { DID } from './did';\n\nexport const registerBlockchain = (blockchain: string): void => {\n  Blockchain[blockchain] = blockchain;\n};\n\nexport const registerNetwork = (network: string): void => {\n  NetworkId[network] = network;\n};\n\nexport const registerDidMethod = (method: string, byte: number): void => {\n  const max = DidMethodByte[DidMethod.Other];\n\n  if (byte >= max) {\n    throw new Error(\n      `Can't register DID method byte: current '${byte.toString(2)}', maximum byte allowed: '${(\n        max - 1\n      ).toString(2)}'`\n    );\n  }\n\n  if (typeof DidMethodByte[method] === 'number' && DidMethodByte[method] === byte) {\n    return;\n  }\n\n  if (Object.values(DidMethodByte).includes(byte)) {\n    throw new Error(\n      `can't register method '${method}' because DID method byte '${byte.toString(\n        2\n      )}' already registered for another method`\n    );\n  }\n\n  DidMethod[method] = method;\n  DidMethodByte[method] = byte;\n};\n\n/**\n * Register chain ID for a blockchain and network.\n *\n * @param {string} blockchain\n * @param {string} network\n * @param {number} [chainId]\n * @returns {void}\n */\nexport const registerChainId = (blockchain: string, network: string, chainId: number): void => {\n  const key = `${blockchain}:${network}`;\n\n  if (typeof ChainIds[key] === 'number' && ChainIds[key] === chainId) {\n    return;\n  }\n\n  if (Object.values(ChainIds).includes(chainId)) {\n    throw new Error(\n      `can't register chainId ${chainId} for '${blockchain}:${network}' because it's already registered for another chain id`\n    );\n  }\n\n  ChainIds[key] = chainId;\n};\n\n/**\n * Get chain ID by a blockchain and network.\n *\n * @param {string} blockchain\n * @param {string} [network]\n * @returns {number}\n */\nexport const getChainId = (blockchain: string, network?: string): number => {\n  if (network) {\n    blockchain += `:${network}`;\n  }\n  const chainId = ChainIds[blockchain];\n  if (!chainId) {\n    throw new Error(`chainId not found for ${blockchain}`);\n  }\n  return chainId;\n};\n\n/**\n * ChainIDfromDID returns chain name from w3c.DID\n *\n * @param {DID} did\n * @returns {number}\n */\nexport const chainIDfromDID = (did: DID): number => {\n  const id = DID.idFromDID(did);\n\n  const blockchain = DID.blockchainFromId(id);\n\n  const networkId = DID.networkIdFromId(id);\n\n  const chainId = ChainIds[`${blockchain}:${networkId}`];\n  if (typeof chainId !== 'number') {\n    throw new Error(`chainId not found for ${blockchain}:${networkId}`);\n  }\n\n  return chainId;\n};\n\n/**\n * Register a DID method with a byte value.\n * https://docs.iden3.io/getting-started/identity/identity-types/#regular-identity\n * @param {{\n *   method: DidMethodName;  DID method name\n *   methodByte?: number; put DID method byte value in case you want to register new DID method\n *   blockchain: BlockchainName;  blockchain name\n *   network: NetworkName;  network name\n *   networkFlag: number;  network flag\n *   chainId?: number;  put  chain ID in case you need to use it\n * }} {\n *   method,\n *   methodByte,\n *   blockchain,\n *   network,\n *   chainId,\n *   networkFlag\n * }\n */\nexport const registerDidMethodNetwork = ({\n  method,\n  methodByte,\n  blockchain,\n  network,\n  chainId,\n  networkFlag\n}: {\n  method: string;\n  methodByte?: number;\n  blockchain: string;\n  network: string;\n  networkFlag: number;\n  chainId?: number;\n}): void => {\n  registerBlockchain(blockchain);\n  registerNetwork(network);\n  if (typeof methodByte === 'number') {\n    registerDidMethod(method, methodByte);\n  }\n\n  if (!DidMethodNetwork[method]) {\n    DidMethodNetwork[method] = {};\n  }\n\n  if (typeof chainId === 'number') {\n    registerChainId(blockchain, network, chainId);\n  }\n\n  const key = `${blockchain}:${network}`;\n\n  const existedFlag = DidMethodNetwork[method][key];\n  if (typeof existedFlag === 'number' && existedFlag === networkFlag) {\n    return;\n  }\n\n  if (Object.values(DidMethodNetwork[method]).includes(networkFlag)) {\n    throw new Error(\n      `DID network flag ${networkFlag.toString(\n        2\n      )} is already registered for the another network id for '${method}' method`\n    );\n  }\n\n  DidMethodNetwork[method][key] = networkFlag;\n};\n"],"names":["Constants","Object","freeze","ERRORS","DATA_OVERFLOW","Error","INCORRECT_ID_POSITION","NO_ID","INVALID_SUBJECT_POSITION","INCORRECT_MERKLIZED_POSITION","NO_MERKLIZED_ROOT","NETWORK_NOT_SUPPORTED_FOR_DID","UNSUPPORTED_BLOCKCHAIN_FOR_DID","UNSUPPORTED_DID_METHOD","UNKNOWN_DID_METHOD","INCORRECT_DID","UNSUPPORTED_ID","SCHEMA","HASH_LENGTH","ETH_ADDRESS_LENGTH","BYTES_LENGTH","ELEM_BYTES_LENGTH","NONCE_BYTES_LENGTH","Q","BigInt","ID","TYPE_DEFAULT","Uint8Array","from","TYPE_READONLY","ID_LENGTH","DID","DID_SCHEMA","GENESIS_LENGTH","Blockchain","Ethereum","Polygon","ZkEVM","Privado","Unknown","NoChain","ReadOnly","NetworkId","Main","Mumbai","Amoy","Goerli","Sepolia","Test","NoNetwork","DidMethod","Iden3","PolygonId","Other","ChainIds","DidMethodByte","blockchainNetworkMap","DidMethodNetwork","encoder","TextEncoder","fromLittleEndian","bytes","n256","result","base","forEach","byte","fromBigEndian","reverse","toLittleEndian","bigNumber","len","i","Number","toBigEndian","putUint32","n","buf","ArrayBuffer","DataView","setUint32","getUint32","arr","buffer","slice","byteOffset","byteLength","putUint64","setBigUint64","getUint64","getBigUint64","getUnixTimestamp","d","Math","floor","getTime","getDateFromUnixTimestamp","Date","checkBigIntInField","a","checkBigIntArrayInField","every","idenState","clr","rer","ror","poseidon","hash","StringUtils","isNotValidIDChar","char","isNotAlpha","isNotDigit","isNotValidParamChar","isNotValidQueryOrFragmentChar","isNotValidPathChar","isNotUnreservedOrSubdelim","isNotHexDigit","isNotSmallLetter","isNotBigLetter","genesisFromEthAddress","addr","BytesHelper","intToBytes","int","intToNBytes","checkChecksum","typ","genesis","checksum","decomposeBytes","length","JSON","stringify","c","calculateChecksum","b","s","reduce","acc","cur","hashBytes","str","sha256","encode","hexToBytes","Hex","decodeString","bytesToHex","hex","current","push","toString","join","bytesToInt","ElemBytes","constructor","this","_bytes","value","toBigInt","setBigInt","slotFromHex","set","encodeString","elemBytesToInts","elements","element","fromInt","SchemaHash","marshalTextBytes","marshalText","newSchemaHashFromHex","schemaEncodedBytes","newSchemaHashFromInt","start","bigInt","authSchemaHash","Id","_checksum","getFromBytes","string","base58FromBytes","type","equal","id","marshal","unMarshal","fromString","TextDecoder","decode","fromBytes","base58ToBytes","fromBigInt","profileId","nonce","bigIntHash","idGenesisFromIdenState","state","idenStateData","idGenesisBytes","ethAddressFromId","SlotName","SubjectFlag","IdPosition","MerklizedFlag","MerklizedRootPosition","Flags","ErrSlotOverflow","msg","super","setPrototypeOf","prototype","Claim","_index","_value","newClaim","sh","args","setSchemaHash","fn","getSchemaHash","index","Array","fill","setSubject","ByteIdx","getSubject","sbj","setFlagExpiration","val","ExpirationBitIdx","getFlagExpiration","mask","getIdPosition","Self","None","OtherIdenIndex","Index","OtherIdenValue","Value","setValueDataInts","slotA","slotB","setSlotInt","ValueA","ValueB","setValueDataBytes","setSlotBytes","setValueData","setIndexDataInts","IndexA","IndexB","setIndexDataBytes","slotName","slot","setFlagMerklized","f","getMerklized","mt","getMerklizedPosition","setIndexData","resetExpirationDate","splice","getExpirationDate","unixTimestamp","setExpirationDate","dt","getBytesFromUint64","getRevocationNonce","setRevocationNonce","getValueId","setValueId","resetIndexId","resetValueId","getIndexId","setIndexId","setVersion","ver","getVersion","setFlagUpdatable","UpdatableBitIdx","hIndex","getFlagUpdatable","hValue","hiHv","hi","hv","setIndexMerklizedRoot","r","resetValueMerklizedRoot","resetIndexMerklizedRoot","setValueMerklizedRoot","getMerklizedRoot","resetId","getId","rawSlots","rawSlotsAsInts","clone","parse","marshalJson","map","unMarshalJson","ints","j","marshalBinary","getBytes","src","concat","fromHex","unMarshalBinary","data","wantLen","ClaimOptions","withFlagUpdatable","withVersion","withIndexId","withValueId","withFlagMerklized","p","withId","pos","withRevocationNonce","withExpirationDate","withIndexData","withIndexDataBytes","withIndexDataInts","withValueData","withValueDataBytes","withValueDataInts","withIndexMerklizedRoot","withValueMerklizedRoot","withMerklizedRoot","DIDNetworkFlag","blockchain","networkId","split","replace","buildDIDType","method","network","fb","methodFn","sb","findNetworkIDForDIDMethodByValue","byteNumber","methodMap","key","entries","findBlockchainForDIDMethodByValue","findDIDMethodByValue","Param","name","initDIDParams","idStrings","params","path","pathSegments","query","fragment","Parser","input","currentIndex","out","checkLength","parseScheme","bind","parseMethod","inputLength","startIndex","parseId","next","parseParamName","parsePath","parseQuery","parseFragment","paramTransition","parseParamValue","indexIncrement","percentEncoded","assign","isUrl","buff","param","toJSON","parser","parserState","decodePartsFromId","networkIdFromId","throwIfDIDUnsupported","methodFromId","blockchainFromId","isUnsupported","message","newFromIdenState","parseFromId","didParts","didString","idFromDID","did","getIdFromDID","error","idFromUnsupportedDID","idSlice","flg","tp","method2","registerBlockchain","registerNetwork","registerDidMethod","max","values","includes","registerChainId","chainId","getChainId","chainIDfromDID","registerDidMethodNetwork","methodByte","networkFlag","existedFlag"],"mappings":"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"}