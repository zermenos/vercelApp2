"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.circomSiblingsFromSiblings = exports.hashElemsKey = exports.hashElems = exports.newHashFromString = exports.newHashFromHex = exports.newHashFromBigInt = exports.ZERO_HASH = exports.Hash = void 0;
const constants_1 = require("../../constants");
const utils_1 = require("../utils");
const js_crypto_1 = require("@iden3/js-crypto");
class Hash {
    constructor(_bytes) {
        if (_bytes?.length) {
            if (_bytes.length !== constants_1.HASH_BYTES_LENGTH) {
                throw new Error(`Expected ${constants_1.HASH_BYTES_LENGTH} bytes, found ${_bytes.length} bytes`);
            }
            this.bytes = _bytes;
        }
        else {
            this.bytes = new Uint8Array(constants_1.HASH_BYTES_LENGTH);
        }
    }
    // returns a new copy, in little endian
    get value() {
        return this.bytes;
    }
    // bytes should be in big-endian
    set value(bytes) {
        if (bytes.length !== constants_1.HASH_BYTES_LENGTH) {
            throw `Expected 32 bytes, found ${bytes.length} bytes`;
        }
        this.bytes = (0, utils_1.swapEndianness)(bytes);
    }
    string() {
        return this.bigInt().toString(10);
    }
    hex() {
        return (0, utils_1.bytes2Hex)(this.bytes);
    }
    equals(hash) {
        return (0, utils_1.bytesEqual)(this.value, hash.value);
    }
    bigInt() {
        const bytes = (0, utils_1.swapEndianness)(this.value);
        return BigInt((0, utils_1.bytes2BinaryString)(bytes));
    }
    static fromString(s) {
        try {
            return Hash.fromBigInt(BigInt(s));
        }
        catch (e) {
            const deserializedHash = JSON.parse(s);
            const bytes = Uint8Array.from(Object.values(deserializedHash.bytes));
            return new Hash(bytes);
        }
    }
    static fromBigInt(i) {
        if (!(0, utils_1.checkBigIntInField)(i)) {
            throw new Error('NewBigIntFromHashBytes: Value not inside the Finite Field');
        }
        const bytes = (0, utils_1.bigIntToUINT8Array)(i);
        return new Hash((0, utils_1.swapEndianness)(bytes));
    }
    static fromHex(h) {
        if (!h) {
            return exports.ZERO_HASH;
        }
        return new Hash(js_crypto_1.Hex.decodeString(h));
    }
    toJSON() {
        return this.string();
    }
}
exports.Hash = Hash;
exports.ZERO_HASH = new Hash();
/**
 * @deprecated The method should not be used and will be removed in the next major version,
 * please use Hash.fromBigInt instead
 */
const newHashFromBigInt = (bigNum) => {
    return Hash.fromBigInt(bigNum);
};
exports.newHashFromBigInt = newHashFromBigInt;
/**
 * @deprecated The method should not be used and will be removed in the next major version,
 * please use Hash.fromBigInt instead
 */
const newHashFromHex = (h) => {
    return Hash.fromHex(h);
};
exports.newHashFromHex = newHashFromHex;
/**
 * @deprecated The method should not be used and will be removed in the next major version,
 * please use Hash.fromBigString instead
 */
const newHashFromString = (decimalString) => {
    return Hash.fromString(decimalString);
};
exports.newHashFromString = newHashFromString;
const hashElems = (e) => {
    const hashBigInt = js_crypto_1.poseidon.hash(e);
    return Hash.fromBigInt(hashBigInt);
};
exports.hashElems = hashElems;
const hashElemsKey = (k, e) => {
    const hashBigInt = js_crypto_1.poseidon.hash([...e, k]);
    return Hash.fromBigInt(hashBigInt);
};
exports.hashElemsKey = hashElemsKey;
const circomSiblingsFromSiblings = (siblings, levels) => {
    for (let i = siblings.length; i < levels; i += 1) {
        siblings.push(exports.ZERO_HASH);
    }
    return siblings;
};
exports.circomSiblingsFromSiblings = circomSiblingsFromSiblings;
