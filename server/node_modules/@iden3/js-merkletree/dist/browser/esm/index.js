import{Hex as t,poseidon as e}from"@iden3/js-crypto";const i=32,s=0,n=1,r=2,a=65,o=new Uint8Array(65),h="empty",l=32,c=8,f=256,u=2,d=30,w=BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617"),y=w-BigInt("1");function g(t,e,i,s){if("a"===i&&!s)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof e?t!==e||!s:!e.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===i?s:"a"===i?s.call(t):s?s.value:e.get(t)}function v(t,e,i,s,n){if("m"===s)throw new TypeError("Private method is not writable");if("a"===s&&!n)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof e?t!==e||!n:!e.has(t))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===s?n.call(t,i):n?n.value=i:e.set(t,i),i}const p=t=>t<w,b=(t,e)=>t.every(((t,i)=>t===e[i])),m=t=>t.slice().reverse(),x=t=>"0b"+t.reduce(((t,e)=>t+e.toString(2).padStart(8,"0")),""),I=(t,e)=>0!=(t[parseInt((e/8).toString())]&1<<e%8),k=(t,e)=>0!=(t[t.length-parseInt(""+e/8)-1]&1<<e%8),A=(t,e)=>{t[t.length-parseInt(""+e/8)-1]|=1<<e%8},R="0123456789abcdef",S=t=>{const e=new Array(2*t.length);let i=0;return t.forEach((t=>{e[i]=R[parseInt((t>>4).toString(10))],e[i+1]=R[parseInt((15&t).toString(10))],i+=2})),e.join("")},L=t=>{if(t.length!==i)throw`Expected 32 bytes, found ${t.length} bytes`;const e=BigInt(x(t));if(!p(e))throw"NewBigIntFromHashBytes: Value not inside the Finite Field";return e},B=t=>new Uint8Array(2*t.length).map(((e,i)=>t.charCodeAt(i))),N=(t,e)=>{const i=new Array(t);for(let s=0;s<t;s+=1)i[s]=I(e,s);return i},U=t=>{const e=new ArrayBuffer(i*t.length),s=new Uint8Array(e);return t.forEach(((t,e)=>{s.set(t.value,e*i)})),s},E=(t,e)=>t.toString(e||10).split("").map((t=>parseInt(t))),K=t=>{const e=BigInt(256),s=new Uint8Array(i);let n=0;for(;t>BigInt(0);)s[31-n]=Number(t%e),t/=e,n+=1;return s};class V{constructor(t){if(t?.length){if(t.length!==i)throw new Error(`Expected 32 bytes, found ${t.length} bytes`);this.bytes=t}else this.bytes=new Uint8Array(i)}get value(){return this.bytes}set value(t){if(t.length!==i)throw`Expected 32 bytes, found ${t.length} bytes`;this.bytes=m(t)}string(){return this.bigInt().toString(10)}hex(){return S(this.bytes)}equals(t){return b(this.value,t.value)}bigInt(){const t=m(this.value);return BigInt(x(t))}static fromString(t){try{return V.fromBigInt(BigInt(t))}catch(e){const i=JSON.parse(t),s=Uint8Array.from(Object.values(i.bytes));return new V(s)}}static fromBigInt(t){if(!p(t))throw new Error("NewBigIntFromHashBytes: Value not inside the Finite Field");const e=K(t);return new V(m(e))}static fromHex(e){return e?new V(t.decodeString(e)):M}toJSON(){return this.string()}}const M=new V,W=t=>V.fromBigInt(t),$=t=>V.fromHex(t),O=t=>V.fromString(t),_=t=>{const i=e.hash(t);return V.fromBigInt(i)},P=(t,i)=>{const s=e.hash([...i,t]);return V.fromBigInt(s)},J=(t,e)=>{for(let i=t.length;i<e;i+=1)t.push(M);return t};var T,H;class j{constructor(t){T.set(this,void 0),H.set(this,void 0),this.prefix=t,v(this,T,{},"f"),v(this,H,M,"f")}async get(t){const e=new Uint8Array([...this.prefix,...t]);return g(this,T,"f")[e.toString()]?g(this,T,"f")[e.toString()]:void 0}async put(t,e){const i=new Uint8Array([...this.prefix,...t]);g(this,T,"f")[i.toString()]=e}async getRoot(){return g(this,H,"f")}async setRoot(t){v(this,H,t,"f")}}T=new WeakMap,H=new WeakMap;const z=async(t,e)=>P(BigInt(1),[t.bigInt(),e.bigInt()]),C=(t,e,i)=>{const s=new Uint8Array(65),n=K(e.bigInt()),r=K(i.bigInt());s[0]=t;for(let t=1;t<33;t+=1)s[t]=n[t-1];for(let t=33;t<=65;t+=1)s[t]=r[t-33];return s};var q,F,D,G;class Q{constructor(t,e){q.set(this,void 0),this.type=1,this.entry=[t,e],v(this,q,M,"f")}async getKey(){return g(this,q,"f")===M?await z(this.entry[0],this.entry[1]):g(this,q,"f")}get value(){return C(this.type,this.entry[0],this.entry[1])}get string(){return`Leaf I:${this.entry[0]} D:${this.entry[1]}`}}q=new WeakMap;class X{constructor(t,e){F.set(this,void 0),this.type=0,this.childL=t,this.childR=e,v(this,F,M,"f")}async getKey(){return g(this,F,"f")===M?_([this.childL.bigInt(),this.childR.bigInt()]):g(this,F,"f")}get value(){return C(this.type,this.childL,this.childR)}get string(){return`Middle L:${this.childL} R:${this.childR}`}}F=new WeakMap;class Y{constructor(){D.set(this,void 0),this.type=2,v(this,D,M,"f")}async getKey(){return M}get value(){return o}get string(){return h}}D=new WeakMap;class Z{constructor(t){this._prefix=t,G.set(this,void 0);const e=localStorage.getItem(S(t));if(e){const t=JSON.parse(e);v(this,G,new V(Uint8Array.from(t)),"f")}else v(this,G,M,"f")}async get(t){const e=new Uint8Array([...this._prefix,...t]),i=S(e),s=localStorage.getItem(i);if(null===s)return;const n=JSON.parse(s);switch(n.type){case 2:return new Y;case 0:const t=new V(Uint8Array.from(n.childL)),e=new V(Uint8Array.from(n.childR));return new X(t,e);case 1:const i=new V(Uint8Array.from(n.entry[0])),s=new V(Uint8Array.from(n.entry[1]));return new Q(i,s)}throw`error: value found for key ${S(e)} is not of type Node`}async put(t,e){const i=new Uint8Array([...this._prefix,...t]),s=S(i),n={type:e.type};e instanceof X?(n.childL=Array.from(e.childL.bytes),n.childR=Array.from(e.childR.bytes)):e instanceof Q&&(n.entry=[Array.from(e.entry[0].bytes),Array.from(e.entry[1].bytes)]);const r=JSON.stringify(n);localStorage.setItem(s,r)}async getRoot(){return g(this,G,"f")}async setRoot(t){v(this,G,t,"f"),localStorage.setItem(S(this._prefix),JSON.stringify(Array.from(t.bytes)))}}function tt(t){return new Promise(((e,i)=>{t.oncomplete=t.onsuccess=()=>e(t.result),t.onabort=t.onerror=()=>i(t.error)}))}function et(t,e){const i=indexedDB.open(t);i.onupgradeneeded=()=>i.result.createObjectStore(e);const s=tt(i);return(t,i)=>s.then((s=>i(s.transaction(e,t).objectStore(e))))}let it;function st(){return it||(it=et("keyval-store","keyval")),it}function nt(t,e=st()){return e("readonly",(e=>tt(e.get(t))))}function rt(t,e,i=st()){return i("readwrite",(i=>(i.put(e,t),tt(i.transaction))))}var at,ot,ht;G=new WeakMap;class lt{constructor(t,e){this._prefix=t,at.set(this,void 0),v(this,at,M,"f"),this._prefixHash=S(t),this._store=et(`${e??lt.storageName}-db`,lt.storageName)}async get(t){const e=new Uint8Array([...this._prefix,...t]),i=S(e),s=await nt(i,this._store);if(null!=s){if(2===s.type)return new Y;if(0===s.type){const t=new V(Uint8Array.from(s.childL.bytes)),e=new V(Uint8Array.from(s.childR.bytes));return new X(t,e)}if(1===s.type){const t=new V(Uint8Array.from(s.entry[0].bytes)),e=new V(Uint8Array.from(s.entry[1].bytes));return new Q(t,e)}throw new Error(`error: value found for key ${i} is not of type Node`)}}async put(t,e){const i=new Uint8Array([...this._prefix,...t]),s=S(i);await rt(s,e,this._store)}async getRoot(){if(!g(this,at,"f").equals(M))return g(this,at,"f");const t=await nt(this._prefixHash,this._store);return v(this,at,t?new V(t.bytes):M,"f"),g(this,at,"f")}async setRoot(t){await rt(this._prefixHash,t,this._store),v(this,at,t,"f")}}at=new WeakMap,lt.storageName="merkle-tree";class ct{constructor(){ot.set(this,void 0),v(this,ot,new Uint8Array(l),"f")}get value(){return g(this,ot,"f")}set value(t){v(this,ot,t,"f")}bigInt(){return L(m(g(this,ot,"f")))}string(){return`${S(g(this,ot,"f").slice(0,4))}...`}}ot=new WeakMap;class ft{constructor(){ht.set(this,void 0),v(this,ht,new Array(8),"f")}get value(){return g(this,ht,"f")}set value(t){if(8!==t.length)throw`expected bytes length to be 8, got ${t.length}`;v(this,ht,t,"f")}bytes(){const t=new Uint8Array(256);for(let e=0;e<8;e+=1)g(this,ht,"f")[e].value.forEach(((i,s)=>{t[e*l+s]=i}));return t}equal(t){return b(g(this,ht,"f")[0].value,t.value[0].value)&&b(g(this,ht,"f")[1].value,t.value[1].value)&&b(g(this,ht,"f")[2].value,t.value[2].value)&&b(g(this,ht,"f")[3].value,t.value[3].value)}}ht=new WeakMap;const ut=t=>{if(t.length!==f)throw`expected bytes length to be 256, got ${t.length}`;const e=new ft,i=new Array(f);for(let e=0;e<8;e+=1){const s=new ct;s.value=t.slice(e*l,(e+1)*f),i[e]=s}return e.value=i,e};var dt,wt,yt;class gt{constructor(t){dt.set(this,void 0),wt.set(this,void 0),yt.set(this,void 0),v(this,dt,t||new ft,"f"),v(this,wt,M,"f"),v(this,yt,M,"f")}get data(){return g(this,dt,"f")}get index(){return g(this,dt,"f").value.slice(0,4)}get value(){return g(this,dt,"f").value.slice(4,8)}async hIndex(){return g(this,wt,"f")===M?_(vt(this.index)):g(this,wt,"f")}async hValue(){return g(this,yt,"f")===M?_(vt(this.value)):g(this,yt,"f")}hiHv(){return(async()=>({hi:await this.hIndex(),hv:await this.hValue()}))()}bytes(){return g(this,dt,"f").value}equal(t){return g(this,dt,"f").equal(t.data)}clone(){return new gt(g(this,dt,"f"))}}dt=new WeakMap,wt=new WeakMap,yt=new WeakMap;const vt=t=>t.map((t=>t.bigInt())),pt=t=>{const e=vt(t.data.value);let i=!0;return e.forEach((t=>{p(t)||(i=!1)})),i},bt="key already exists",mt="Key not found in the MerkleTree",xt="node data has incorrect size in the DB",It="reached maximum level of the merkle tree",kt="found an invalid node in the DB",At="the serialized proof is invalid",Rt="the value in the DB is invalid",St="the entry index already exists in the tree",Lt="Merkle Tree not writable",Bt="key not found";class Nt{constructor(t=M,e=[],i=M,s=M,n=!1,r=M,a=M,o=0){this.root=t,this.siblings=e,this.oldKey=i,this.oldValue=s,this.isOld0=n,this.key=r,this.value=a,this.fnc=o}}class Ut{constructor(t=M,e=M,i=[],s=M,n=M,r=M,a=M,o=!1,h=0){this.oldRoot=t,this.newRoot=e,this.siblings=i,this.oldKey=s,this.oldValue=n,this.newKey=r,this.newValue=a,this.isOld0=o,this.fnc=h}}const Et="non-existence proof being checked against hIndex equal to nodeAux";class Kt{constructor(t){this.existence=t?.existence??!1,this.depth=0,this.nodeAux=t?.nodeAux;const{siblings:e,notEmpties:i}=this.reduceSiblings(t?.siblings);this.siblings=e,this.notEmpties=i}bytes(){let t=2+this.notEmpties.length+l*this.siblings.length;void 0!==this.nodeAux&&(t+=64);const e=new ArrayBuffer(t),i=new Uint8Array(e);this.existence||(i[0]|=1),i[1]=this.depth,i.set(this.notEmpties,2);const s=U(this.siblings);return i.set(s,this.notEmpties.length+2),void 0!==this.nodeAux&&(i[0]|=2,i.set(this.nodeAux.key.value,i.length-64),i.set(this.nodeAux.value.value,i.length-32)),i}toJSON(){return{existence:this.existence,siblings:this.allSiblings().map((t=>t.toJSON())),node_aux:this.nodeAux?{key:this.nodeAux.key.toJSON(),value:this.nodeAux.value.toJSON()}:void 0}}reduceSiblings(t){const e=[],i=new Uint8Array(30);if(!t)return{siblings:e,notEmpties:i};for(let s=0;s<t.length;s++){const n=t[s];JSON.stringify(t[s])!==JSON.stringify(M)&&(A(i,s),e.push(n),this.depth=s+1)}return{notEmpties:i,siblings:e}}static fromJSON(t){let e;const i=t.node_aux??t.nodeAux;i&&(e={key:V.fromString(i.key),value:V.fromString(i.value)});const s=t.existence??!1,n=t.siblings.map((t=>V.fromString(t)));return new Kt({existence:s,nodeAux:e,siblings:n})}allSiblings(){return Kt.buildAllSiblings(this.depth,this.notEmpties,this.siblings)}static buildAllSiblings(t,e,i){let s=0;const n=[];for(let r=0;r<t;r+=1)k(e,r)?(n.push(i[s]),s+=1):n.push(M);return n}}const Vt=t=>t.allSiblings(),Mt=async(t,e,i,s)=>{try{const n=await Wt(e,i,s);return b(t.value,n.value)}catch(t){if(t===Et)return!1;throw t}},Wt=async(t,e,i)=>{const s=V.fromBigInt(e),n=V.fromBigInt(i);let r;if(t.existence)r=await z(s,n);else if(void 0===t.nodeAux)r=M;else{const e=t.nodeAux;if(b(s.value,e.key.value))throw Et;r=await z(e.key,e.value)}const a=t.allSiblings(),o=N(a.length,s.value);for(let t=a.length-1;t>=0;t-=1)r=o[t]?await new X(a[t],r).getKey():await new X(r,a[t]).getKey();return r};var $t,Ot,_t,Pt;class Jt{constructor(t,e,i){$t.set(this,void 0),Ot.set(this,void 0),_t.set(this,void 0),Pt.set(this,void 0),v(this,$t,t,"f"),v(this,_t,e,"f"),v(this,Pt,i,"f")}async root(){return g(this,Ot,"f")||v(this,Ot,await g(this,$t,"f").getRoot(),"f"),g(this,Ot,"f")}get maxLevels(){return g(this,Pt,"f")}async add(t,e){if(!g(this,_t,"f"))throw Lt;v(this,Ot,await this.root(),"f");const i=V.fromBigInt(t),s=V.fromBigInt(e),n=new Q(i,s),r=N(this.maxLevels,i.value),a=await this.addLeaf(n,g(this,Ot,"f"),0,r);v(this,Ot,a,"f"),await g(this,$t,"f").setRoot(g(this,Ot,"f"))}async updateNode(t){if(!g(this,_t,"f"))throw Lt;if(2===t.type)return await t.getKey();const e=await t.getKey();return await g(this,$t,"f").put(e.value,t),e}async addNode(t){if(!g(this,_t,"f"))throw Lt;if(2===t.type)return await t.getKey();const e=await t.getKey();return await g(this,$t,"f").put(e.value,t),e}async addEntry(t){if(!g(this,_t,"f"))throw Lt;if(!pt(t))throw"elements not inside the finite field over r";v(this,Ot,await g(this,$t,"f").getRoot(),"f");const e=await t.hIndex(),i=await t.hValue(),s=new Q(e,i),n=N(this.maxLevels,e.value),r=await this.addLeaf(s,g(this,Ot,"f"),0,n);v(this,Ot,r,"f"),await g(this,$t,"f").setRoot(g(this,Ot,"f"))}async pushLeaf(t,e,i,s,n){if(i>g(this,Pt,"f")-2)throw new Error(It);let r;if(s[i]===n[i]){const a=await this.pushLeaf(t,e,i+1,s,n);return r=s[i]?new X(new V,a):new X(a,new V),await this.addNode(r)}const a=await e.getKey(),o=await t.getKey();return r=s[i]?new X(a,o):new X(o,a),await this.addNode(t),await this.addNode(r)}async addLeaf(t,e,i,s){if(i>g(this,Pt,"f")-1)throw new Error(It);const n=await this.getNode(e);if(void 0===n)throw Bt;switch(n.type){case 2:return this.addNode(t);case 1:{const e=n.entry[0],r=t.entry[0];if(b(e.value,r.value))throw St;const a=N(this.maxLevels,e.value);return this.pushLeaf(t,n,i,s,a)}case 0:{let e;if(s[i]){const r=await this.addLeaf(t,n.childR,i+1,s);e=new X(n.childL,r)}else{const r=await this.addLeaf(t,n.childL,i+1,s);e=new X(r,n.childR)}return this.addNode(e)}default:throw kt}}async get(t){const e=V.fromBigInt(t),i=N(this.maxLevels,e.value);let s=await this.root();const n=[];for(let t=0;t<this.maxLevels;t++){const e=await this.getNode(s);if(void 0===e)throw mt;switch(e.type){case 2:return{key:BigInt("0"),value:BigInt("0"),siblings:n};case 1:return{key:e.entry[0].bigInt(),value:e.entry[1].bigInt(),siblings:n};case 0:i[t]?(s=e.childR,n.push(e.childL)):(s=e.childL,n.push(e.childR));break;default:throw kt}}throw new Error(It)}async update(t,e){if(!g(this,_t,"f"))throw Lt;if(!p(t))throw"key not inside the finite field";if(!p(e))throw"key not inside the finite field";const i=V.fromBigInt(t),s=V.fromBigInt(e),n=N(this.maxLevels,i.value),r=new Ut;r.fnc=1,r.oldRoot=await this.root(),r.oldKey=i,r.newKey=i,r.newValue=s;let a=await this.root();const o=[];for(let t=0;t<this.maxLevels;t+=1){const e=await this.getNode(a);if(void 0===e)throw Bt;switch(e.type){case 2:throw mt;case 1:if(b(i.value,e.entry[0].value)){r.oldValue=e.entry[1],r.siblings=J([...o],this.maxLevels);const t=new Q(i,s);await this.updateNode(t);const a=await this.recalculatePathUntilRoot(n,t,o);return v(this,Ot,a,"f"),await g(this,$t,"f").setRoot(a),r.newRoot=a,r}break;case 0:n[t]?(a=e.childR,o.push(e.childL)):(a=e.childL,o.push(e.childR));break;default:throw kt}}throw mt}async getNode(t){return b(t.value,M.value)?new Y:await g(this,$t,"f").get(t.value)}async recalculatePathUntilRoot(t,e,i){for(let s=i.length-1;s>=0;s-=1){const n=await e.getKey();e=t[s]?new X(i[s],n):new X(n,i[s]),await this.addNode(e)}return await e.getKey()}async delete(t){if(!g(this,_t,"f"))throw Lt;const e=V.fromBigInt(t),i=N(this.maxLevels,e.value);let s=g(this,Ot,"f");const n=[];for(let t=0;t<g(this,Pt,"f");t+=1){const r=await this.getNode(s);if(void 0===r)throw Bt;switch(r.type){case 2:throw mt;case 1:if(b(e.bytes,r.entry[0].value))return void await this.rmAndUpload(i,e,n);throw mt;case 0:i[t]?(s=r.childR,n.push(r.childL)):(s=r.childL,n.push(r.childR));break;default:throw kt}}throw mt}async rmAndUpload(t,e,i){if(0===i.length)return v(this,Ot,M,"f"),void await g(this,$t,"f").setRoot(g(this,Ot,"f"));const s=i[i.length-1];i.length<2&&(v(this,Ot,i[0],"f"),await g(this,$t,"f").setRoot(g(this,Ot,"f")));const n=await g(this,$t,"f").get(s.bytes);if(0===n?.type){let e;e=t[i.length-1]?new X(s,M):new X(M,s),await this.addNode(e);const n=await this.recalculatePathUntilRoot(t,e,i.slice(0,i.length-1));return v(this,Ot,n,"f"),void await g(this,$t,"f").setRoot(g(this,Ot,"f"))}for(let e=i.length-2;e>=0;e-=1){if(!b(i[e].value,M.value)){let n;n=t[e]?new X(i[e],s):new X(s,i[e]),await this.addNode(n);const r=await this.recalculatePathUntilRoot(t,n,i.slice(0,e));v(this,Ot,r,"f"),await g(this,$t,"f").setRoot(g(this,Ot,"f"));break}if(0===e){v(this,Ot,s,"f"),await g(this,$t,"f").setRoot(g(this,Ot,"f"));break}}}async recWalk(t,e){const i=await this.getNode(t);if(void 0===i)throw Bt;switch(i.type){case 2:case 1:await e(i);break;case 0:await e(i),await this.recWalk(i.childL,e),await this.recWalk(i.childR,e);break;default:throw kt}}async walk(t,e){b(t.value,M.value)&&(t=await this.root()),await this.recWalk(t,e)}async generateCircomVerifierProof(t,e){const i=await this.generateSCVerifierProof(t,e);return i.siblings=J(i.siblings,this.maxLevels),i}async generateSCVerifierProof(t,e){b(e.value,M.value)&&(e=await this.root());const{proof:i,value:s}=await this.generateProof(t,e),n=new Nt;return n.root=e,n.siblings=i.allSiblings(),void 0!==i.nodeAux?(n.oldKey=i.nodeAux.key,n.oldValue=i.nodeAux.value):(n.oldKey=M,n.oldValue=M),n.key=V.fromBigInt(t),n.value=V.fromBigInt(s),i.existence?n.fnc=0:n.fnc=1,n}async generateProof(t,e){let i;const s=V.fromBigInt(t),n=N(this.maxLevels,s.value);e||(e=await this.root());let r=e,a=0,o=!1;const h=[];let l;for(a=0;a<this.maxLevels;a+=1){const t=await this.getNode(r);if(void 0===t)throw Bt;switch(t.type){case 2:return{proof:new Kt({existence:o,nodeAux:l,siblings:h}),value:BigInt("0")};case 1:return b(s.value,t.entry[0].value)?(o=!0,{proof:new Kt({existence:o,nodeAux:l,siblings:h}),value:t.entry[1].bigInt()}):(l={key:t.entry[0],value:t.entry[1]},{proof:new Kt({existence:o,nodeAux:l,siblings:h}),value:t.entry[1].bigInt()});case 0:n[a]?(r=t.childR,i=t.childL):(r=t.childL,i=t.childR);break;default:throw kt}h.push(i)}throw mt}async addAndGetCircomProof(t,e){const i=new Ut;i.fnc=2,i.oldRoot=await this.root();let s=BigInt("0"),n=BigInt("0"),r=[];try{const e=await this.get(t);s=e.key,n=e.value,r=e.siblings}catch(t){if(t!==mt)throw t}if(void 0===s||void 0===n)throw"key/value undefined";return i.oldKey=V.fromBigInt(s),i.oldValue=V.fromBigInt(n),b(i.oldKey.value,M.value)&&(i.isOld0=!0),i.siblings=J(r,this.maxLevels),await this.add(t,e),i.newKey=V.fromBigInt(t),i.newValue=V.fromBigInt(e),i.newRoot=await this.root(),i}async graphViz(t){let e=0;await this.walk(t,(async t=>{const i=await t.getKey();let s,n;switch(t.type){case 2:break;case 1:console.log(`"${i.string()}" [style=filled]`);break;case 0:s=[t.childL.string(),t.childR.string()],n="",s.forEach(((t,i)=>{"0"===t&&(s[i]=`empty${e}`,n+=`"${s[i]}" [style=dashed,label=0];\n`,e+=1)})),console.log(`"${i.string()}" -> {"${s[1]}"}`),console.log(n)}})),console.log("}\n")}async printGraphViz(t){b(t.value,M.value)&&(t=await this.root()),console.log(`--------\nGraphViz of the MerkleTree with RootKey ${t.bigInt().toString(10)}\n`),await this.graphViz(M),console.log(`End of GraphViz of the MerkleTree with RootKey ${t.bigInt().toString(10)}\n--------\n`)}}$t=new WeakMap,Ot=new WeakMap,_t=new WeakMap,Pt=new WeakMap;export{Ut as CircomProcessorProof,Nt as CircomVerifierProof,c as DATA_LEN,f as DATA_LEN_BYTES,ft as Data,l as ELEM_BYTES_LEN,h as EMPTY_NODE_STRING,o as EMPTY_NODE_VALUE,ct as ElemBytes,gt as Entry,St as ErrEntryIndexAlreadyExists,Rt as ErrInvalidDBValue,kt as ErrInvalidNodeFound,At as ErrInvalidProofBytes,mt as ErrKeyNotFound,xt as ErrNodeBytesBadSize,bt as ErrNodeKeyAlreadyExists,Bt as ErrNotFound,Lt as ErrNotWritable,It as ErrReachedMaxLevel,w as FIELD_SIZE,i as HASH_BYTES_LENGTH,V as Hash,j as InMemoryDB,lt as IndexedDBStorage,Z as LocalStorageDB,y as MAX_NUM_IN_FIELD,Jt as Merkletree,r as NODE_TYPE_EMPTY,n as NODE_TYPE_LEAF,s as NODE_TYPE_MIDDLE,a as NODE_VALUE_BYTE_ARR_LENGTH,d as NOT_EMPTIES_LEN,Y as NodeEmpty,Q as NodeLeaf,X as NodeMiddle,u as PROOF_FLAG_LEN,Kt as Proof,M as ZERO_HASH,K as bigIntToUINT8Array,E as bigint2Array,x as bytes2BinaryString,S as bytes2Hex,b as bytesEqual,p as checkBigIntInField,pt as checkEntryInField,J as circomSiblingsFromSiblings,vt as elemBytesToBigInts,N as getPath,_ as hashElems,P as hashElemsKey,L as newBigIntFromBytes,ut as newDataFromBytes,W as newHashFromBigInt,$ as newHashFromHex,O as newHashFromString,Wt as rootFromProof,A as setBitBigEndian,Vt as siblignsFroomProof,U as siblings2Bytes,B as str2Bytes,m as swapEndianness,I as testBit,k as testBitBigEndian,Mt as verifyProof};
//# sourceMappingURL=index.js.map
