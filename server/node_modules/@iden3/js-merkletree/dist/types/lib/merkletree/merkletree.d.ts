import { ITreeStorage } from '../../types/storage';
import { Hash } from '../hash/hash';
import { Node } from '../../types';
import { NodeLeaf } from '../node/node';
import { Siblings } from '../../types/merkletree';
import { CircomProcessorProof, CircomVerifierProof } from './circom';
import { Proof } from './proof';
import { Entry } from '../entry';
export declare class Merkletree {
    #private;
    constructor(_db: ITreeStorage, _writable: boolean, _maxLevels: number);
    root(): Promise<Hash>;
    get maxLevels(): number;
    add(k: bigint, v: bigint): Promise<void>;
    updateNode(n: Node): Promise<Hash>;
    addNode(n: Node): Promise<Hash>;
    addEntry(e: Entry): Promise<void>;
    pushLeaf(newLeaf: Node, oldLeaf: Node, lvl: number, pathNewLeaf: Array<boolean>, pathOldLeaf: Array<boolean>): Promise<Hash>;
    addLeaf(newLeaf: NodeLeaf, key: Hash, lvl: number, path: Array<boolean>): Promise<Hash>;
    get(k: bigint): Promise<{
        key: bigint;
        value: bigint;
        siblings: Siblings;
    }>;
    update(k: bigint, v: bigint): Promise<CircomProcessorProof>;
    getNode(k: Hash): Promise<Node | undefined>;
    recalculatePathUntilRoot(path: Array<boolean>, node: Node, siblings: Siblings): Promise<Hash>;
    delete(k: bigint): Promise<void>;
    rmAndUpload(path: Array<boolean>, kHash: Hash, siblings: Siblings): Promise<void>;
    recWalk(key: Hash, f: (n: Node) => Promise<void>): Promise<void>;
    walk(rootKey: Hash, f: (n: Node) => Promise<void>): Promise<void>;
    generateCircomVerifierProof(k: bigint, rootKey: Hash): Promise<CircomVerifierProof>;
    generateSCVerifierProof(k: bigint, rootKey: Hash): Promise<CircomVerifierProof>;
    generateProof(k: bigint, rootKey?: Hash): Promise<{
        proof: Proof;
        value: bigint;
    }>;
    addAndGetCircomProof(k: bigint, v: bigint): Promise<CircomProcessorProof>;
    graphViz(rootKey: Hash): Promise<void>;
    printGraphViz(rootKey: Hash): Promise<void>;
}
