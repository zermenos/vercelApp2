"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepare = exports.getAlgorithms = exports.getProvingMethod = exports.registerProvingMethod = exports.ProvingMethodAlg = void 0;
class ProvingMethodAlg {
    constructor(alg, circuitId) {
        this.alg = alg;
        this.circuitId = circuitId;
    }
    toString() {
        return `${this.alg}:${this.circuitId}`;
    }
}
exports.ProvingMethodAlg = ProvingMethodAlg;
const provingMethods = new Map(); // map[string]func() ProvingMethod{}
// RegisterProvingMethod registers the "alg" name and a factory function for proving method.
// This is typically done during init() in the method's implementation
function registerProvingMethod(alg, f) {
    return new Promise((res) => {
        provingMethods.set(alg.toString(), f);
        res();
    });
}
exports.registerProvingMethod = registerProvingMethod;
// GetProvingMethod retrieves a proving method from an "alg" string
function getProvingMethod(alg) {
    return new Promise((res, rej) => {
        const func = provingMethods.get(alg.toString());
        if (func) {
            const method = func();
            res(method);
        }
        else {
            rej('unknown alg');
        }
    });
}
exports.getProvingMethod = getProvingMethod;
function getAlgorithms() {
    return Promise.resolve(Array.from(provingMethods.keys()).map((k) => k.split(':')[0]));
}
exports.getAlgorithms = getAlgorithms;
// Prepare function is responsible to call provided handler for inputs preparation
function prepare(f, hash, circuitId) {
    return f(hash, circuitId);
}
exports.prepare = prepare;
