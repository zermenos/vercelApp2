import { Id } from '@iden3/js-iden3-core';
import { ProvingMethodAlg } from './proving';
import { AuthV2Circuit, Groth16, prove, verify } from './common';
import { Hash } from '@iden3/js-merkletree';
import { getCurveFromName } from 'ffjavascript';
export const AuthV2Groth16Alg = new ProvingMethodAlg(Groth16, AuthV2Circuit);
// ProvingMethodGroth16AuthV2 instance for Groth16 proving method with an authV2 circuit
export class ProvingMethodGroth16AuthV2 {
    constructor(methodAlg) {
        this.methodAlg = methodAlg;
    }
    get alg() {
        return this.methodAlg.alg;
    }
    get circuitId() {
        return this.methodAlg.circuitId;
    }
    async verify(messageHash, proof, verificationKey) {
        const verificationResult = await verify(messageHash, proof, verificationKey, this.unmarshall);
        await this.terminateCurve();
        return verificationResult;
    }
    async prove(inputs, provingKey, wasm) {
        const zkProof = await prove(inputs, provingKey, wasm);
        await this.terminateCurve();
        return zkProof;
    }
    async terminateCurve() {
        const curve = await getCurveFromName(ProvingMethodGroth16AuthV2.curveName);
        curve.terminate();
    }
    unmarshall(pubSignals) {
        const len = 3;
        if (pubSignals.length !== len) {
            throw new Error(`invalid number of Output values expected ${len} got ${pubSignals.length}`);
        }
        return {
            userID: Id.fromBigInt(BigInt(pubSignals[0])),
            challenge: BigInt(pubSignals[1]),
            GISTRoot: Hash.fromString(pubSignals[2])
        };
    }
}
ProvingMethodGroth16AuthV2.curveName = 'bn128';
export const provingMethodGroth16AuthV2Instance = new ProvingMethodGroth16AuthV2(new ProvingMethodAlg(Groth16, AuthV2Circuit));
