{"version":3,"file":"index.js","sources":["../../../src/hash.ts","../../../src/proving.ts","../../../node_modules/rfc4648/lib/rfc4648.js","../../../src/jwz.ts","../../../src/witness_calculator.ts","../../../src/common.ts","../../../src/authGroth16.ts","../../../src/authV2Groth16.ts","../../../src/index.ts"],"sourcesContent":["import { fromBigEndian } from '@iden3/js-iden3-core';\nimport { poseidon, sha256 } from '@iden3/js-crypto';\n// Q is the order of the integer field (Zq) that fits inside the SNARK.\nexport const qString =\n  '21888242871839275222246405745257275088548364400416034343698204186575808495617';\n\nexport function hash(message: Uint8Array): bigint {\n  // 1. sha256 hash\n  const hashBytes = sha256(message);\n\n  // 2. swap hash before hashing\n  const bi = fromBigEndian(hashBytes.reverse());\n\n  let m = BigInt(0);\n  if (checkBigIntInField(bi)) {\n    m = bi;\n  } else {\n    m = bi % BigInt(qString);\n  }\n\n  return poseidon.hash([m]);\n}\n\n// checkBigIntInField checks if given *big.Int fits in a Field Q element\nexport function checkBigIntInField(a: bigint): boolean {\n  return a < BigInt(qString);\n}\n","export interface ZKProof {\n  proof: ProofData;\n  pub_signals: string[];\n}\nexport interface ProofData {\n  pi_a: string[];\n  pi_b: string[][];\n  pi_c: string[];\n  protocol: string;\n}\n\nexport class ProvingMethodAlg {\n  constructor(public readonly alg: string, public readonly circuitId: string) {}\n\n  toString(): string {\n    return `${this.alg}:${this.circuitId}`;\n  }\n}\n\nconst provingMethods = new Map<string, () => ProvingMethod>(); // map[string]func() ProvingMethod{}\n\n// ProvingMethod can be used add new methods for signing or verifying tokens.\nexport interface ProvingMethod {\n  // Returns true if proof is valid\n  verify(messageHash: Uint8Array, proof: ZKProof, verificationKey: Uint8Array): Promise<boolean>;\n  // Returns proof or error\n  prove(inputs: Uint8Array, provingKey: Uint8Array, wasm: Uint8Array): Promise<ZKProof>;\n\n  readonly methodAlg: ProvingMethodAlg;\n\n  readonly alg: string;\n  // Returns the alg identifier for this method (example: 'AUTH-GROTH-16')\n  readonly circuitId: string;\n}\n\n// RegisterProvingMethod registers the \"alg\" name and a factory function for proving method.\n// This is typically done during init() in the method's implementation\nexport function registerProvingMethod(\n  alg: ProvingMethodAlg,\n  f: () => ProvingMethod\n): Promise<void> {\n  return new Promise((res) => {\n    provingMethods.set(alg.toString(), f);\n    res();\n  });\n}\n\n// GetProvingMethod retrieves a proving method from an \"alg\" string\nexport function getProvingMethod(alg: ProvingMethodAlg): Promise<ProvingMethod> {\n  return new Promise((res, rej) => {\n    const func = provingMethods.get(alg.toString());\n    if (func) {\n      const method: ProvingMethod = func();\n      res(method);\n    } else {\n      rej('unknown alg');\n    }\n  });\n}\n\nexport function getAlgorithms(): Promise<string[]> {\n  return Promise.resolve(Array.from(provingMethods.keys()).map((k) => k.split(':')[0]));\n}\n\n// ProofInputsPreparerHandlerFunc prepares inputs using hash message and circuit id\nexport type ProofInputsPreparerHandlerFunc = (\n  hash: Uint8Array,\n  circuitId: string\n) => Promise<Uint8Array>;\n\n// Prepare function is responsible to call provided handler for inputs preparation\nexport function prepare(\n  f: ProofInputsPreparerHandlerFunc,\n  hash: Uint8Array,\n  circuitId: string\n): Promise<Uint8Array> {\n  return f(hash, circuitId);\n}\n","/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nfunction parse(string, encoding, opts) {\n  var _opts$out;\n\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  // Build the character lookup table:\n  if (!encoding.codes) {\n    encoding.codes = {};\n\n    for (var i = 0; i < encoding.chars.length; ++i) {\n      encoding.codes[encoding.chars[i]] = i;\n    }\n  } // The string must have a whole number of bytes:\n\n\n  if (!opts.loose && string.length * encoding.bits & 7) {\n    throw new SyntaxError('Invalid padding');\n  } // Count the padding bytes:\n\n\n  var end = string.length;\n\n  while (string[end - 1] === '=') {\n    --end; // If we get a whole number of bytes, there is too much padding:\n\n    if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {\n      throw new SyntaxError('Invalid padding');\n    }\n  } // Allocate the output:\n\n\n  var out = new ((_opts$out = opts.out) != null ? _opts$out : Uint8Array)(end * encoding.bits / 8 | 0); // Parse the data:\n\n  var bits = 0; // Number of bits currently in the buffer\n\n  var buffer = 0; // Bits waiting to be written out, MSB first\n\n  var written = 0; // Next byte to write\n\n  for (var _i = 0; _i < end; ++_i) {\n    // Read one character from the string:\n    var value = encoding.codes[string[_i]];\n\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[_i]);\n    } // Append the bits to the buffer:\n\n\n    buffer = buffer << encoding.bits | value;\n    bits += encoding.bits; // Write out some bits if the buffer has a byte's worth:\n\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & buffer >> bits;\n    }\n  } // Verify that we have received just enough bits:\n\n\n  if (bits >= encoding.bits || 0xff & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n\n  return out;\n}\nfunction stringify(data, encoding, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  var _opts = opts,\n      _opts$pad = _opts.pad,\n      pad = _opts$pad === void 0 ? true : _opts$pad;\n  var mask = (1 << encoding.bits) - 1;\n  var out = '';\n  var bits = 0; // Number of bits currently in the buffer\n\n  var buffer = 0; // Bits waiting to be written out, MSB first\n\n  for (var i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = buffer << 8 | 0xff & data[i];\n    bits += 8; // Write out as much as we can:\n\n    while (bits > encoding.bits) {\n      bits -= encoding.bits;\n      out += encoding.chars[mask & buffer >> bits];\n    }\n  } // Partial character:\n\n\n  if (bits) {\n    out += encoding.chars[mask & buffer << encoding.bits - bits];\n  } // Add padding characters until we hit a byte boundary:\n\n\n  if (pad) {\n    while (out.length * encoding.bits & 7) {\n      out += '=';\n    }\n  }\n\n  return out;\n}\n\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nvar base16Encoding = {\n  chars: '0123456789ABCDEF',\n  bits: 4\n};\nvar base32Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bits: 5\n};\nvar base32HexEncoding = {\n  chars: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bits: 5\n};\nvar base64Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bits: 6\n};\nvar base64UrlEncoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bits: 6\n};\nvar base16 = {\n  parse: function parse$1(string, opts) {\n    return parse(string.toUpperCase(), base16Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base16Encoding, opts);\n  }\n};\nvar base32 = {\n  parse: function parse$1(string, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    return parse(opts.loose ? string.toUpperCase().replace(/0/g, 'O').replace(/1/g, 'L').replace(/8/g, 'B') : string, base32Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base32Encoding, opts);\n  }\n};\nvar base32hex = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base32HexEncoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base32HexEncoding, opts);\n  }\n};\nvar base64 = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base64Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base64Encoding, opts);\n  }\n};\nvar base64url = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base64UrlEncoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base64UrlEncoding, opts);\n  }\n};\nvar codec = {\n  parse: parse,\n  stringify: stringify\n};\n\nexport { base16, base32, base32hex, base64, base64url, codec };\n","import { hash } from './hash';\nimport {\n  ZKProof,\n  ProvingMethod,\n  ProvingMethodAlg,\n  ProofInputsPreparerHandlerFunc,\n  getProvingMethod,\n  prepare\n} from './proving';\n\nimport { base64url as base64 } from 'rfc4648';\nimport { toBigEndian } from '@iden3/js-iden3-core';\n\nexport enum Header {\n  Type = 'typ',\n  Alg = 'alg',\n  CircuitId = 'circuitId',\n  Critical = 'crit'\n}\n\nexport interface IRawJSONWebZeroknowledge {\n  payload: Uint8Array;\n  protectedHeaders: Uint8Array;\n  header: { [key: string]: unknown };\n  zkp: Uint8Array;\n\n  sanitized(): Promise<Token>;\n}\n\nexport class RawJSONWebZeroknowledge implements IRawJSONWebZeroknowledge {\n  constructor(\n    public payload: Uint8Array,\n    public protectedHeaders: Uint8Array,\n    public header: { [key: string]: unknown },\n    public zkp: Uint8Array\n  ) {}\n\n  async sanitized(): Promise<Token> {\n    if (!this.payload) {\n      throw new Error('iden3/js-jwz: missing payload in JWZ message');\n    }\n\n    const headers: { [key: string]: unknown } = JSON.parse(\n      new TextDecoder().decode(this.protectedHeaders)\n    );\n    const criticalHeaders = headers[Header.Critical] as string[];\n    criticalHeaders.forEach((key: string) => {\n      if (!headers[key]) {\n        throw new Error(`iden3/js-jwz: header is listed in critical ${key}, but not presented`);\n      }\n    });\n\n    const alg = headers[Header.Alg] as string;\n    const circuitId = headers[Header.CircuitId] as string;\n\n    const method = await getProvingMethod(new ProvingMethodAlg(alg, circuitId));\n    const zkp = JSON.parse(new TextDecoder().decode(this.zkp));\n    const token = new Token(method, new TextDecoder().decode(this.payload));\n    token.alg = alg;\n    token.circuitId = circuitId;\n    token.zkProof = zkp;\n    for (const [key, value] of Object.entries(headers)) {\n      token.setHeader(key, value);\n    }\n\n    return token;\n  }\n}\n\n// Token represents a JWZ Token.\nexport class Token {\n  public alg: string;\n  public circuitId: string;\n  private raw: IRawJSONWebZeroknowledge;\n  public zkProof: ZKProof = {} as ZKProof;\n\n  constructor(\n    public readonly method: ProvingMethod,\n    payload: string,\n    private readonly inputsPreparer?: ProofInputsPreparerHandlerFunc\n  ) {\n    this.alg = this.method.alg;\n    this.circuitId = this.method.circuitId;\n    this.raw = {} as IRawJSONWebZeroknowledge;\n    this.raw.header = this.getDefaultHeaders();\n\n    this.raw.payload = new TextEncoder().encode(payload);\n  }\n\n  public setHeader(key: string, value: unknown): void {\n    this.raw.header[key] = value;\n  }\n\n  public getPayload(): string {\n    return new TextDecoder().decode(this.raw.payload);\n  }\n\n  private getDefaultHeaders(): { [key: string]: string | string[] } {\n    return {\n      [Header.Alg]: this.alg,\n      [Header.Critical]: [Header.CircuitId],\n      [Header.CircuitId]: this.circuitId,\n      [Header.Type]: 'JWZ'\n    };\n  }\n\n  // Parse parses a jwz message in compact or full serialization format.\n  static parse(tokenStr: string): Promise<Token> {\n    // Parse parses a jwz message in compact or full serialization format.\n    const token = tokenStr?.trim();\n    return token.startsWith('{') ? Token.parseFull(tokenStr) : Token.parseCompact(tokenStr);\n  }\n\n  // parseCompact parses a message in compact format.\n  private static async parseCompact(tokenStr: string): Promise<Token> {\n    const parts = tokenStr.split('.');\n    if (parts.length != 3) {\n      throw new Error('iden3/js-jwz: compact JWZ format must have three segments');\n    }\n    const rawProtected = base64.parse(parts[0], { loose: true });\n\n    const rawPayload = base64.parse(parts[1], { loose: true });\n\n    const proof = base64.parse(parts[2], { loose: true });\n\n    const raw: IRawJSONWebZeroknowledge = new RawJSONWebZeroknowledge(\n      rawPayload,\n      rawProtected,\n      {},\n      proof\n    );\n\n    return await raw.sanitized();\n  }\n\n  // parseFull parses a message in full format.\n  private static async parseFull(tokenStr: string): Promise<Token> {\n    const raw: IRawJSONWebZeroknowledge = JSON.parse(tokenStr);\n    return await raw.sanitized();\n  }\n\n  // Prove creates and returns a complete, proved JWZ.\n  // The token is proven using the Proving Method specified in the token.\n  async prove(provingKey: Uint8Array, wasm: Uint8Array): Promise<string> {\n    // all headers must be protected\n    const headers = this.serializeHeaders();\n\n    this.raw.protectedHeaders = new TextEncoder().encode(headers);\n\n    const msgHash: Uint8Array = await this.getMessageHash();\n\n    if (!this.inputsPreparer) {\n      throw new Error('iden3/jwz: prepare func must be defined');\n    }\n    const inputs: Uint8Array = await prepare(this.inputsPreparer, msgHash, this.circuitId);\n\n    const proof: ZKProof = await this.method.prove(inputs, provingKey, wasm);\n\n    const marshaledProof = JSON.stringify(proof);\n\n    this.zkProof = proof;\n    this.raw.zkp = new TextEncoder().encode(marshaledProof);\n\n    return this.compactSerialize();\n  }\n\n  // CompactSerialize returns token serialized in three parts: base64 encoded headers, payload and proof.\n  compactSerialize(): string {\n    if (!this.raw.header || !this.raw.protectedHeaders || !this.zkProof) {\n      throw new Error(\"iden3/jwz:can't serialize without one of components\");\n    }\n\n    const serializedProtected = base64.stringify(this.raw.protectedHeaders, {\n      pad: false\n    });\n    const serializedProof = base64.stringify(this.raw.zkp, { pad: false });\n    const serializedPayload = base64.stringify(this.raw.payload, {\n      pad: false\n    });\n    return `${serializedProtected}.${serializedPayload}.${serializedProof}`;\n  }\n\n  // fullSerialize returns marshaled presentation of raw token as json string.\n  fullSerialize(): string {\n    return JSON.stringify(this.raw);\n  }\n\n  async getMessageHash(): Promise<Uint8Array> {\n    const serializedHeadersJSON = this.serializeHeaders();\n\n    const serializedHeaders = new TextEncoder().encode(serializedHeadersJSON);\n    const protectedHeaders = base64.stringify(serializedHeaders, {\n      pad: false\n    });\n\n    const payload = base64.stringify(this.raw.payload, { pad: false });\n\n    // JWZ ZkProof input value is ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' || BASE64URL(JWS Payload)).\n    const messageToProof = new TextEncoder().encode(`${protectedHeaders}.${payload}`);\n\n    const hashInt: bigint = await hash(messageToProof);\n\n    return toBigEndian(hashInt, 32);\n  }\n\n  // Verify  perform zero knowledge verification.\n  async verify(verificationKey: Uint8Array): Promise<boolean> {\n    // 1. prepare hash o payload message that had to be proven\n    const msgHash = await this.getMessageHash();\n\n    // 2. verify that zkp is valid\n\n    return this.method.verify(msgHash, this.zkProof, verificationKey);\n  }\n\n  serializeHeaders() {\n    return JSON.stringify(this.raw.header, Object.keys(this.raw.header).sort());\n  }\n}\n","/* eslint-disable require-await */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport async function witnessBuilder(code, options?) {\n  options = options || {};\n\n  let wasmModule;\n  try {\n    wasmModule = await WebAssembly.compile(code);\n  } catch (err) {\n    console.log(err);\n    console.log('\\nTry to run circom --c in order to generate c++ code instead\\n');\n    throw new Error(err);\n  }\n\n  let wc;\n\n  let errStr = '';\n  let msgStr = '';\n\n  const instance = await WebAssembly.instantiate(wasmModule, {\n    runtime: {\n      exceptionHandler: function (code) {\n        let err;\n        if (code == 1) {\n          err = 'Signal not found.\\n';\n        } else if (code == 2) {\n          err = 'Too many signals set.\\n';\n        } else if (code == 3) {\n          err = 'Signal already set.\\n';\n        } else if (code == 4) {\n          err = 'Assert Failed.\\n';\n        } else if (code == 5) {\n          err = 'Not enough memory.\\n';\n        } else if (code == 6) {\n          err = 'Input signal array access exceeds the size.\\n';\n        } else {\n          err = 'Unknown error.\\n';\n        }\n        throw new Error(err + errStr);\n      },\n      printErrorMessage: function () {\n        errStr += getMessage() + '\\n';\n        // console.error(getMessage());\n      },\n      writeBufferMessage: function () {\n        const msg = getMessage();\n        // Any calls to `log()` will always end with a `\\n`, so that's when we print and reset\n        if (msg === '\\n') {\n          console.log(msgStr);\n          msgStr = '';\n        } else {\n          // If we've buffered other content, put a space in between the items\n          if (msgStr !== '') {\n            msgStr += ' ';\n          }\n          // Then append the message to the message we are creating\n          msgStr += msg;\n        }\n      },\n      showSharedRWMemory: function () {\n        printSharedRWMemory();\n      }\n    }\n  });\n\n  const sanityCheck = options;\n  //        options &&\n  //        (\n  //            options.sanityCheck ||\n  //            options.logGetSignal ||\n  //            options.logSetSignal ||\n  //            options.logStartComponent ||\n  //            options.logFinishComponent\n  //        );\n\n  wc = new WitnessCalculator(instance, sanityCheck);\n  return wc;\n\n  function getMessage() {\n    let message = '';\n    let c = (instance as any).exports.getMessageChar();\n    while (c != 0) {\n      message += String.fromCharCode(c);\n      c = (instance as any).exports.getMessageChar();\n    }\n    return message;\n  }\n\n  function printSharedRWMemory() {\n    const shared_rw_memory_size = (instance as any).exports.getFieldNumLen32();\n    const arr = new Uint32Array(shared_rw_memory_size);\n    for (let j = 0; j < shared_rw_memory_size; j++) {\n      arr[shared_rw_memory_size - 1 - j] = (instance as any).exports.readSharedRWMemory(j);\n    }\n\n    // If we've buffered other content, put a space in between the items\n    if (msgStr !== '') {\n      msgStr += ' ';\n    }\n    // Then append the value to the message we are creating\n    msgStr += fromArray32(arr).toString();\n  }\n}\n\nclass WitnessCalculator {\n  version: any;\n  n32: any;\n  prime: any;\n  witnessSize: any;\n  sanityCheck: any;\n  constructor(private instance, sanityCheck) {\n    this.instance = instance;\n    this.version = (this.instance.exports as any).getVersion();\n    this.n32 = (this.instance.exports as any).getFieldNumLen32();\n\n    (this.instance.exports as any).getRawPrime();\n    const arr = new Uint32Array(this.n32);\n    for (let i = 0; i < this.n32; i++) {\n      arr[this.n32 - 1 - i] = (this.instance.exports as any).readSharedRWMemory(i);\n    }\n    this.prime = fromArray32(arr);\n\n    this.witnessSize = (this.instance.exports as any).getWitnessSize();\n\n    this.sanityCheck = sanityCheck;\n  }\n\n  circom_version() {\n    return (this.instance.exports as any).getVersion();\n  }\n\n  async _doCalculateWitness(input, sanityCheck) {\n    //input is assumed to be a map from signals to arrays of bigints\n    (this.instance.exports as any).init(this.sanityCheck || sanityCheck ? 1 : 0);\n    const keys = Object.keys(input);\n    let input_counter = 0;\n    keys.forEach((k) => {\n      const h = fnvHash(k);\n      const hMSB = parseInt(h.slice(0, 8), 16);\n      const hLSB = parseInt(h.slice(8, 16), 16);\n      const fArr = flatArray(input[k]);\n      let signalSize = (this.instance.exports as any).getInputSignalSize(hMSB, hLSB);\n      if (signalSize < 0) {\n        throw new Error(`Signal ${k} not found\\n`);\n      }\n      if (fArr.length < signalSize) {\n        throw new Error(`Not enough values for input signal ${k}\\n`);\n      }\n      if (fArr.length > signalSize) {\n        throw new Error(`Too many values for input signal ${k}\\n`);\n      }\n      for (let i = 0; i < fArr.length; i++) {\n        const arrFr = toArray32(BigInt(fArr[i]) % this.prime, this.n32);\n        for (let j = 0; j < this.n32; j++) {\n          (this.instance.exports as any).writeSharedRWMemory(j, arrFr[this.n32 - 1 - j]);\n        }\n        try {\n          (this.instance.exports as any).setInputSignal(hMSB, hLSB, i);\n          input_counter++;\n        } catch (err) {\n          // console.log(`After adding signal ${i} of ${k}`)\n          throw new Error(err);\n        }\n      }\n    });\n    if (input_counter < (this.instance.exports as any).getInputSize()) {\n      throw new Error(\n        `Not all inputs have been set. Only ${input_counter} out of ${(\n          this.instance.exports as any\n        ).getInputSize()}`\n      );\n    }\n  }\n\n  async calculateWitness(input, sanityCheck) {\n    const w: bigint[] = [];\n\n    await this._doCalculateWitness(input, sanityCheck);\n\n    for (let i = 0; i < this.witnessSize; i++) {\n      (this.instance.exports as any).getWitness(i);\n      const arr = new Uint32Array(this.n32);\n      for (let j = 0; j < this.n32; j++) {\n        arr[this.n32 - 1 - j] = (this.instance.exports as any).readSharedRWMemory(j);\n      }\n      w.push(fromArray32(arr));\n    }\n\n    return w;\n  }\n\n  async calculateBinWitness(input, sanityCheck) {\n    const buff32 = new Uint32Array(this.witnessSize * this.n32);\n    const buff = new Uint8Array(buff32.buffer);\n    await this._doCalculateWitness(input, sanityCheck);\n\n    for (let i = 0; i < this.witnessSize; i++) {\n      (this.instance.exports as any).getWitness(i);\n      const pos = i * this.n32;\n      for (let j = 0; j < this.n32; j++) {\n        buff32[pos + j] = (this.instance.exports as any).readSharedRWMemory(j);\n      }\n    }\n\n    return buff;\n  }\n\n  async calculateWTNSBin(input, sanityCheck) {\n    const buff32 = new Uint32Array(this.witnessSize * this.n32 + this.n32 + 11);\n    const buff = new Uint8Array(buff32.buffer);\n    await this._doCalculateWitness(input, sanityCheck);\n\n    //\"wtns\"\n    buff[0] = 'w'.charCodeAt(0);\n    buff[1] = 't'.charCodeAt(0);\n    buff[2] = 'n'.charCodeAt(0);\n    buff[3] = 's'.charCodeAt(0);\n\n    //version 2\n    buff32[1] = 2;\n\n    //number of sections: 2\n    buff32[2] = 2;\n\n    //id section 1\n    buff32[3] = 1;\n\n    const n8 = this.n32 * 4;\n    //id section 1 length in 64bytes\n    const idSection1length = 8 + n8;\n    const idSection1lengthHex = idSection1length.toString(16);\n    buff32[4] = parseInt(idSection1lengthHex.slice(0, 8), 16);\n    buff32[5] = parseInt(idSection1lengthHex.slice(8, 16), 16);\n\n    //this.n32\n    buff32[6] = n8;\n\n    //prime number\n    this.instance.exports.getRawPrime();\n\n    let pos = 7;\n    for (let j = 0; j < this.n32; j++) {\n      buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);\n    }\n    pos += this.n32;\n\n    // witness size\n    buff32[pos] = this.witnessSize;\n    pos++;\n\n    //id section 2\n    buff32[pos] = 2;\n    pos++;\n\n    // section 2 length\n    const idSection2length = n8 * this.witnessSize;\n    const idSection2lengthHex = idSection2length.toString(16);\n    buff32[pos] = parseInt(idSection2lengthHex.slice(0, 8), 16);\n    buff32[pos + 1] = parseInt(idSection2lengthHex.slice(8, 16), 16);\n\n    pos += 2;\n    for (let i = 0; i < this.witnessSize; i++) {\n      this.instance.exports.getWitness(i);\n      for (let j = 0; j < this.n32; j++) {\n        buff32[pos + j] = this.instance.exports.readSharedRWMemory(j);\n      }\n      pos += this.n32;\n    }\n\n    return buff;\n  }\n}\n\nfunction toArray32(rem, size) {\n  const res: number[] = []; //new Uint32Array(size); //has no unshift\n  const radix = BigInt(0x100000000);\n  while (rem) {\n    res.unshift(Number(rem % radix));\n    rem = rem / radix;\n  }\n  if (size) {\n    let i = size - res.length;\n    while (i > 0) {\n      res.unshift(0);\n      i--;\n    }\n  }\n  return res;\n}\n\nfunction fromArray32(arr) {\n  //returns a BigInt\n  let res = BigInt(0);\n  const radix = BigInt(0x100000000);\n  for (let i = 0; i < arr.length; i++) {\n    res = res * radix + BigInt(arr[i]);\n  }\n  return res;\n}\n\nfunction flatArray(a) {\n  let res = [];\n  fillArray(res, a);\n  return res;\n\n  function fillArray(res, a) {\n    if (Array.isArray(a)) {\n      for (let i = 0; i < a.length; i++) {\n        fillArray(res, a[i]);\n      }\n    } else {\n      res.push(a);\n    }\n  }\n}\n\nfunction fnvHash(str) {\n  const uint64_max = BigInt(2) ** BigInt(64);\n  let hash = BigInt('0xCBF29CE484222325');\n  for (let i = 0; i < str.length; i++) {\n    hash ^= BigInt(str[i].charCodeAt());\n    hash *= BigInt(0x100000001b3);\n    hash %= uint64_max;\n  }\n  let shash = hash.toString(16);\n  let n = 16 - shash.length;\n  shash = '0'.repeat(n).concat(shash);\n  return shash;\n}\n","import { ZKProof } from './proving';\nimport { witnessBuilder } from './witness_calculator';\nimport { groth16 } from 'snarkjs';\nimport { fromBigEndian } from '@iden3/js-iden3-core';\n\nexport const Groth16 = 'groth16';\nexport const AuthCircuit = 'auth';\nexport const AuthV2Circuit = 'authV2';\nconst textDecoder = new TextDecoder();\n\nexport async function prove(\n  inputs: Uint8Array,\n  provingKey: Uint8Array,\n  wasm: Uint8Array\n): Promise<ZKProof> {\n  const witnessCalculator = await witnessBuilder(wasm);\n\n  const jsonString = new TextDecoder().decode(inputs);\n\n  const parsedData = JSON.parse(jsonString);\n  const wtnsBytes: Uint8Array = await witnessCalculator.calculateWTNSBin(parsedData, 0);\n\n  const { proof, publicSignals } = await groth16.prove(provingKey, wtnsBytes);\n\n  return {\n    proof: proof,\n    pub_signals: publicSignals\n  };\n}\n\nexport async function verify<T extends { challenge: bigint }>(\n  messageHash: Uint8Array,\n  proof: ZKProof,\n  verificationKey: Uint8Array,\n  unmarshall: (pubSignals: string[]) => T\n): Promise<boolean> {\n  const outputs: T = unmarshall(proof.pub_signals);\n  if (outputs.challenge !== fromBigEndian(messageHash)) {\n    throw new Error('challenge is not equal to message hash');\n  }\n  const result = await groth16.verify(\n    JSON.parse(textDecoder.decode(verificationKey)),\n    proof.pub_signals,\n    proof.proof\n  );\n  return result;\n}\n","import { ProvingMethod, ProvingMethodAlg, ZKProof } from './proving';\nimport { Id } from '@iden3/js-iden3-core';\nimport { AuthCircuit, Groth16, prove, verify } from './common';\n\n// AuthPubSignals auth.circom public signals\ninterface AuthPubSignals {\n  challenge: bigint;\n  userState: bigint;\n  userId: Id;\n}\n\n// ProvingMethodGroth16Auth defines proofs family and specific circuit\nclass ProvingMethodGroth16Auth implements ProvingMethod {\n  constructor(public readonly methodAlg: ProvingMethodAlg) {}\n\n  get alg(): string {\n    return this.methodAlg.alg;\n  }\n\n  get circuitId(): string {\n    return this.methodAlg.circuitId;\n  }\n\n  unmarshall(pubsignals: string[]): AuthPubSignals {\n    const outputs: AuthPubSignals = {} as AuthPubSignals;\n    if (pubsignals.length != 3) {\n      throw new Error(`invalid number of Output values expected ${3} got ${pubsignals.length}`);\n    }\n    outputs.challenge = BigInt(pubsignals[0]);\n    outputs.userState = BigInt(pubsignals[1]);\n    outputs.userId = Id.fromBigInt(BigInt(pubsignals[2]));\n\n    return outputs;\n  }\n\n  async verify(\n    messageHash: Uint8Array,\n    proof: ZKProof,\n    verificationKey: Uint8Array\n  ): Promise<boolean> {\n    return verify<AuthPubSignals>(messageHash, proof, verificationKey, this.unmarshall);\n  }\n\n  prove(inputs: Uint8Array, provingKey: Uint8Array, wasm: Uint8Array): Promise<ZKProof> {\n    return prove(inputs, provingKey, wasm);\n  }\n}\n\nexport const provingMethodGroth16AuthInstance: ProvingMethod = new ProvingMethodGroth16Auth(\n  new ProvingMethodAlg(Groth16, AuthCircuit)\n);\n","import { Id } from '@iden3/js-iden3-core';\nimport { ProvingMethod, ProvingMethodAlg, ZKProof } from './proving';\nimport { AuthV2Circuit, Groth16, prove, verify } from './common';\nimport { Hash } from '@iden3/js-merkletree';\nimport { getCurveFromName } from 'ffjavascript';\n\n// AuthV2PubSignals auth.circom public signals\nexport interface AuthV2PubSignals {\n  userID: Id;\n  challenge: bigint;\n  GISTRoot: Hash;\n}\n\nexport const AuthV2Groth16Alg = new ProvingMethodAlg(Groth16, AuthV2Circuit);\n\n// ProvingMethodGroth16AuthV2 instance for Groth16 proving method with an authV2 circuit\nexport class ProvingMethodGroth16AuthV2 implements ProvingMethod {\n  private static readonly curveName = 'bn128';\n\n  constructor(public readonly methodAlg: ProvingMethodAlg) {}\n\n  get alg(): string {\n    return this.methodAlg.alg;\n  }\n\n  get circuitId(): string {\n    return this.methodAlg.circuitId;\n  }\n\n  async verify(\n    messageHash: Uint8Array,\n    proof: ZKProof,\n    verificationKey: Uint8Array\n  ): Promise<boolean> {\n    const verificationResult = await verify<AuthV2PubSignals>(\n      messageHash,\n      proof,\n      verificationKey,\n      this.unmarshall\n    );\n    await this.terminateCurve();\n\n    return verificationResult;\n  }\n\n  async prove(inputs: Uint8Array, provingKey: Uint8Array, wasm: Uint8Array): Promise<ZKProof> {\n    const zkProof = await prove(inputs, provingKey, wasm);\n    await this.terminateCurve();\n    return zkProof;\n  }\n\n  private async terminateCurve(): Promise<void> {\n    const curve = await getCurveFromName(ProvingMethodGroth16AuthV2.curveName);\n    curve.terminate();\n  }\n\n  unmarshall(pubSignals: string[]): AuthV2PubSignals {\n    const len = 3;\n\n    if (pubSignals.length !== len) {\n      throw new Error(`invalid number of Output values expected ${len} got ${pubSignals.length}`);\n    }\n\n    return {\n      userID: Id.fromBigInt(BigInt(pubSignals[0])),\n      challenge: BigInt(pubSignals[1]),\n      GISTRoot: Hash.fromString(pubSignals[2])\n    };\n  }\n}\n\nexport const provingMethodGroth16AuthV2Instance: ProvingMethod = new ProvingMethodGroth16AuthV2(\n  new ProvingMethodAlg(Groth16, AuthV2Circuit)\n);\n","import { hash } from './hash';\nimport { Token, Header } from './jwz';\nimport { provingMethodGroth16AuthInstance } from './authGroth16';\nimport {\n  getProvingMethod,\n  ProofInputsPreparerHandlerFunc,\n  ProvingMethod,\n  ProvingMethodAlg,\n  registerProvingMethod,\n  ZKProof,\n  ProofData\n} from './proving';\nimport { provingMethodGroth16AuthV2Instance } from './authV2Groth16';\n\nregisterProvingMethod(\n  provingMethodGroth16AuthInstance.methodAlg,\n  () => provingMethodGroth16AuthInstance\n);\n\nregisterProvingMethod(\n  provingMethodGroth16AuthV2Instance.methodAlg,\n  () => provingMethodGroth16AuthV2Instance\n);\n\nconst proving = {\n  registerProvingMethod,\n  getProvingMethod,\n  provingMethodGroth16AuthInstance,\n  provingMethodGroth16AuthV2Instance\n};\n\nexport {\n  proving,\n  ProofInputsPreparerHandlerFunc,\n  ProvingMethod,\n  ProvingMethodAlg,\n  Token,\n  hash,\n  ZKProof,\n  ProofData,\n  Header\n};\n"],"names":["qString","hash","message","hashBytes","sha256","bi","fromBigEndian","reverse","m","BigInt","poseidon","ProvingMethodAlg","constructor","alg","circuitId","this","toString","provingMethods","Map","registerProvingMethod","f","Promise","res","set","getProvingMethod","rej","func","get","Header","base64UrlEncoding","chars","bits","base64url","string","opts","encoding","_opts$out","codes","i","length","loose","SyntaxError","end","out","Uint8Array","buffer","written","_i","value","undefined","parse","data","_opts$pad","pad","mask","stringify","RawJSONWebZeroknowledge","payload","protectedHeaders","header","zkp","sanitized","Error","headers","JSON","TextDecoder","decode","Critical","forEach","key","Alg","CircuitId","method","token","Token","zkProof","Object","entries","setHeader","inputsPreparer","raw","getDefaultHeaders","TextEncoder","encode","getPayload","Type","tokenStr","trim","startsWith","parseFull","parseCompact","parts","split","rawProtected","base64","rawPayload","proof","prove","provingKey","wasm","serializeHeaders","msgHash","getMessageHash","inputs","prepare","marshaledProof","compactSerialize","serializedProtected","serializedProof","fullSerialize","serializedHeadersJSON","serializedHeaders","messageToProof","hashInt","toBigEndian","verify","verificationKey","keys","sort","async","witnessBuilder","code","options","wasmModule","wc","WebAssembly","compile","err","console","log","errStr","msgStr","instance","instantiate","runtime","exceptionHandler","printErrorMessage","getMessage","writeBufferMessage","msg","showSharedRWMemory","shared_rw_memory_size","exports","getFieldNumLen32","arr","Uint32Array","j","readSharedRWMemory","fromArray32","printSharedRWMemory","WitnessCalculator","c","getMessageChar","String","fromCharCode","sanityCheck","version","getVersion","n32","getRawPrime","prime","witnessSize","getWitnessSize","circom_version","_doCalculateWitness","input","init","input_counter","k","h","str","uint64_max","charCodeAt","shash","n","repeat","concat","fnvHash","hMSB","parseInt","slice","hLSB","fArr","a","fillArray","Array","isArray","push","flatArray","signalSize","getInputSignalSize","arrFr","toArray32","writeSharedRWMemory","setInputSignal","getInputSize","calculateWitness","w","getWitness","calculateBinWitness","buff32","buff","pos","calculateWTNSBin","n8","idSection1lengthHex","idSection2lengthHex","rem","size","radix","unshift","Number","Groth16","textDecoder","witnessCalculator","jsonString","parsedData","wtnsBytes","publicSignals","groth16","pub_signals","messageHash","unmarshall","challenge","provingMethodGroth16AuthInstance","methodAlg","pubsignals","outputs","userState","userId","Id","fromBigInt","ProvingMethodGroth16AuthV2","verificationResult","terminateCurve","getCurveFromName","curveName","terminate","pubSignals","userID","GISTRoot","Hash","fromString","provingMethodGroth16AuthV2Instance","proving"],"mappings":"oQAGO,MAAMA,EACX,gFAEI,SAAUC,EAAKC,GAEnB,MAAMC,EAAYC,EAAOF,GAGnBG,EAAKC,EAAcH,EAAUI,WAEnC,IAAIC,EAAIC,OAAO,GAOf,OALED,EADqBH,EAWZI,OAAOT,GAVZK,EAEAA,EAAKI,OAAOT,GAGXU,EAAST,KAAK,CAACO,GACxB,OCVaG,EACX,WAAAC,CAA4BC,EAA6BC,GAA7BC,KAAGF,IAAHA,EAA6BE,KAASD,UAATA,CAAqB,CAE9E,QAAAE,GACE,MAAO,GAAGD,KAAKF,OAAOE,KAAKD,WAC5B,EAGH,MAAMG,EAAiB,IAAIC,IAkBX,SAAAC,EACdN,EACAO,GAEA,OAAO,IAAIC,SAASC,IAClBL,EAAeM,IAAIV,EAAIG,WAAYI,GACnCE,GAAK,GAET,CAGM,SAAUE,EAAiBX,GAC/B,OAAO,IAAIQ,SAAQ,CAACC,EAAKG,KACvB,MAAMC,EAAOT,EAAeU,IAAId,EAAIG,YACpC,GAAIU,EAAM,CAERJ,EAD8BI,IAE/B,MACCD,EAAI,cACL,GAEL,CCkEA,IC/GYG,ED+GRC,EAAoB,CACtBC,MAAO,mEACPC,KAAM,GAsCJC,EACK,SAAiBC,EAAQC,GAC9B,OArKJ,SAAeD,EAAQE,EAAUD,GAC/B,IAAIE,EAOJ,QALa,IAATF,IACFA,EAAO,CAAA,IAIJC,EAASE,MAAO,CACnBF,EAASE,MAAQ,GAEjB,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAASL,MAAMS,SAAUD,EAC3CH,EAASE,MAAMF,EAASL,MAAMQ,IAAMA,CAEvC,CAGD,IAAKJ,EAAKM,OAASP,EAAOM,OAASJ,EAASJ,KAAO,EACjD,MAAM,IAAIU,YAAY,mBAMxB,IAFA,IAAIC,EAAMT,EAAOM,OAEU,MAApBN,EAAOS,EAAM,IAGlB,KAFEA,IAEGR,EAAKM,QAAYP,EAAOM,OAASG,GAAOP,EAASJ,KAAO,GAC3D,MAAM,IAAIU,YAAY,mBAa1B,IARA,IAAIE,EAAM,IAA+B,OAAzBP,EAAYF,EAAKS,KAAeP,EAAYQ,YAAYF,EAAMP,EAASJ,KAAO,EAAI,GAE9FA,EAAO,EAEPc,EAAS,EAETC,EAAU,EAELC,EAAK,EAAGA,EAAKL,IAAOK,EAAI,CAE/B,IAAIC,EAAQb,EAASE,MAAMJ,EAAOc,IAElC,QAAcE,IAAVD,EACF,MAAM,IAAIP,YAAY,qBAAuBR,EAAOc,IAItDF,EAASA,GAAUV,EAASJ,KAAOiB,GACnCjB,GAAQI,EAASJ,OAEL,IACVA,GAAQ,EACRY,EAAIG,KAAa,IAAOD,GAAUd,EAErC,CAGD,GAAIA,GAAQI,EAASJ,MAAQ,IAAOc,GAAU,EAAId,EAChD,MAAM,IAAIU,YAAY,0BAGxB,OAAOE,CACT,CAoGWO,CAAMjB,EAAQJ,EAAmBK,EACzC,EAHCF,EAIS,SAAqBmB,EAAMjB,GACpC,OAtGJ,SAAmBiB,EAAMhB,EAAUD,QACpB,IAATA,IACFA,EAAO,CAAA,GAYT,IATA,IACIkB,EADQlB,EACUmB,IAClBA,OAAoB,IAAdD,GAA8BA,EACpCE,GAAQ,GAAKnB,EAASJ,MAAQ,EAC9BY,EAAM,GACNZ,EAAO,EAEPc,EAAS,EAEJP,EAAI,EAAGA,EAAIa,EAAKZ,SAAUD,EAKjC,IAHAO,EAASA,GAAU,EAAI,IAAOM,EAAKb,GACnCP,GAAQ,EAEDA,EAAOI,EAASJ,MACrBA,GAAQI,EAASJ,KACjBY,GAAOR,EAASL,MAAMwB,EAAOT,GAAUd,GAU3C,GALIA,IACFY,GAAOR,EAASL,MAAMwB,EAAOT,GAAUV,EAASJ,KAAOA,IAIrDsB,EACF,KAAOV,EAAIJ,OAASJ,EAASJ,KAAO,GAClCY,GAAO,IAIX,OAAOA,CACT,CAgEWY,CAAUJ,EAAMtB,EAAmBK,EAC3C,GC7JH,SAAYN,GACVA,EAAA,KAAA,MACAA,EAAA,IAAA,MACAA,EAAA,UAAA,YACAA,EAAA,SAAA,MACD,CALD,CAAYA,IAAAA,EAKX,CAAA,UAWY4B,EACX,WAAA5C,CACS6C,EACAC,EACAC,EACAC,GAHA7C,KAAO0C,QAAPA,EACA1C,KAAgB2C,iBAAhBA,EACA3C,KAAM4C,OAANA,EACA5C,KAAG6C,IAAHA,CACL,CAEJ,eAAMC,GACJ,IAAK9C,KAAK0C,QACR,MAAM,IAAIK,MAAM,gDAGlB,MAAMC,EAAsCC,KAAKd,OAC/C,IAAIe,aAAcC,OAAOnD,KAAK2C,mBAERK,EAAQnC,EAAOuC,UACvBC,SAASC,IACvB,IAAKN,EAAQM,GACX,MAAM,IAAIP,MAAM,8CAA8CO,uBAC/D,IAGH,MAAMxD,EAAMkD,EAAQnC,EAAO0C,KACrBxD,EAAYiD,EAAQnC,EAAO2C,WAE3BC,QAAehD,EAAiB,IAAIb,EAAiBE,EAAKC,IAC1D8C,EAAMI,KAAKd,OAAM,IAAIe,aAAcC,OAAOnD,KAAK6C,MAC/Ca,EAAQ,IAAIC,EAAMF,GAAQ,IAAIP,aAAcC,OAAOnD,KAAK0C,UAC9DgB,EAAM5D,IAAMA,EACZ4D,EAAM3D,UAAYA,EAClB2D,EAAME,QAAUf,EAChB,IAAK,MAAOS,EAAKrB,KAAU4B,OAAOC,QAAQd,GACxCU,EAAMK,UAAUT,EAAKrB,GAGvB,OAAOyB,CACR,QAIUC,EAMX,WAAA9D,CACkB4D,EAChBf,EACiBsB,GAFDhE,KAAMyD,OAANA,EAECzD,KAAcgE,eAAdA,EALZhE,KAAO4D,QAAY,GAOxB5D,KAAKF,IAAME,KAAKyD,OAAO3D,IACvBE,KAAKD,UAAYC,KAAKyD,OAAO1D,UAC7BC,KAAKiE,IAAM,GACXjE,KAAKiE,IAAIrB,OAAS5C,KAAKkE,oBAEvBlE,KAAKiE,IAAIvB,SAAU,IAAIyB,aAAcC,OAAO1B,EAC7C,CAEM,SAAAqB,CAAUT,EAAarB,GAC5BjC,KAAKiE,IAAIrB,OAAOU,GAAOrB,CACxB,CAEM,UAAAoC,GACL,OAAO,IAAInB,aAAcC,OAAOnD,KAAKiE,IAAIvB,QAC1C,CAEO,iBAAAwB,GACN,MAAO,CACL,CAACrD,EAAO0C,KAAMvD,KAAKF,IACnB,CAACe,EAAOuC,UAAW,CAACvC,EAAO2C,WAC3B,CAAC3C,EAAO2C,WAAYxD,KAAKD,UACzB,CAACc,EAAOyD,MAAO,MAElB,CAGD,YAAOnC,CAAMoC,GAEX,MAAMb,EAAQa,GAAUC,OACxB,OAAOd,EAAMe,WAAW,KAAOd,EAAMe,UAAUH,GAAYZ,EAAMgB,aAAaJ,EAC/E,CAGO,yBAAaI,CAAaJ,GAChC,MAAMK,EAAQL,EAASM,MAAM,KAC7B,GAAoB,GAAhBD,EAAMpD,OACR,MAAM,IAAIuB,MAAM,6DAElB,MAAM+B,EAAeC,EAAaH,EAAM,GAAI,CAAEnD,OAAO,IAE/CuD,EAAaD,EAAaH,EAAM,GAAI,CAAEnD,OAAO,IAE7CwD,EAAQF,EAAaH,EAAM,GAAI,CAAEnD,OAAO,IAExCwC,EAAgC,IAAIxB,EACxCuC,EACAF,EACA,CAAA,EACAG,GAGF,aAAahB,EAAInB,WAClB,CAGO,sBAAa4B,CAAUH,GAC7B,MAAMN,EAAgChB,KAAKd,MAAMoC,GACjD,aAAaN,EAAInB,WAClB,CAID,WAAMoC,CAAMC,EAAwBC,GAElC,MAAMpC,EAAUhD,KAAKqF,mBAErBrF,KAAKiE,IAAItB,kBAAmB,IAAIwB,aAAcC,OAAOpB,GAErD,MAAMsC,QAA4BtF,KAAKuF,iBAEvC,IAAKvF,KAAKgE,eACR,MAAM,IAAIjB,MAAM,2CAElB,MAAMyC,iBFlFRnF,EACAnB,EACAa,GAEA,OAAOM,EAAEnB,EAAMa,EACjB,CE6EqC0F,CAAQzF,KAAKgE,eAAgBsB,EAAStF,KAAKD,WAEtEkF,QAAuBjF,KAAKyD,OAAOyB,MAAMM,EAAQL,EAAYC,GAE7DM,EAAiBzC,KAAKT,UAAUyC,GAKtC,OAHAjF,KAAK4D,QAAUqB,EACfjF,KAAKiE,IAAIpB,KAAM,IAAIsB,aAAcC,OAAOsB,GAEjC1F,KAAK2F,kBACb,CAGD,gBAAAA,GACE,IAAK3F,KAAKiE,IAAIrB,SAAW5C,KAAKiE,IAAItB,mBAAqB3C,KAAK4D,QAC1D,MAAM,IAAIb,MAAM,uDAGlB,MAAM6C,EAAsBb,EAAiB/E,KAAKiE,IAAItB,iBAAkB,CACtEL,KAAK,IAEDuD,EAAkBd,EAAiB/E,KAAKiE,IAAIpB,IAAK,CAAEP,KAAK,IAI9D,MAAO,GAAGsD,KAHgBb,EAAiB/E,KAAKiE,IAAIvB,QAAS,CAC3DJ,KAAK,OAE+CuD,GACvD,CAGD,aAAAC,GACE,OAAO7C,KAAKT,UAAUxC,KAAKiE,IAC5B,CAED,oBAAMsB,GACJ,MAAMQ,EAAwB/F,KAAKqF,mBAE7BW,GAAoB,IAAI7B,aAAcC,OAAO2B,GAC7CpD,EAAmBoC,EAAiBiB,EAAmB,CAC3D1D,KAAK,IAGDI,EAAUqC,EAAiB/E,KAAKiE,IAAIvB,QAAS,CAAEJ,KAAK,IAGpD2D,GAAiB,IAAI9B,aAAcC,OAAO,GAAGzB,KAAoBD,KAEjEwD,QAAwBhH,EAAK+G,GAEnC,OAAOE,EAAYD,EAAS,GAC7B,CAGD,YAAME,CAAOC,GAEX,MAAMf,QAAgBtF,KAAKuF,iBAI3B,OAAOvF,KAAKyD,OAAO2C,OAAOd,EAAStF,KAAK4D,QAASyC,EAClD,CAED,gBAAAhB,GACE,OAAOpC,KAAKT,UAAUxC,KAAKiE,IAAIrB,OAAQiB,OAAOyC,KAAKtG,KAAKiE,IAAIrB,QAAQ2D,OACrE,ECvNIC,eAAeC,EAAeC,EAAMC,GAGzC,IAAIC,EASAC,EAXJF,EAAUA,GAAW,GAGrB,IACEC,QAAmBE,YAAYC,QAAQL,EACxC,CAAC,MAAOM,GAGP,MAFAC,QAAQC,IAAIF,GACZC,QAAQC,IAAI,mEACN,IAAInE,MAAMiE,EACjB,CAID,IAAIG,EAAS,GACTC,EAAS,GAEb,MAAMC,QAAiBP,YAAYQ,YAAYV,EAAY,CACzDW,QAAS,CACPC,iBAAkB,SAAUd,GAC1B,IAAIM,EAgBJ,MAdEA,EADU,GAARN,EACI,sBACW,GAARA,EACH,0BACW,GAARA,EACH,wBACW,GAARA,EACH,mBACW,GAARA,EACH,uBACW,GAARA,EACH,gDAEA,mBAEF,IAAI3D,MAAMiE,EAAMG,EACvB,EACDM,kBAAmB,WACjBN,GAAUO,IAAe,IAE1B,EACDC,mBAAoB,WAClB,MAAMC,EAAMF,IAEA,OAARE,GACFX,QAAQC,IAAIE,GACZA,EAAS,KAGM,KAAXA,IACFA,GAAU,KAGZA,GAAUQ,EAEb,EACDC,mBAAoB,YA6BxB,WACE,MAAMC,EAAyBT,EAAiBU,QAAQC,mBAClDC,EAAM,IAAIC,YAAYJ,GAC5B,IAAK,IAAIK,EAAI,EAAGA,EAAIL,EAAuBK,IACzCF,EAAIH,EAAwB,EAAIK,GAAMd,EAAiBU,QAAQK,mBAAmBD,GAIrE,KAAXf,IACFA,GAAU,KAGZA,GAAUiB,EAAYJ,GAAKhI,UAC5B,CAzCKqI,EACD,KAeL,OADAzB,EAAK,IAAI0B,EAAkBlB,EAVPV,GAWbE,EAEP,SAASa,IACP,IAAIvI,EAAU,GACVqJ,EAAKnB,EAAiBU,QAAQU,iBAClC,KAAY,GAALD,GACLrJ,GAAWuJ,OAAOC,aAAaH,GAC/BA,EAAKnB,EAAiBU,QAAQU,iBAEhC,OAAOtJ,CACR,CAgBH,CAEA,MAAMoJ,EAMJ,WAAA1I,CAAoBwH,EAAUuB,GAAV5I,KAAQqH,SAARA,EAClBrH,KAAKqH,SAAWA,EAChBrH,KAAK6I,QAAW7I,KAAKqH,SAASU,QAAgBe,aAC9C9I,KAAK+I,IAAO/I,KAAKqH,SAASU,QAAgBC,mBAEzChI,KAAKqH,SAASU,QAAgBiB,cAC/B,MAAMf,EAAM,IAAIC,YAAYlI,KAAK+I,KACjC,IAAK,IAAIxH,EAAI,EAAGA,EAAIvB,KAAK+I,IAAKxH,IAC5B0G,EAAIjI,KAAK+I,IAAM,EAAIxH,GAAMvB,KAAKqH,SAASU,QAAgBK,mBAAmB7G,GAE5EvB,KAAKiJ,MAAQZ,EAAYJ,GAEzBjI,KAAKkJ,YAAelJ,KAAKqH,SAASU,QAAgBoB,iBAElDnJ,KAAK4I,YAAcA,CACpB,CAED,cAAAQ,GACE,OAAQpJ,KAAKqH,SAASU,QAAgBe,YACvC,CAED,yBAAMO,CAAoBC,EAAOV,GAE9B5I,KAAKqH,SAASU,QAAgBwB,KAAKvJ,KAAK4I,aAAeA,EAAc,EAAI,GAC1E,MAAMtC,EAAOzC,OAAOyC,KAAKgD,GACzB,IAAIE,EAAgB,EA8BpB,GA7BAlD,EAAKjD,SAASoG,IACZ,MAAMC,EAmLZ,SAAiBC,GACf,MAAMC,EAAalK,OAAO,IAAMA,OAAO,IACvC,IAAIR,EAAOQ,OAAO,sBAClB,IAAK,IAAI6B,EAAI,EAAGA,EAAIoI,EAAInI,OAAQD,IAC9BrC,GAAQQ,OAAOiK,EAAIpI,GAAGsI,cACtB3K,GAAQQ,OAAO,eACfR,GAAQ0K,EAEV,IAAIE,EAAQ5K,EAAKe,SAAS,IACtB8J,EAAI,GAAKD,EAAMtI,OAEnB,OADAsI,EAAQ,IAAIE,OAAOD,GAAGE,OAAOH,GACtBA,CACT,CA/LgBI,CAAQT,GACZU,EAAOC,SAASV,EAAEW,MAAM,EAAG,GAAI,IAC/BC,EAAOF,SAASV,EAAEW,MAAM,EAAG,IAAK,IAChCE,EAgKZ,SAAmBC,GACjB,IAAIjK,EAAM,GAEV,OADAkK,EAAUlK,EAAKiK,GACRjK,EAEP,SAASkK,EAAUlK,EAAKiK,GACtB,GAAIE,MAAMC,QAAQH,GAChB,IAAK,IAAIjJ,EAAI,EAAGA,EAAIiJ,EAAEhJ,OAAQD,IAC5BkJ,EAAUlK,EAAKiK,EAAEjJ,SAGnBhB,EAAIqK,KAAKJ,EAEZ,CACH,CA9KmBK,CAAUvB,EAAMG,IAC7B,IAAIqB,EAAc9K,KAAKqH,SAASU,QAAgBgD,mBAAmBZ,EAAMG,GACzE,GAAIQ,EAAa,EACf,MAAM,IAAI/H,MAAM,UAAU0G,iBAE5B,GAAIc,EAAK/I,OAASsJ,EAChB,MAAM,IAAI/H,MAAM,sCAAsC0G,OAExD,GAAIc,EAAK/I,OAASsJ,EAChB,MAAM,IAAI/H,MAAM,oCAAoC0G,OAEtD,IAAK,IAAIlI,EAAI,EAAGA,EAAIgJ,EAAK/I,OAAQD,IAAK,CACpC,MAAMyJ,EAAQC,EAAUvL,OAAO6K,EAAKhJ,IAAMvB,KAAKiJ,MAAOjJ,KAAK+I,KAC3D,IAAK,IAAIZ,EAAI,EAAGA,EAAInI,KAAK+I,IAAKZ,IAC3BnI,KAAKqH,SAASU,QAAgBmD,oBAAoB/C,EAAG6C,EAAMhL,KAAK+I,IAAM,EAAIZ,IAE7E,IACGnI,KAAKqH,SAASU,QAAgBoD,eAAehB,EAAMG,EAAM/I,GAC1DiI,GACD,CAAC,MAAOxC,GAEP,MAAM,IAAIjE,MAAMiE,EACjB,CACF,KAECwC,EAAiBxJ,KAAKqH,SAASU,QAAgBqD,eACjD,MAAM,IAAIrI,MACR,sCAAsCyG,YACpCxJ,KAAKqH,SAASU,QACdqD,iBAGP,CAED,sBAAMC,CAAiB/B,EAAOV,GAC5B,MAAM0C,EAAc,SAEdtL,KAAKqJ,oBAAoBC,EAAOV,GAEtC,IAAK,IAAIrH,EAAI,EAAGA,EAAIvB,KAAKkJ,YAAa3H,IAAK,CACxCvB,KAAKqH,SAASU,QAAgBwD,WAAWhK,GAC1C,MAAM0G,EAAM,IAAIC,YAAYlI,KAAK+I,KACjC,IAAK,IAAIZ,EAAI,EAAGA,EAAInI,KAAK+I,IAAKZ,IAC5BF,EAAIjI,KAAK+I,IAAM,EAAIZ,GAAMnI,KAAKqH,SAASU,QAAgBK,mBAAmBD,GAE5EmD,EAAEV,KAAKvC,EAAYJ,GACpB,CAED,OAAOqD,CACR,CAED,yBAAME,CAAoBlC,EAAOV,GAC/B,MAAM6C,EAAS,IAAIvD,YAAYlI,KAAKkJ,YAAclJ,KAAK+I,KACjD2C,EAAO,IAAI7J,WAAW4J,EAAO3J,cAC7B9B,KAAKqJ,oBAAoBC,EAAOV,GAEtC,IAAK,IAAIrH,EAAI,EAAGA,EAAIvB,KAAKkJ,YAAa3H,IAAK,CACxCvB,KAAKqH,SAASU,QAAgBwD,WAAWhK,GAC1C,MAAMoK,EAAMpK,EAAIvB,KAAK+I,IACrB,IAAK,IAAIZ,EAAI,EAAGA,EAAInI,KAAK+I,IAAKZ,IAC5BsD,EAAOE,EAAMxD,GAAMnI,KAAKqH,SAASU,QAAgBK,mBAAmBD,EAEvE,CAED,OAAOuD,CACR,CAED,sBAAME,CAAiBtC,EAAOV,GAC5B,MAAM6C,EAAS,IAAIvD,YAAYlI,KAAKkJ,YAAclJ,KAAK+I,IAAM/I,KAAK+I,IAAM,IAClE2C,EAAO,IAAI7J,WAAW4J,EAAO3J,cAC7B9B,KAAKqJ,oBAAoBC,EAAOV,GAGtC8C,EAAK,GAAK,IAAI7B,WAAW,GACzB6B,EAAK,GAAK,IAAI7B,WAAW,GACzB6B,EAAK,GAAK,IAAI7B,WAAW,GACzB6B,EAAK,GAAK,IAAI7B,WAAW,GAGzB4B,EAAO,GAAK,EAGZA,EAAO,GAAK,EAGZA,EAAO,GAAK,EAEZ,MAAMI,EAAgB,EAAX7L,KAAK+I,IAGV+C,GADmB,EAAID,GACgB5L,SAAS,IACtDwL,EAAO,GAAKrB,SAAS0B,EAAoBzB,MAAM,EAAG,GAAI,IACtDoB,EAAO,GAAKrB,SAAS0B,EAAoBzB,MAAM,EAAG,IAAK,IAGvDoB,EAAO,GAAKI,EAGZ7L,KAAKqH,SAASU,QAAQiB,cAEtB,IAAI2C,EAAM,EACV,IAAK,IAAIxD,EAAI,EAAGA,EAAInI,KAAK+I,IAAKZ,IAC5BsD,EAAOE,EAAMxD,GAAKnI,KAAKqH,SAASU,QAAQK,mBAAmBD,GAE7DwD,GAAO3L,KAAK+I,IAGZ0C,EAAOE,GAAO3L,KAAKkJ,YACnByC,IAGAF,EAAOE,GAAO,EACdA,IAGA,MACMI,GADmBF,EAAK7L,KAAKkJ,aACUjJ,SAAS,IACtDwL,EAAOE,GAAOvB,SAAS2B,EAAoB1B,MAAM,EAAG,GAAI,IACxDoB,EAAOE,EAAM,GAAKvB,SAAS2B,EAAoB1B,MAAM,EAAG,IAAK,IAE7DsB,GAAO,EACP,IAAK,IAAIpK,EAAI,EAAGA,EAAIvB,KAAKkJ,YAAa3H,IAAK,CACzCvB,KAAKqH,SAASU,QAAQwD,WAAWhK,GACjC,IAAK,IAAI4G,EAAI,EAAGA,EAAInI,KAAK+I,IAAKZ,IAC5BsD,EAAOE,EAAMxD,GAAKnI,KAAKqH,SAASU,QAAQK,mBAAmBD,GAE7DwD,GAAO3L,KAAK+I,GACb,CAED,OAAO2C,CACR,EAGH,SAAST,EAAUe,EAAKC,GACtB,MAAM1L,EAAgB,GAChB2L,EAAQxM,OAAO,YACrB,KAAOsM,GACLzL,EAAI4L,QAAQC,OAAOJ,EAAME,IACzBF,GAAYE,EAEd,GAAID,EAAM,CACR,IAAI1K,EAAI0K,EAAO1L,EAAIiB,OACnB,KAAOD,EAAI,GACThB,EAAI4L,QAAQ,GACZ5K,GAEH,CACD,OAAOhB,CACT,CAEA,SAAS8H,EAAYJ,GAEnB,IAAI1H,EAAMb,OAAO,GACjB,MAAMwM,EAAQxM,OAAO,YACrB,IAAK,IAAI6B,EAAI,EAAGA,EAAI0G,EAAIzG,OAAQD,IAC9BhB,EAAMA,EAAM2L,EAAQxM,OAAOuI,EAAI1G,IAEjC,OAAOhB,CACT,CCrSO,MAAM8L,EAAU,UAGjBC,EAAc,IAAIpJ,YAEjBsD,eAAetB,EACpBM,EACAL,EACAC,GAEA,MAAMmH,QAA0B9F,EAAerB,GAEzCoH,GAAa,IAAItJ,aAAcC,OAAOqC,GAEtCiH,EAAaxJ,KAAKd,MAAMqK,GACxBE,QAA8BH,EAAkBX,iBAAiBa,EAAY,IAE7ExH,MAAEA,EAAK0H,cAAEA,SAAwBC,EAAQ1H,MAAMC,EAAYuH,GAEjE,MAAO,CACLzH,MAAOA,EACP4H,YAAaF,EAEjB,CAEOnG,eAAeJ,EACpB0G,EACA7H,EACAoB,EACA0G,GAGA,GADmBA,EAAW9H,EAAM4H,aACxBG,YAAczN,EAAcuN,GACtC,MAAM,IAAI/J,MAAM,0CAOlB,aALqB6J,EAAQxG,OAC3BnD,KAAKd,MAAMmK,EAAYnJ,OAAOkD,IAC9BpB,EAAM4H,YACN5H,EAAMA,MAGV,CCEO,MAAMgI,EAAkD,IApC/D,MACE,WAAApN,CAA4BqN,GAAAlN,KAASkN,UAATA,CAA+B,CAE3D,OAAIpN,GACF,OAAOE,KAAKkN,UAAUpN,GACvB,CAED,aAAIC,GACF,OAAOC,KAAKkN,UAAUnN,SACvB,CAED,UAAAgN,CAAWI,GACT,MAAMC,EAA0B,CAAA,EAChC,GAAyB,GAArBD,EAAW3L,OACb,MAAM,IAAIuB,MAAM,kDAAqDoK,EAAW3L,UAMlF,OAJA4L,EAAQJ,UAAYtN,OAAOyN,EAAW,IACtCC,EAAQC,UAAY3N,OAAOyN,EAAW,IACtCC,EAAQE,OAASC,EAAGC,WAAW9N,OAAOyN,EAAW,KAE1CC,CACR,CAED,YAAMhH,CACJ0G,EACA7H,EACAoB,GAEA,OAAOD,EAAuB0G,EAAa7H,EAAOoB,EAAiBrG,KAAK+M,WACzE,CAED,KAAA7H,CAAMM,EAAoBL,EAAwBC,GAChD,OAAOF,EAAMM,EAAQL,EAAYC,EAClC,GAID,IAAIxF,EAAiByM,ED3CI,eEUdoB,EAGX,WAAA5N,CAA4BqN,GAAAlN,KAASkN,UAATA,CAA+B,CAE3D,OAAIpN,GACF,OAAOE,KAAKkN,UAAUpN,GACvB,CAED,aAAIC,GACF,OAAOC,KAAKkN,UAAUnN,SACvB,CAED,YAAMqG,CACJ0G,EACA7H,EACAoB,GAEA,MAAMqH,QAA2BtH,EAC/B0G,EACA7H,EACAoB,EACArG,KAAK+M,YAIP,aAFM/M,KAAK2N,iBAEJD,CACR,CAED,WAAMxI,CAAMM,EAAoBL,EAAwBC,GACtD,MAAMxB,QAAgBsB,EAAMM,EAAQL,EAAYC,GAEhD,aADMpF,KAAK2N,iBACJ/J,CACR,CAEO,oBAAM+J,UACQC,EAAiBH,EAA2BI,YAC1DC,WACP,CAED,UAAAf,CAAWgB,GAGT,GAFY,IAERA,EAAWvM,OACb,MAAM,IAAIuB,MAAM,kDAAuDgL,EAAWvM,UAGpF,MAAO,CACLwM,OAAQT,EAAGC,WAAW9N,OAAOqO,EAAW,KACxCf,UAAWtN,OAAOqO,EAAW,IAC7BE,SAAUC,EAAKC,WAAWJ,EAAW,IAExC,EAnDuBN,EAASI,UAAG,QAsD/B,MAAMO,EAAoD,IAAIX,EACnE,IAAI7N,EAAiByM,EFjEM,WGO7BjM,EACE6M,EAAiCC,WACjC,IAAMD,IAGR7M,EACEgO,EAAmClB,WACnC,IAAMkB,IAGR,MAAMC,EAAU,CACdjO,wBACAK,mBACAwM,mCACAmB","x_google_ignoreList":[2]}