"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrivateKey = exports.PublicKey = exports.Signature = void 0;
const babyjub_1 = require("./babyjub");
const eddsa_1 = require("./eddsa");
const hex_1 = require("../hex");
class Signature {
    constructor(r8, s) {
        this.R8 = r8;
        this.S = s;
    }
    static newFromCompressed(buf) {
        if (buf.length !== 64) {
            throw new Error('buf must be 64 bytes');
        }
        const sig = eddsa_1.eddsa.unpackSignature(buf);
        if (sig.R8 == null) {
            throw new Error('unpackSignature failed');
        }
        return new Signature(sig.R8, sig.S);
    }
    compress() {
        return eddsa_1.eddsa.packSignature(this);
    }
    toString() {
        return this.compress().toString();
    }
    hex() {
        return hex_1.Hex.encodeString(this.compress());
    }
}
exports.Signature = Signature;
class PublicKey {
    constructor(p) {
        this.p = p;
    }
    static newFromCompressed(buf) {
        if (buf.length !== 32) {
            throw new Error('buf must be 32 bytes');
        }
        // const bufLE = utils.swapEndianness(buf);
        const p = babyjub_1.babyJub.unpackPoint(buf);
        if (p == null) {
            throw new Error('unpackPoint failed');
        }
        return new PublicKey(p);
    }
    static newFromHex(hexStr) {
        const buff = hex_1.Hex.decodeString(hexStr);
        return PublicKey.newFromCompressed(buff);
    }
    compress() {
        // return utils.swapEndianness(babyJub.packPoint(this.p));
        return babyjub_1.babyJub.packPoint(this.p);
    }
    toString() {
        return this.compress().toString();
    }
    hex() {
        return hex_1.Hex.encodeString(this.compress());
    }
    verifyPoseidon(msg, sig) {
        return eddsa_1.eddsa.verifyPoseidon(msg, sig, this.p);
    }
}
exports.PublicKey = PublicKey;
class PrivateKey {
    constructor(buf) {
        if (buf.length !== 32) {
            throw new Error('buf must be 32 bytes');
        }
        this.sk = buf;
    }
    toString() {
        return this.sk.toString();
    }
    hex() {
        return hex_1.Hex.encodeString(this.sk);
    }
    public() {
        return new PublicKey(eddsa_1.eddsa.prv2pub(this.sk));
    }
    signPoseidon(msg) {
        const s = eddsa_1.eddsa.signPoseidon(this.sk, msg);
        return new Signature(s.R8, s.S);
    }
}
exports.PrivateKey = PrivateKey;
//# sourceMappingURL=eddsa-keys.js.map