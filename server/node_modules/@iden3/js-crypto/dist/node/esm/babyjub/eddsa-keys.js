import { babyJub } from './babyjub';
import { eddsa } from './eddsa';
import { Hex } from '../hex';
export class Signature {
    constructor(r8, s) {
        this.R8 = r8;
        this.S = s;
    }
    static newFromCompressed(buf) {
        if (buf.length !== 64) {
            throw new Error('buf must be 64 bytes');
        }
        const sig = eddsa.unpackSignature(buf);
        if (sig.R8 == null) {
            throw new Error('unpackSignature failed');
        }
        return new Signature(sig.R8, sig.S);
    }
    compress() {
        return eddsa.packSignature(this);
    }
    toString() {
        return this.compress().toString();
    }
    hex() {
        return Hex.encodeString(this.compress());
    }
}
export class PublicKey {
    constructor(p) {
        this.p = p;
    }
    static newFromCompressed(buf) {
        if (buf.length !== 32) {
            throw new Error('buf must be 32 bytes');
        }
        // const bufLE = utils.swapEndianness(buf);
        const p = babyJub.unpackPoint(buf);
        if (p == null) {
            throw new Error('unpackPoint failed');
        }
        return new PublicKey(p);
    }
    static newFromHex(hexStr) {
        const buff = Hex.decodeString(hexStr);
        return PublicKey.newFromCompressed(buff);
    }
    compress() {
        // return utils.swapEndianness(babyJub.packPoint(this.p));
        return babyJub.packPoint(this.p);
    }
    toString() {
        return this.compress().toString();
    }
    hex() {
        return Hex.encodeString(this.compress());
    }
    verifyPoseidon(msg, sig) {
        return eddsa.verifyPoseidon(msg, sig, this.p);
    }
}
export class PrivateKey {
    constructor(buf) {
        if (buf.length !== 32) {
            throw new Error('buf must be 32 bytes');
        }
        this.sk = buf;
    }
    toString() {
        return this.sk.toString();
    }
    hex() {
        return Hex.encodeString(this.sk);
    }
    public() {
        return new PublicKey(eddsa.prv2pub(this.sk));
    }
    signPoseidon(msg) {
        const s = eddsa.signPoseidon(this.sk, msg);
        return new Signature(s.R8, s.S);
    }
}
//# sourceMappingURL=eddsa-keys.js.map