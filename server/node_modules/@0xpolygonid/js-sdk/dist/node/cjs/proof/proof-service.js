"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProofService = void 0;
const js_iden3_core_1 = require("@iden3/js-iden3-core");
const circuits_1 = require("../circuits");
const verifiable_1 = require("../verifiable");
const common_1 = require("./common");
const prover_1 = require("./provers/prover");
const js_jsonld_merklization_1 = require("@iden3/js-jsonld-merklization");
const iden3comm_1 = require("../iden3comm");
const schema_processor_1 = require("../schema-processor");
const encoding_1 = require("../utils/encoding");
const inputs_generator_1 = require("./provers/inputs-generator");
const pub_signals_verifier_1 = require("./verifiers/pub-signals-verifier");
/**
 * Proof service is an implementation of IProofService
 * that works with a native groth16 prover
 *
 * @public
 * @class ProofService
 * @implements implements IProofService interface
 */
class ProofService {
    /**
     * Creates an instance of ProofService.
     * @param {IIdentityWallet} _identityWallet - identity wallet
     * @param {ICredentialWallet} _credentialWallet - credential wallet
     * @param {ICircuitStorage} _circuitStorage - circuit storage to load proving / verification files
     * @param {IStateStorage} _stateStorage - state storage to get GIST proof / publish state
     */
    constructor(_identityWallet, _credentialWallet, _circuitStorage, _stateStorage, opts) {
        this._identityWallet = _identityWallet;
        this._credentialWallet = _credentialWallet;
        this._stateStorage = _stateStorage;
        this._prover = opts?.prover ?? new prover_1.NativeProver(_circuitStorage);
        this._ldOptions = { ...opts, documentLoader: opts?.documentLoader ?? (0, schema_processor_1.cacheLoader)(opts) };
        this._inputsGenerator = new inputs_generator_1.InputGenerator(_identityWallet, _credentialWallet, _stateStorage);
        this._pubSignalsVerifier = new pub_signals_verifier_1.PubSignalsVerifier(opts?.documentLoader ?? (0, schema_processor_1.cacheLoader)(opts), _stateStorage);
    }
    /** {@inheritdoc IProofService.verifyProof} */
    async verifyProof(zkp, circuitId) {
        return this._prover.verify(zkp, circuitId);
    }
    /** {@inheritdoc IProofService.verify} */
    async verifyZKPResponse(proofResp, opts) {
        const proofValid = await this._prover.verify(proofResp, proofResp.circuitId);
        if (!proofValid) {
            throw Error(`Proof with circuit id ${proofResp.circuitId} and request id ${proofResp.id} is not valid`);
        }
        const verifyContext = {
            pubSignals: proofResp.pub_signals,
            query: opts.query,
            verifiablePresentation: proofResp.vp,
            sender: opts.sender,
            challenge: BigInt(proofResp.id),
            opts: opts.opts,
            params: opts.params
        };
        const pubSignals = await this._pubSignalsVerifier.verify(proofResp.circuitId, verifyContext);
        return { linkID: pubSignals.linkID };
    }
    /** {@inheritdoc IProofService.generateProof} */
    async generateProof(proofReq, identifier, opts) {
        if (!opts) {
            opts = {
                skipRevocation: false,
                challenge: 0n
            };
        }
        let credentialWithRevStatus = { cred: opts.credential, revStatus: opts.credentialRevocationStatus };
        if (!opts.credential) {
            credentialWithRevStatus = await this.findCredentialByProofQuery(identifier, proofReq.query);
        }
        if (opts.credential && !opts.credentialRevocationStatus && !opts.skipRevocation) {
            const revStatus = await this._credentialWallet.getRevocationStatusFromCredential(opts.credential);
            credentialWithRevStatus = { cred: opts.credential, revStatus };
        }
        if (!credentialWithRevStatus.cred) {
            throw new Error(`credential not found for query ${JSON.stringify(proofReq.query)}`);
        }
        const credentialCoreClaim = await this._identityWallet.getCoreClaimFromCredential(credentialWithRevStatus.cred);
        const { nonce: authProfileNonce, genesisDID } = await this._identityWallet.getGenesisDIDMetadata(identifier);
        const preparedCredential = {
            credential: credentialWithRevStatus.cred,
            credentialCoreClaim,
            revStatus: credentialWithRevStatus.revStatus
        };
        const subjectDID = js_iden3_core_1.DID.parse(preparedCredential.credential.credentialSubject['id']);
        const { nonce: credentialSubjectProfileNonce, genesisDID: subjectGenesisDID } = await this._identityWallet.getGenesisDIDMetadata(subjectDID);
        if (subjectGenesisDID.string() !== genesisDID.string()) {
            throw new Error('subject and auth profiles are not derived from the same did');
        }
        const propertiesMetadata = (0, common_1.parseCredentialSubject)(proofReq.query.credentialSubject);
        if (!propertiesMetadata.length) {
            throw new Error('no queries in zkp request');
        }
        const mtPosition = preparedCredential.credentialCoreClaim.getMerklizedPosition();
        let mk;
        if (mtPosition !== js_iden3_core_1.MerklizedRootPosition.None) {
            mk = await preparedCredential.credential.merklize(this._ldOptions);
        }
        const context = proofReq.query['context'];
        const groupId = proofReq.query['groupId'];
        const ldContext = await this.loadLdContext(context);
        const credentialType = proofReq.query['type'];
        const queriesMetadata = [];
        const circuitQueries = [];
        for (const propertyMetadata of propertiesMetadata) {
            const queryMetadata = await (0, common_1.parseQueryMetadata)(propertyMetadata, encoding_1.byteDecoder.decode(ldContext), credentialType, this._ldOptions);
            queriesMetadata.push(queryMetadata);
            const circuitQuery = await this.toCircuitsQuery(preparedCredential.credential, queryMetadata, mk);
            circuitQueries.push(circuitQuery);
        }
        const inputs = await this.generateInputs(preparedCredential, genesisDID, proofReq, {
            ...opts,
            authProfileNonce,
            credentialSubjectProfileNonce,
            linkNonce: groupId ? opts.linkNonce : 0n
        }, circuitQueries);
        const sdQueries = queriesMetadata.filter((q) => q.operator === circuits_1.Operators.SD);
        let vp;
        if (sdQueries.length) {
            vp = (0, verifiable_1.createVerifiablePresentation)(context, credentialType, preparedCredential.credential, sdQueries);
        }
        const { proof, pub_signals } = await this._prover.generate(inputs, proofReq.circuitId);
        return {
            id: proofReq.id,
            circuitId: proofReq.circuitId,
            vp,
            proof,
            pub_signals
        };
    }
    /** {@inheritdoc IProofService.transitState} */
    async transitState(did, oldTreeState, isOldStateGenesis, stateStorage, // for compatibility with previous versions we leave this parameter
    ethSigner) {
        return this._identityWallet.transitState(did, oldTreeState, isOldStateGenesis, ethSigner, this._prover);
    }
    async generateInputs(preparedCredential, identifier, proofReq, params, circuitQueries) {
        return this._inputsGenerator.generateInputs({
            preparedCredential,
            identifier,
            proofReq,
            params,
            circuitQueries
        });
    }
    async toCircuitsQuery(credential, queryMetadata, merklizedCredential) {
        if (queryMetadata.merklizedSchema && !merklizedCredential) {
            throw new Error('merklized root position is set to None for merklized schema');
        }
        if (!queryMetadata.merklizedSchema && merklizedCredential) {
            throw new Error('merklized root position is not set to None for non-merklized schema');
        }
        const query = new circuits_1.Query();
        query.slotIndex = queryMetadata.slotIndex;
        query.operator = queryMetadata.operator;
        query.values = queryMetadata.values;
        if (queryMetadata.merklizedSchema && merklizedCredential) {
            const { proof, value: mtValue } = await merklizedCredential.proof(queryMetadata.path);
            query.valueProof = new circuits_1.ValueProof();
            query.valueProof.mtp = proof;
            query.valueProof.path = queryMetadata.claimPathKey;
            const mtEntry = (await mtValue?.mtEntry()) ?? 0n;
            query.valueProof.value = mtEntry;
            if (!queryMetadata.fieldName) {
                query.values = [mtEntry];
                return query;
            }
        }
        if (queryMetadata.operator === circuits_1.Operators.SD) {
            const [first, ...rest] = queryMetadata.fieldName.split('.');
            let v = credential.credentialSubject[first];
            for (const part of rest) {
                v = v[part];
            }
            if (typeof v === 'undefined') {
                throw new Error(`credential doesn't contain value for field ${queryMetadata.fieldName}`);
            }
            query.values = await (0, common_1.transformQueryValueToBigInts)(v, queryMetadata.datatype);
        }
        return query;
    }
    async loadLdContext(context) {
        const loader = (0, js_jsonld_merklization_1.getDocumentLoader)(this._ldOptions);
        let ldSchema;
        try {
            ldSchema = (await loader(context)).document;
        }
        catch (e) {
            throw new Error(`can't load ld context from url ${context}`);
        }
        return encoding_1.byteEncoder.encode(JSON.stringify(ldSchema));
    }
    /** {@inheritdoc IProofService.generateAuthV2Inputs} */
    async generateAuthV2Inputs(hash, did, circuitId) {
        if (circuitId !== circuits_1.CircuitId.AuthV2) {
            throw new Error('CircuitId is not supported');
        }
        const { nonce: authProfileNonce, genesisDID } = await this._identityWallet.getGenesisDIDMetadata(did);
        const challenge = js_iden3_core_1.BytesHelper.bytesToInt(hash.reverse());
        const authPrepared = await this._inputsGenerator.prepareAuthBJJCredential(genesisDID);
        const signature = await this._identityWallet.signChallenge(challenge, authPrepared.credential);
        const id = js_iden3_core_1.DID.idFromDID(genesisDID);
        const stateProof = await this._stateStorage.getGISTProof(id.bigInt());
        const gistProof = (0, common_1.toGISTProof)(stateProof);
        const authInputs = new circuits_1.AuthV2Inputs();
        authInputs.genesisID = id;
        authInputs.profileNonce = BigInt(authProfileNonce);
        authInputs.authClaim = authPrepared.coreClaim;
        authInputs.authClaimIncMtp = authPrepared.incProof.proof;
        authInputs.authClaimNonRevMtp = authPrepared.nonRevProof.proof;
        authInputs.treeState = authPrepared.incProof.treeState;
        authInputs.signature = signature;
        authInputs.challenge = challenge;
        authInputs.gistProof = gistProof;
        return authInputs.inputsMarshal();
    }
    async verifyState(circuitId, pubSignals, opts = {
        acceptedStateTransitionDelay: iden3comm_1.PROTOCOL_CONSTANTS.DEFAULT_AUTH_VERIFY_DELAY
    }) {
        if (circuitId !== circuits_1.CircuitId.AuthV2) {
            throw new Error(`CircuitId is not supported ${circuitId}`);
        }
        const authV2PubSignals = new circuits_1.AuthV2PubSignals().pubSignalsUnmarshal(encoding_1.byteEncoder.encode(JSON.stringify(pubSignals)));
        const gistRoot = authV2PubSignals.GISTRoot.bigInt();
        const userId = authV2PubSignals.userID.bigInt();
        const globalStateInfo = await this._stateStorage.getGISTRootInfo(gistRoot, userId);
        if (globalStateInfo.root !== gistRoot) {
            throw new Error(`gist info contains invalid state`);
        }
        if (globalStateInfo.replacedByRoot !== 0n) {
            if (globalStateInfo.replacedAtTimestamp === 0n) {
                throw new Error(`state was replaced, but replaced time unknown`);
            }
            const timeDiff = Date.now() -
                (0, js_iden3_core_1.getDateFromUnixTimestamp)(Number(globalStateInfo.replacedAtTimestamp)).getTime();
            if (timeDiff >
                (opts?.acceptedStateTransitionDelay ?? iden3comm_1.PROTOCOL_CONSTANTS.DEFAULT_AUTH_VERIFY_DELAY)) {
                throw new Error('global state is outdated');
            }
        }
        return true;
    }
    async findCredentialByProofQuery(did, query) {
        const credentials = await this._identityWallet.findOwnedCredentialsByDID(did, query);
        if (!credentials.length) {
            throw new Error(`no credentials belong to did or its profiles`);
        }
        //  For EQ / IN / NIN / LT / GT operations selective if credential satisfies query - we can get any.
        // TODO: choose credential for selective credentials
        const credential = query.skipClaimRevocationCheck
            ? { cred: credentials[0], revStatus: undefined }
            : await this._credentialWallet.findNonRevokedCredential(credentials);
        return credential;
    }
}
exports.ProofService = ProofService;
