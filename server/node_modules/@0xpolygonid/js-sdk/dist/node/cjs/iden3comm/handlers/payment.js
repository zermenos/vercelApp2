"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentHandler = exports.createPayment = exports.createPaymentRequest = void 0;
const constants_1 = require("../constants");
const constants_2 = require("../constants");
const js_iden3_core_1 = require("@iden3/js-iden3-core");
const uuid = __importStar(require("uuid"));
const js_jwz_1 = require("@iden3/js-jwz");
const utils_1 = require("../../utils");
const message_handler_1 = require("./message-handler");
const verifiable_1 = require("../../verifiable");
/**
 * @beta
 * createPaymentRequest is a function to create protocol payment-request message
 * @param {DID} sender - sender did
 * @param {DID} receiver - receiver did
 * @param {string} agent - agent URL
 * @param {PaymentRequestInfo[]} payments - payments
 * @returns `PaymentRequestMessage`
 */
function createPaymentRequest(sender, receiver, agent, payments) {
    const uuidv4 = uuid.v4();
    const request = {
        id: uuidv4,
        thid: uuidv4,
        from: sender.string(),
        to: receiver.string(),
        typ: constants_2.MediaType.PlainMessage,
        type: constants_1.PROTOCOL_MESSAGE_TYPE.PAYMENT_REQUEST_MESSAGE_TYPE,
        body: {
            agent,
            payments
        }
    };
    return request;
}
exports.createPaymentRequest = createPaymentRequest;
/**
 * @beta
 * createPayment is a function to create protocol payment message
 * @param {DID} sender - sender did
 * @param {DID} receiver - receiver did
 * @param {PaymentInfo[]} payments - payments
 * @returns `PaymentMessage`
 */
function createPayment(sender, receiver, payments) {
    const uuidv4 = uuid.v4();
    const request = {
        id: uuidv4,
        thid: uuidv4,
        from: sender.string(),
        to: receiver.string(),
        typ: constants_2.MediaType.PlainMessage,
        type: constants_1.PROTOCOL_MESSAGE_TYPE.PAYMENT_MESSAGE_TYPE,
        body: {
            payments
        }
    };
    return request;
}
exports.createPayment = createPayment;
/**
 *
 * Allows to process PaymentRequest protocol message
 * @beta
 * @class PaymentHandler
 * @implements implements IPaymentHandler interface
 */
class PaymentHandler extends message_handler_1.AbstractMessageHandler {
    /**
     * @beta Creates an instance of PaymentHandler.
     * @param {IPackageManager} _packerMgr - package manager to unpack message envelope
     * @param {PaymentHandlerParams} _params - payment handler params
     *
     */
    constructor(_packerMgr, _params) {
        super();
        this._packerMgr = _packerMgr;
        this._params = _params;
    }
    async handle(message, context) {
        switch (message.type) {
            case constants_1.PROTOCOL_MESSAGE_TYPE.PAYMENT_REQUEST_MESSAGE_TYPE:
                return await this.handlePaymentRequestMessage(message, context);
            case constants_1.PROTOCOL_MESSAGE_TYPE.PAYMENT_MESSAGE_TYPE:
                await this.handlePayment(message, context);
                return null;
            default:
                return super.handle(message, context);
        }
    }
    /**
     * @inheritdoc IPaymentHandler#parsePaymentRequest
     */
    async parsePaymentRequest(request) {
        const { unpackedMessage: message } = await this._packerMgr.unpack(request);
        const paymentRequest = message;
        if (message.type !== constants_1.PROTOCOL_MESSAGE_TYPE.PAYMENT_REQUEST_MESSAGE_TYPE) {
            throw new Error('Invalid media type');
        }
        return paymentRequest;
    }
    async handlePaymentRequestMessage(paymentRequest, ctx) {
        if (!paymentRequest.to) {
            throw new Error(`failed request. empty 'to' field`);
        }
        if (!paymentRequest.from) {
            throw new Error(`failed request. empty 'from' field`);
        }
        if (!paymentRequest.body.payments?.length) {
            throw new Error(`failed request. no 'payments' in body`);
        }
        if (!ctx.paymentHandler) {
            throw new Error(`please provide payment handler in context`);
        }
        const senderDID = js_iden3_core_1.DID.parse(paymentRequest.to);
        const receiverDID = js_iden3_core_1.DID.parse(paymentRequest.from);
        const payments = [];
        for (let i = 0; i < paymentRequest.body.payments.length; i++) {
            const paymentReq = paymentRequest.body.payments[i];
            if (paymentReq.type !== verifiable_1.PaymentRequestType.PaymentRequest) {
                throw new Error(`failed request. not supported '${paymentReq.type}' payment type `);
            }
            if (paymentReq.data.type !== verifiable_1.PaymentRequestDataType.Iden3PaymentRequestCryptoV1) {
                throw new Error(`failed request. not supported '${paymentReq.data.type}' payment type `);
            }
            const txId = await ctx.paymentHandler(paymentReq.data);
            payments.push({
                id: paymentReq.data.id,
                type: verifiable_1.PaymentType.Iden3PaymentCryptoV1,
                paymentData: {
                    txId
                }
            });
        }
        const paymentMessage = createPayment(senderDID, receiverDID, payments);
        const response = await this.packMessage(paymentMessage, senderDID);
        const agentResult = await fetch(paymentRequest.body.agent, {
            method: 'POST',
            body: response,
            headers: {
                'Content-Type': 'application/octet-stream'
            }
        });
        const arrayBuffer = await agentResult.arrayBuffer();
        if (!arrayBuffer.byteLength) {
            return null;
        }
        const { unpackedMessage } = await this._packerMgr.unpack(new Uint8Array(arrayBuffer));
        return unpackedMessage;
    }
    /**
     * @inheritdoc IPaymentHandler#handlePaymentRequest
     */
    async handlePaymentRequest(request, opts) {
        if (this._params.packerParams.mediaType === constants_2.MediaType.SignedMessage &&
            !this._params.packerParams.packerOptions) {
            throw new Error(`jws packer options are required for ${constants_2.MediaType.SignedMessage}`);
        }
        const paymentRequest = await this.parsePaymentRequest(request);
        if (!paymentRequest.from) {
            throw new Error(`failed request. empty 'from' field`);
        }
        if (!paymentRequest.to) {
            throw new Error(`failed request. empty 'to' field`);
        }
        const agentMessage = await this.handlePaymentRequestMessage(paymentRequest, opts);
        if (!agentMessage) {
            return null;
        }
        const senderDID = js_iden3_core_1.DID.parse(paymentRequest.to);
        return this.packMessage(agentMessage, senderDID);
    }
    /**
     * @inheritdoc IPaymentHandler#handlePayment
     */
    async handlePayment(payment, opts) {
        if (opts.paymentRequest.from !== payment.to) {
            throw new Error(`sender of the request is not a target of response - expected ${opts.paymentRequest.from}, given ${payment.to}`);
        }
        if (!payment.body.payments.length) {
            throw new Error(`failed request. empty 'payments' field in body`);
        }
        for (let i = 0; i < payment.body.payments.length; i++) {
            const p = payment.body.payments[i];
            const paymentRequestData = opts.paymentRequest.body.payments.find((r) => r.data.id === p.id);
            if (!paymentRequestData) {
                throw new Error(`can't find payment request for payment id ${p.id}`);
            }
            if (!opts.paymentValidationHandler) {
                throw new Error(`please provide payment validation handler in options`);
            }
            await opts.paymentValidationHandler(p.paymentData.txId, paymentRequestData.data);
        }
    }
    async packMessage(message, senderDID) {
        const responseEncoded = utils_1.byteEncoder.encode(JSON.stringify(message));
        const packerOpts = this._params.packerParams.mediaType === constants_2.MediaType.SignedMessage
            ? this._params.packerParams.packerOptions
            : {
                provingMethodAlg: js_jwz_1.proving.provingMethodGroth16AuthV2Instance.methodAlg
            };
        return await this._packerMgr.pack(this._params.packerParams.mediaType, responseEncoded, {
            senderDID,
            ...packerOpts
        });
    }
}
exports.PaymentHandler = PaymentHandler;
