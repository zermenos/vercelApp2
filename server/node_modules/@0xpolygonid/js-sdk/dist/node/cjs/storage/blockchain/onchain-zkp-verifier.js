"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OnChainZKPVerifier = exports.FunctionSignatures = void 0;
const ethers_1 = require("ethers");
const ZkpVerifier_json_1 = __importDefault(require("./abi/ZkpVerifier.json"));
const blockchain_1 = require("../../blockchain");
const js_iden3_core_1 = require("@iden3/js-iden3-core");
const circuits_1 = require("../../circuits");
const utils_1 = require("../../utils");
const js_crypto_1 = require("@iden3/js-crypto");
const maxGasLimit = 10000000n;
/**
 * Supported function signature for SubmitZKPResponse
 */
var FunctionSignatures;
(function (FunctionSignatures) {
    /**
     * solidity identifier for function signature:
     * function submitZKPResponse(uint64 requestId, uint256[] calldata inputs,
     * uint256[2] calldata a, uint256[2][2] calldata b, uint256[2] calldata c) public
     */
    FunctionSignatures["SubmitZKPResponseV1"] = "b68967e2";
    //function submitZKPResponseV2(tuple[](uint64 requestId,bytes zkProof,bytes data),bytes crossChainProof)
    FunctionSignatures["SubmitZKPResponseV2"] = "ade09fcd";
})(FunctionSignatures = exports.FunctionSignatures || (exports.FunctionSignatures = {}));
/**
 * OnChainZKPVerifier is a class that allows to interact with the OnChainZKPVerifier contract
 * and submitZKPResponse.
 *
 * @beta
 * @class OnChainZKPVerifier
 */
class OnChainZKPVerifier {
    /**
     *
     * Creates an instance of OnChainZKPVerifier.
     * @beta
     * @param {EthConnectionConfig[]} - array of ETH configs
     */
    constructor(_configs, _opts) {
        this._configs = _configs;
        this._opts = _opts;
        /**
         * supported circuits
         */
        this._supportedCircuits = [
            circuits_1.CircuitId.AtomicQueryMTPV2OnChain,
            circuits_1.CircuitId.AtomicQuerySigV2OnChain,
            circuits_1.CircuitId.AtomicQueryV3OnChain
        ];
        /**
         * abi coder to encode/decode structures to solidity bytes
         */
        this._abiCoder = new ethers_1.ethers.AbiCoder();
    }
    /**
     * {@inheritDoc IOnChainZKPVerifier.prepareTxArgsSubmitV1}
     */
    async prepareTxArgsSubmitV1(txData, zkProofResponse) {
        if (txData.method_id.replace('0x', '') !== FunctionSignatures.SubmitZKPResponseV1) {
            throw new Error(`prepareTxArgsSubmitV1 function doesn't implement requested method id. Only '0x${FunctionSignatures.SubmitZKPResponseV1}' is supported.`);
        }
        const requestID = zkProofResponse.id;
        const inputs = zkProofResponse.pub_signals;
        const payload = [
            requestID,
            inputs,
            zkProofResponse.proof.pi_a.slice(0, 2),
            [
                [zkProofResponse.proof.pi_b[0][1], zkProofResponse.proof.pi_b[0][0]],
                [zkProofResponse.proof.pi_b[1][1], zkProofResponse.proof.pi_b[1][0]]
            ],
            zkProofResponse.proof.pi_c.slice(0, 2)
        ];
        return payload;
    }
    /**
     * {@inheritDoc IOnChainZKPVerifier.submitZKPResponse}
     */
    async submitZKPResponse(ethSigner, txData, zkProofResponses) {
        const chainConfig = this._configs.find((i) => i.chainId == txData.chain_id);
        if (!chainConfig) {
            throw new Error(`config for chain id ${txData.chain_id} was not found`);
        }
        if (txData.method_id.replace('0x', '') !== FunctionSignatures.SubmitZKPResponseV1) {
            throw new Error(`submitZKPResponse function doesn't implement requested method id. Only '0x${FunctionSignatures.SubmitZKPResponseV1}' is supported.`);
        }
        const provider = new ethers_1.JsonRpcProvider(chainConfig.url, chainConfig.chainId);
        ethSigner = ethSigner.connect(provider);
        const response = new Map();
        const feeData = await provider.getFeeData();
        const maxFeePerGas = chainConfig.maxFeePerGas
            ? BigInt(chainConfig.maxFeePerGas)
            : feeData.maxFeePerGas;
        const maxPriorityFeePerGas = chainConfig.maxPriorityFeePerGas
            ? BigInt(chainConfig.maxPriorityFeePerGas)
            : feeData.maxPriorityFeePerGas;
        const verifierContract = new ethers_1.Contract(txData.contract_address, ZkpVerifier_json_1.default);
        for (const zkProofResponse of zkProofResponses) {
            const txArgs = await this.prepareTxArgsSubmitV1(txData, zkProofResponse);
            const payload = await verifierContract.submitZKPResponse.populateTransaction(...txArgs);
            const request = {
                to: txData.contract_address,
                data: payload.data,
                maxFeePerGas,
                maxPriorityFeePerGas
            };
            let gasLimit;
            try {
                gasLimit = await ethSigner.estimateGas(request);
            }
            catch (e) {
                gasLimit = maxGasLimit;
            }
            request.gasLimit = gasLimit;
            const transactionService = new blockchain_1.TransactionService(provider);
            const { txnHash } = await transactionService.sendTransactionRequest(ethSigner, request);
            response.set(txnHash, zkProofResponse);
        }
        return response;
    }
    /**
     * {@inheritDoc IOnChainZKPVerifier.submitZKPResponseV2}
     */
    async submitZKPResponseV2(ethSigner, txData, zkProofResponses) {
        const chainConfig = this._configs.find((i) => i.chainId == txData.chain_id);
        if (!chainConfig) {
            throw new Error(`config for chain id ${txData.chain_id} was not found`);
        }
        if (txData.method_id.replace('0x', '') !== FunctionSignatures.SubmitZKPResponseV2) {
            throw new Error(`submitZKPResponseV2 function doesn't implement requested method id. Only '0x${FunctionSignatures.SubmitZKPResponseV2}' is supported.`);
        }
        if (!this._opts?.didResolverUrl) {
            throw new Error(`did resolver url required for crosschain verification`);
        }
        const provider = new ethers_1.JsonRpcProvider(chainConfig.url, chainConfig.chainId);
        ethSigner = ethSigner.connect(provider);
        const txDataArgs = await this.prepareTxArgsSubmitV2(txData, zkProofResponses);
        const feeData = await provider.getFeeData();
        const maxFeePerGas = chainConfig.maxFeePerGas
            ? BigInt(chainConfig.maxFeePerGas)
            : feeData.maxFeePerGas;
        const maxPriorityFeePerGas = chainConfig.maxPriorityFeePerGas
            ? BigInt(chainConfig.maxPriorityFeePerGas)
            : feeData.maxPriorityFeePerGas;
        const verifierContract = new ethers_1.Contract(txData.contract_address, ZkpVerifier_json_1.default);
        const txRequestData = await verifierContract.submitZKPResponseV2.populateTransaction(...txDataArgs);
        const request = {
            to: txData.contract_address,
            data: txRequestData.data,
            maxFeePerGas,
            maxPriorityFeePerGas
        };
        let gasLimit;
        try {
            gasLimit = await ethSigner.estimateGas(request);
        }
        catch (e) {
            gasLimit = maxGasLimit;
        }
        request.gasLimit = gasLimit;
        const transactionService = new blockchain_1.TransactionService(provider);
        const { txnHash } = await transactionService.sendTransactionRequest(ethSigner, request);
        return new Map().set(txnHash, zkProofResponses);
    }
    async prepareTxArgsSubmitV2(txData, zkProofResponses) {
        if (txData.method_id.replace('0x', '') !== FunctionSignatures.SubmitZKPResponseV2) {
            throw new Error(`submit cross chain doesn't implement requested method id. Only '0x${FunctionSignatures.SubmitZKPResponseV2}' is supported.`);
        }
        if (!this._opts?.didResolverUrl) {
            throw new Error(`did resolver url required for crosschain verification`);
        }
        const gistUpdateArr = [];
        const stateUpdateArr = [];
        const payload = [];
        // Resolved gists and states to avoid duplicate requests
        const gistUpdateResolutionsPending = [];
        const stateUpdateResolutionsPending = [];
        for (const zkProof of zkProofResponses) {
            const requestID = zkProof.id;
            const inputs = zkProof.pub_signals;
            if (!this._supportedCircuits.includes(zkProof.circuitId)) {
                throw new Error(`Circuit ${zkProof.circuitId} not supported by OnChainZKPVerifier`);
            }
            const zkProofEncoded = this.packZkpProof(inputs, zkProof.proof.pi_a.slice(0, 2), [
                [zkProof.proof.pi_b[0][1], zkProof.proof.pi_b[0][0]],
                [zkProof.proof.pi_b[1][1], zkProof.proof.pi_b[1][0]]
            ], zkProof.proof.pi_c.slice(0, 2));
            const stateInfo = this.getOnChainGistRootStatePubSignals(zkProof.circuitId, zkProof.pub_signals);
            const gistUpdateResolutions = [];
            for (const gist of stateInfo.gists) {
                const gistResolutionPending = gistUpdateResolutionsPending.find((g) => g == JSON.stringify(gist));
                if (gistResolutionPending) {
                    continue;
                }
                gistUpdateResolutionsPending.push(JSON.stringify(gist));
                gistUpdateResolutions.push(this.resolveDidDocumentEip712MessageAndSignature(js_iden3_core_1.DID.parseFromId(gist.id), this._opts.didResolverUrl, { gist: gist.root }));
            }
            const stateUpdateResolutions = [];
            for (const state of stateInfo.states) {
                const stateResolutionPending = stateUpdateResolutionsPending.find((s) => s == JSON.stringify(state));
                if (stateResolutionPending) {
                    continue;
                }
                stateUpdateResolutionsPending.push(JSON.stringify(state));
                stateUpdateResolutions.push(this.resolveDidDocumentEip712MessageAndSignature(js_iden3_core_1.DID.parseFromId(state.id), this._opts.didResolverUrl, {
                    state: state.state
                }));
            }
            if (gistUpdateResolutions.length > 0) {
                gistUpdateArr.push(...(await Promise.all(gistUpdateResolutions)));
            }
            if (stateUpdateResolutions.length > 0) {
                stateUpdateArr.push(...(await Promise.all(stateUpdateResolutions)));
            }
            const metadataArr = [];
            if (zkProof.vp) {
                for (const key in zkProof.vp.verifiableCredential.credentialSubject) {
                    if (key === '@type') {
                        continue;
                    }
                    const metadataValue = js_crypto_1.poseidon.hashBytes(utils_1.byteEncoder.encode(JSON.stringify(zkProof.vp.verifiableCredential.credentialSubject[key])));
                    const bytesValue = utils_1.byteEncoder.encode(metadataValue.toString());
                    metadataArr.push({
                        key,
                        value: bytesValue
                    });
                }
            }
            const metadata = this.packMetadatas(metadataArr);
            payload.push({
                requestId: requestID,
                zkProof: zkProofEncoded,
                data: metadata
            });
        }
        const crossChainProofs = this.packCrossChainProofs(gistUpdateArr, stateUpdateArr);
        return [payload, crossChainProofs];
    }
    packZkpProof(inputs, a, b, c) {
        return this._abiCoder.encode(['uint256[] inputs', 'uint256[2]', 'uint256[2][2]', 'uint256[2]'], [inputs, a, b, c]);
    }
    packCrossChainProofs(gistUpdateArr, stateUpdateArr) {
        const proofs = [];
        for (const globalStateUpdate of gistUpdateArr) {
            proofs.push({
                proofType: 'globalStateProof',
                proof: this.packGlobalStateMsg(globalStateUpdate)
            });
        }
        for (const stateUpdate of stateUpdateArr) {
            proofs.push({
                proofType: 'stateProof',
                proof: this.packIdentityStateMsg(stateUpdate)
            });
        }
        return this._abiCoder.encode(['tuple(' + 'string proofType,' + 'bytes proof' + ')[]'], [proofs]);
    }
    packGlobalStateMsg(msg) {
        return this._abiCoder.encode([
            'tuple(' +
                'tuple(' +
                'uint256 timestamp,' +
                'bytes2 idType,' +
                'uint256 root,' +
                'uint256 replacedAtTimestamp' +
                ') globalStateMsg,' +
                'bytes signature,' +
                ')'
        ], [msg]);
    }
    packIdentityStateMsg(msg) {
        return this._abiCoder.encode([
            'tuple(' +
                'tuple(' +
                'uint256 timestamp,' +
                'uint256 id,' +
                'uint256 state,' +
                'uint256 replacedAtTimestamp' +
                ') idStateMsg,' +
                'bytes signature,' +
                ')'
        ], [msg]);
    }
    packMetadatas(metas) {
        return this._abiCoder.encode(['tuple(' + 'string key,' + 'bytes value' + ')[]'], [metas]);
    }
    getOnChainGistRootStatePubSignals(onChainCircuitId, inputs) {
        let atomicQueryPubSignals;
        switch (onChainCircuitId) {
            case circuits_1.CircuitId.AtomicQueryMTPV2OnChain:
                atomicQueryPubSignals = new circuits_1.AtomicQueryMTPV2OnChainPubSignals();
                break;
            case circuits_1.CircuitId.AtomicQuerySigV2OnChain:
                atomicQueryPubSignals = new circuits_1.AtomicQuerySigV2OnChainPubSignals();
                break;
            case circuits_1.CircuitId.AtomicQueryV3OnChain:
                atomicQueryPubSignals = new circuits_1.AtomicQueryV3OnChainPubSignals();
                break;
        }
        const encodedInputs = utils_1.byteEncoder.encode(JSON.stringify(inputs));
        atomicQueryPubSignals.pubSignalsUnmarshal(encodedInputs);
        return atomicQueryPubSignals.getStatesInfo();
    }
    async resolveDidDocumentEip712MessageAndSignature(did, resolverUrl, opts) {
        const didDoc = await (0, utils_1.resolveDidDocument)(did, resolverUrl, {
            ...opts,
            signature: utils_1.DIDDocumentSignature.EthereumEip712Signature2021
        });
        if (!didDoc.didResolutionMetadata.proof?.length) {
            throw new Error('No proof found in resolved DID document');
        }
        const message = didDoc.didResolutionMetadata.proof[0].eip712.message;
        const signature = didDoc.didResolutionMetadata.proof[0].proofValue;
        const isGistRequest = opts?.gist && !opts.state;
        if (isGistRequest) {
            return {
                globalStateMsg: {
                    timestamp: message.timestamp,
                    idType: message.idType,
                    root: message.root,
                    replacedAtTimestamp: message.replacedAtTimestamp
                },
                signature
            };
        }
        return {
            idStateMsg: {
                timestamp: message.timestamp,
                id: message.id,
                state: message.state,
                replacedAtTimestamp: message.replacedAtTimestamp
            },
            signature
        };
    }
}
exports.OnChainZKPVerifier = OnChainZKPVerifier;
