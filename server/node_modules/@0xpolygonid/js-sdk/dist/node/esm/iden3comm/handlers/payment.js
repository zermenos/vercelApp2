import { PROTOCOL_MESSAGE_TYPE } from '../constants';
import { MediaType } from '../constants';
import { DID } from '@iden3/js-iden3-core';
import * as uuid from 'uuid';
import { proving } from '@iden3/js-jwz';
import { byteEncoder } from '../../utils';
import { AbstractMessageHandler } from './message-handler';
import { PaymentRequestDataType, PaymentRequestType, PaymentType } from '../../verifiable';
/**
 * @beta
 * createPaymentRequest is a function to create protocol payment-request message
 * @param {DID} sender - sender did
 * @param {DID} receiver - receiver did
 * @param {string} agent - agent URL
 * @param {PaymentRequestInfo[]} payments - payments
 * @returns `PaymentRequestMessage`
 */
export function createPaymentRequest(sender, receiver, agent, payments) {
    const uuidv4 = uuid.v4();
    const request = {
        id: uuidv4,
        thid: uuidv4,
        from: sender.string(),
        to: receiver.string(),
        typ: MediaType.PlainMessage,
        type: PROTOCOL_MESSAGE_TYPE.PAYMENT_REQUEST_MESSAGE_TYPE,
        body: {
            agent,
            payments
        }
    };
    return request;
}
/**
 * @beta
 * createPayment is a function to create protocol payment message
 * @param {DID} sender - sender did
 * @param {DID} receiver - receiver did
 * @param {PaymentInfo[]} payments - payments
 * @returns `PaymentMessage`
 */
export function createPayment(sender, receiver, payments) {
    const uuidv4 = uuid.v4();
    const request = {
        id: uuidv4,
        thid: uuidv4,
        from: sender.string(),
        to: receiver.string(),
        typ: MediaType.PlainMessage,
        type: PROTOCOL_MESSAGE_TYPE.PAYMENT_MESSAGE_TYPE,
        body: {
            payments
        }
    };
    return request;
}
/**
 *
 * Allows to process PaymentRequest protocol message
 * @beta
 * @class PaymentHandler
 * @implements implements IPaymentHandler interface
 */
export class PaymentHandler extends AbstractMessageHandler {
    /**
     * @beta Creates an instance of PaymentHandler.
     * @param {IPackageManager} _packerMgr - package manager to unpack message envelope
     * @param {PaymentHandlerParams} _params - payment handler params
     *
     */
    constructor(_packerMgr, _params) {
        super();
        this._packerMgr = _packerMgr;
        this._params = _params;
    }
    async handle(message, context) {
        switch (message.type) {
            case PROTOCOL_MESSAGE_TYPE.PAYMENT_REQUEST_MESSAGE_TYPE:
                return await this.handlePaymentRequestMessage(message, context);
            case PROTOCOL_MESSAGE_TYPE.PAYMENT_MESSAGE_TYPE:
                await this.handlePayment(message, context);
                return null;
            default:
                return super.handle(message, context);
        }
    }
    /**
     * @inheritdoc IPaymentHandler#parsePaymentRequest
     */
    async parsePaymentRequest(request) {
        const { unpackedMessage: message } = await this._packerMgr.unpack(request);
        const paymentRequest = message;
        if (message.type !== PROTOCOL_MESSAGE_TYPE.PAYMENT_REQUEST_MESSAGE_TYPE) {
            throw new Error('Invalid media type');
        }
        return paymentRequest;
    }
    async handlePaymentRequestMessage(paymentRequest, ctx) {
        if (!paymentRequest.to) {
            throw new Error(`failed request. empty 'to' field`);
        }
        if (!paymentRequest.from) {
            throw new Error(`failed request. empty 'from' field`);
        }
        if (!paymentRequest.body.payments?.length) {
            throw new Error(`failed request. no 'payments' in body`);
        }
        if (!ctx.paymentHandler) {
            throw new Error(`please provide payment handler in context`);
        }
        const senderDID = DID.parse(paymentRequest.to);
        const receiverDID = DID.parse(paymentRequest.from);
        const payments = [];
        for (let i = 0; i < paymentRequest.body.payments.length; i++) {
            const paymentReq = paymentRequest.body.payments[i];
            if (paymentReq.type !== PaymentRequestType.PaymentRequest) {
                throw new Error(`failed request. not supported '${paymentReq.type}' payment type `);
            }
            if (paymentReq.data.type !== PaymentRequestDataType.Iden3PaymentRequestCryptoV1) {
                throw new Error(`failed request. not supported '${paymentReq.data.type}' payment type `);
            }
            const txId = await ctx.paymentHandler(paymentReq.data);
            payments.push({
                id: paymentReq.data.id,
                type: PaymentType.Iden3PaymentCryptoV1,
                paymentData: {
                    txId
                }
            });
        }
        const paymentMessage = createPayment(senderDID, receiverDID, payments);
        const response = await this.packMessage(paymentMessage, senderDID);
        const agentResult = await fetch(paymentRequest.body.agent, {
            method: 'POST',
            body: response,
            headers: {
                'Content-Type': 'application/octet-stream'
            }
        });
        const arrayBuffer = await agentResult.arrayBuffer();
        if (!arrayBuffer.byteLength) {
            return null;
        }
        const { unpackedMessage } = await this._packerMgr.unpack(new Uint8Array(arrayBuffer));
        return unpackedMessage;
    }
    /**
     * @inheritdoc IPaymentHandler#handlePaymentRequest
     */
    async handlePaymentRequest(request, opts) {
        if (this._params.packerParams.mediaType === MediaType.SignedMessage &&
            !this._params.packerParams.packerOptions) {
            throw new Error(`jws packer options are required for ${MediaType.SignedMessage}`);
        }
        const paymentRequest = await this.parsePaymentRequest(request);
        if (!paymentRequest.from) {
            throw new Error(`failed request. empty 'from' field`);
        }
        if (!paymentRequest.to) {
            throw new Error(`failed request. empty 'to' field`);
        }
        const agentMessage = await this.handlePaymentRequestMessage(paymentRequest, opts);
        if (!agentMessage) {
            return null;
        }
        const senderDID = DID.parse(paymentRequest.to);
        return this.packMessage(agentMessage, senderDID);
    }
    /**
     * @inheritdoc IPaymentHandler#handlePayment
     */
    async handlePayment(payment, opts) {
        if (opts.paymentRequest.from !== payment.to) {
            throw new Error(`sender of the request is not a target of response - expected ${opts.paymentRequest.from}, given ${payment.to}`);
        }
        if (!payment.body.payments.length) {
            throw new Error(`failed request. empty 'payments' field in body`);
        }
        for (let i = 0; i < payment.body.payments.length; i++) {
            const p = payment.body.payments[i];
            const paymentRequestData = opts.paymentRequest.body.payments.find((r) => r.data.id === p.id);
            if (!paymentRequestData) {
                throw new Error(`can't find payment request for payment id ${p.id}`);
            }
            if (!opts.paymentValidationHandler) {
                throw new Error(`please provide payment validation handler in options`);
            }
            await opts.paymentValidationHandler(p.paymentData.txId, paymentRequestData.data);
        }
    }
    async packMessage(message, senderDID) {
        const responseEncoded = byteEncoder.encode(JSON.stringify(message));
        const packerOpts = this._params.packerParams.mediaType === MediaType.SignedMessage
            ? this._params.packerParams.packerOptions
            : {
                provingMethodAlg: proving.provingMethodGroth16AuthV2Instance.methodAlg
            };
        return await this._packerMgr.pack(this._params.packerParams.mediaType, responseEncoded, {
            senderDID,
            ...packerOpts
        });
    }
}
