"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinkedMultiQueryVerifier = void 0;
const js_jsonld_merklization_1 = require("@iden3/js-jsonld-merklization");
const js_sdk_1 = require("@0xpolygonid/js-sdk");
/**
 * Verifies the linked multi-query circuit.
 * @beta
 */
class LinkedMultiQueryVerifier {
    constructor(pubSignals) {
        this.pubSignals = new js_sdk_1.LinkedMultiQueryPubSignals();
        this.bigIntCompare = (a, b) => {
            if (a < b)
                return -1;
            if (a > b)
                return 1;
            return 0;
        };
        this.pubSignals = this.pubSignals.pubSignalsUnmarshal(js_sdk_1.byteEncoder.encode(JSON.stringify(pubSignals)));
    }
    verifyIdOwnership() {
        return Promise.resolve();
    }
    async verifyQuery(query, schemaLoader, verifiablePresentation) {
        let schema;
        const ldOpts = { documentLoader: schemaLoader ?? (0, js_sdk_1.cacheLoader)() };
        try {
            schema = (await ldOpts.documentLoader(query.context)).document;
        }
        catch (e) {
            throw new Error(`can't load schema for request query`);
        }
        const ldContextJSON = JSON.stringify(schema);
        const credentialSubject = query.credentialSubject;
        const schemaId = await js_jsonld_merklization_1.Path.getTypeIDFromContext(ldContextJSON, query.type, ldOpts);
        const schemaHash = (0, js_sdk_1.calculateCoreSchemaHash)(js_sdk_1.byteEncoder.encode(schemaId));
        const queriesMetadata = await (0, js_sdk_1.parseQueriesMetadata)(query.type, ldContextJSON, credentialSubject, ldOpts);
        const request = [];
        const merklized = queriesMetadata[0]?.merklizedSchema ? 1 : 0;
        for (let i = 0; i < js_sdk_1.LinkedMultiQueryInputs.queryCount; i++) {
            const queryMeta = queriesMetadata[i];
            const values = queryMeta?.values ?? [];
            const valArrSize = values.length;
            const queryHash = (0, js_sdk_1.calculateQueryHashV3)(values, schemaHash, queryMeta?.slotIndex ?? 0, queryMeta?.operator ?? 0, queryMeta?.claimPathKey.toString() ?? 0, valArrSize, merklized, 0, 0, 0);
            request.push({ queryHash, queryMeta });
        }
        const queryHashCompare = (a, b) => {
            if (a.queryHash < b.queryHash)
                return -1;
            if (a.queryHash > b.queryHash)
                return 1;
            return 0;
        };
        const pubSignalsMeta = this.pubSignals.circuitQueryHash.map((queryHash, index) => ({
            queryHash,
            operatorOutput: this.pubSignals.operatorOutput[index]
        }));
        pubSignalsMeta.sort(queryHashCompare);
        request.sort(queryHashCompare);
        for (let i = 0; i < js_sdk_1.LinkedMultiQueryInputs.queryCount; i++) {
            if (request[i].queryHash != pubSignalsMeta[i].queryHash) {
                throw new Error('query hashes do not match');
            }
            if (request[i].queryMeta?.operator === js_sdk_1.Operators.SD) {
                const disclosedValue = await (0, js_sdk_1.fieldValueFromVerifiablePresentation)(request[i].queryMeta.fieldName, verifiablePresentation, schemaLoader);
                if (disclosedValue != pubSignalsMeta[i].operatorOutput) {
                    throw new Error('disclosed value is not in the proof outputs');
                }
            }
        }
        return this.pubSignals;
    }
    async verifyStates() {
        return Promise.resolve();
    }
}
exports.LinkedMultiQueryVerifier = LinkedMultiQueryVerifier;
//# sourceMappingURL=linkedMultiQuery.js.map