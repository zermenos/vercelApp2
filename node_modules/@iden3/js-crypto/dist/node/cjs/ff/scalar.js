"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.one = exports.zero = exports.toLEBuff = exports.toString = exports.fromRprBE = exports.fromRprLE = exports.toRprBE = exports.toRprLE = exports.lor = exports.land = exports.bxor = exports.bor = exports.band = exports.geq = exports.leq = exports.gt = exports.lt = exports.neq = exports.eq = exports.mod = exports.div = exports.abs = exports.exp = exports.pow = exports.square = exports.mul = exports.neg = exports.sub = exports.add = exports.toArray = exports.toNumber = exports.bits = exports.naf = exports.isOdd = exports.shr = exports.shl = exports.shiftRight = exports.shiftLeft = exports.isZero = exports.isNegative = exports.bitLength = exports.fromArray = exports.e = exports.fromString = void 0;
const hexLen = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4];
const fromString = (s, radix) => {
    if (!radix || radix === 10) {
        return BigInt(s);
    }
    else if (radix === 16) {
        if (s.slice(0, 2) == '0x') {
            return BigInt(s);
        }
        else {
            return BigInt('0x' + s);
        }
    }
    throw new Error('Unsupported radix');
};
exports.fromString = fromString;
exports.e = exports.fromString;
const fromArray = (a, r) => {
    let acc = BigInt(0);
    const radix = BigInt(r);
    for (let i = 0; i < a.length; i++) {
        acc = acc * radix + BigInt(a[i]);
    }
    return acc;
};
exports.fromArray = fromArray;
const bitLength = (a) => {
    const aS = a.toString(16);
    return (aS.length - 1) * 4 + hexLen[parseInt(aS[0], 16)];
};
exports.bitLength = bitLength;
const isNegative = (a) => {
    return BigInt(a) < BigInt(0);
};
exports.isNegative = isNegative;
const isZero = (a) => {
    return a === exports.zero;
};
exports.isZero = isZero;
const shiftLeft = (a, n) => {
    return a << n;
};
exports.shiftLeft = shiftLeft;
const shiftRight = (a, n) => {
    return a >> n;
};
exports.shiftRight = shiftRight;
exports.shl = exports.shiftLeft;
exports.shr = exports.shiftRight;
const isOdd = (a) => {
    return (a & exports.one) == exports.one;
};
exports.isOdd = isOdd;
const naf = (n) => {
    let E = n;
    const res = [];
    while (E) {
        if (E & exports.one) {
            const z = 2 - Number(E % BigInt(4));
            res.push(z);
            E = E - BigInt(z);
        }
        else {
            res.push(0);
        }
        E = E >> exports.one;
    }
    return res;
};
exports.naf = naf;
const bits = (n) => {
    let E = n;
    const res = [];
    while (E) {
        if (E & exports.one) {
            res.push(1);
        }
        else {
            res.push(0);
        }
        E = E >> exports.one;
    }
    return res;
};
exports.bits = bits;
const toNumber = (s) => {
    if (s > BigInt(Number.MAX_SAFE_INTEGER)) {
        throw new Error('Number too big');
    }
    return Number(s);
};
exports.toNumber = toNumber;
const toArray = (s, r) => {
    const res = [];
    let rem = s;
    const radix = r;
    while (rem) {
        res.unshift(Number(rem % radix));
        rem = rem / radix;
    }
    return res;
};
exports.toArray = toArray;
const add = (a, b) => {
    return a + b;
};
exports.add = add;
const sub = (a, b) => {
    return a - b;
};
exports.sub = sub;
const neg = (a) => {
    return -a;
};
exports.neg = neg;
const mul = (a, b) => {
    return a * b;
};
exports.mul = mul;
const square = (a) => {
    return a * a;
};
exports.square = square;
const pow = (a, b) => {
    return a ** b;
};
exports.pow = pow;
const exp = (a, b) => {
    return a ** b;
};
exports.exp = exp;
const abs = (a) => {
    return a >= 0 ? a : -a;
};
exports.abs = abs;
const div = (a, b) => {
    return a / b;
};
exports.div = div;
const mod = (a, b) => {
    return a % b;
};
exports.mod = mod;
const eq = (a, b) => {
    return a === b;
};
exports.eq = eq;
const neq = (a, b) => {
    return a !== b;
};
exports.neq = neq;
const lt = (a, b) => {
    return a < b;
};
exports.lt = lt;
const gt = (a, b) => {
    return a > b;
};
exports.gt = gt;
const leq = (a, b) => {
    return a <= b;
};
exports.leq = leq;
const geq = (a, b) => {
    return a >= b;
};
exports.geq = geq;
const band = (a, b) => {
    return a & b;
};
exports.band = band;
const bor = (a, b) => {
    return a | b;
};
exports.bor = bor;
const bxor = (a, b) => {
    return a ^ b;
};
exports.bxor = bxor;
const land = (a, b) => {
    return a && b;
};
exports.land = land;
const lor = (a, b) => {
    return a || b;
};
exports.lor = lor;
// Returns a buffer with Little Endian Representation
const toRprLE = (buff, o, e, n8) => {
    const s = '0000000' + e.toString(16);
    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8 / 4);
    const l = (((s.length - 7) * 4 - 1) >> 5) + 1; // Number of 32bit words;
    for (let i = 0; i < l; i++)
        v[i] = parseInt(s.substring(s.length - 8 * i - 8, s.length - 8 * i), 16);
    for (let i = l; i < v.length; i++)
        v[i] = 0;
    for (let i = v.length * 4; i < n8; i++)
        buff[i] = (0, exports.toNumber)((0, exports.band)((0, exports.shiftRight)(e, BigInt(i * 8)), BigInt(0xff)));
};
exports.toRprLE = toRprLE;
// Returns a buffer with Big Endian Representation
const toRprBE = (buff, o, e, n8) => {
    const s = '0000000' + e.toString(16);
    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);
    const l = (((s.length - 7) * 4 - 1) >> 5) + 1; // Number of 32bit words;
    for (let i = 0; i < l; i++)
        v.setUint32(n8 - i * 4 - 4, parseInt(s.substring(s.length - 8 * i - 8, s.length - 8 * i), 16), false);
    // todo: check this
    for (let i = 0; i < n8 / 4 - l; i++)
        v.setInt32(0, 0, false);
};
exports.toRprBE = toRprBE;
// Pases a buffer with Little Endian Representation
const fromRprLE = (buff, o, n8) => {
    n8 = n8 || buff.byteLength;
    o = o || 0;
    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8 / 4);
    const a = new Array(n8 / 4);
    v.forEach((ch, i) => (a[a.length - i - 1] = ch.toString(16).padStart(8, '0')));
    return (0, exports.fromString)(a.join(''), 16);
};
exports.fromRprLE = fromRprLE;
// Pases a buffer with Big Endian Representation
const fromRprBE = (buff, o, n8) => {
    n8 = n8 || buff.byteLength;
    o = o || 0;
    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);
    const a = new Array(n8 / 4);
    for (let i = 0; i < n8 / 4; i++) {
        a[i] = v
            .getUint32(i * 4, false)
            .toString(16)
            .padStart(8, '0');
    }
    return (0, exports.fromString)(a.join(''), 16);
};
exports.fromRprBE = fromRprBE;
const toString = (a, radix = 10) => {
    return a.toString(radix);
};
exports.toString = toString;
const toLEBuff = (a) => {
    const buff = new Uint8Array(Math.floor(((0, exports.bitLength)(a) - 1) / 8) + 1);
    (0, exports.toRprLE)(buff, 0, a, buff.byteLength);
    return buff;
};
exports.toLEBuff = toLEBuff;
exports.zero = BigInt(0);
exports.one = BigInt(1);
//# sourceMappingURL=scalar.js.map