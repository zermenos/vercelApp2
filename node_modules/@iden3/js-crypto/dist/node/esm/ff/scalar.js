const hexLen = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4];
export const fromString = (s, radix) => {
    if (!radix || radix === 10) {
        return BigInt(s);
    }
    else if (radix === 16) {
        if (s.slice(0, 2) == '0x') {
            return BigInt(s);
        }
        else {
            return BigInt('0x' + s);
        }
    }
    throw new Error('Unsupported radix');
};
export const e = fromString;
export const fromArray = (a, r) => {
    let acc = BigInt(0);
    const radix = BigInt(r);
    for (let i = 0; i < a.length; i++) {
        acc = acc * radix + BigInt(a[i]);
    }
    return acc;
};
export const bitLength = (a) => {
    const aS = a.toString(16);
    return (aS.length - 1) * 4 + hexLen[parseInt(aS[0], 16)];
};
export const isNegative = (a) => {
    return BigInt(a) < BigInt(0);
};
export const isZero = (a) => {
    return a === zero;
};
export const shiftLeft = (a, n) => {
    return a << n;
};
export const shiftRight = (a, n) => {
    return a >> n;
};
export const shl = shiftLeft;
export const shr = shiftRight;
export const isOdd = (a) => {
    return (a & one) == one;
};
export const naf = (n) => {
    let E = n;
    const res = [];
    while (E) {
        if (E & one) {
            const z = 2 - Number(E % BigInt(4));
            res.push(z);
            E = E - BigInt(z);
        }
        else {
            res.push(0);
        }
        E = E >> one;
    }
    return res;
};
export const bits = (n) => {
    let E = n;
    const res = [];
    while (E) {
        if (E & one) {
            res.push(1);
        }
        else {
            res.push(0);
        }
        E = E >> one;
    }
    return res;
};
export const toNumber = (s) => {
    if (s > BigInt(Number.MAX_SAFE_INTEGER)) {
        throw new Error('Number too big');
    }
    return Number(s);
};
export const toArray = (s, r) => {
    const res = [];
    let rem = s;
    const radix = r;
    while (rem) {
        res.unshift(Number(rem % radix));
        rem = rem / radix;
    }
    return res;
};
export const add = (a, b) => {
    return a + b;
};
export const sub = (a, b) => {
    return a - b;
};
export const neg = (a) => {
    return -a;
};
export const mul = (a, b) => {
    return a * b;
};
export const square = (a) => {
    return a * a;
};
export const pow = (a, b) => {
    return a ** b;
};
export const exp = (a, b) => {
    return a ** b;
};
export const abs = (a) => {
    return a >= 0 ? a : -a;
};
export const div = (a, b) => {
    return a / b;
};
export const mod = (a, b) => {
    return a % b;
};
export const eq = (a, b) => {
    return a === b;
};
export const neq = (a, b) => {
    return a !== b;
};
export const lt = (a, b) => {
    return a < b;
};
export const gt = (a, b) => {
    return a > b;
};
export const leq = (a, b) => {
    return a <= b;
};
export const geq = (a, b) => {
    return a >= b;
};
export const band = (a, b) => {
    return a & b;
};
export const bor = (a, b) => {
    return a | b;
};
export const bxor = (a, b) => {
    return a ^ b;
};
export const land = (a, b) => {
    return a && b;
};
export const lor = (a, b) => {
    return a || b;
};
// Returns a buffer with Little Endian Representation
export const toRprLE = (buff, o, e, n8) => {
    const s = '0000000' + e.toString(16);
    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8 / 4);
    const l = (((s.length - 7) * 4 - 1) >> 5) + 1; // Number of 32bit words;
    for (let i = 0; i < l; i++)
        v[i] = parseInt(s.substring(s.length - 8 * i - 8, s.length - 8 * i), 16);
    for (let i = l; i < v.length; i++)
        v[i] = 0;
    for (let i = v.length * 4; i < n8; i++)
        buff[i] = toNumber(band(shiftRight(e, BigInt(i * 8)), BigInt(0xff)));
};
// Returns a buffer with Big Endian Representation
export const toRprBE = (buff, o, e, n8) => {
    const s = '0000000' + e.toString(16);
    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);
    const l = (((s.length - 7) * 4 - 1) >> 5) + 1; // Number of 32bit words;
    for (let i = 0; i < l; i++)
        v.setUint32(n8 - i * 4 - 4, parseInt(s.substring(s.length - 8 * i - 8, s.length - 8 * i), 16), false);
    // todo: check this
    for (let i = 0; i < n8 / 4 - l; i++)
        v.setInt32(0, 0, false);
};
// Pases a buffer with Little Endian Representation
export const fromRprLE = (buff, o, n8) => {
    n8 = n8 || buff.byteLength;
    o = o || 0;
    const v = new Uint32Array(buff.buffer, buff.byteOffset + o, n8 / 4);
    const a = new Array(n8 / 4);
    v.forEach((ch, i) => (a[a.length - i - 1] = ch.toString(16).padStart(8, '0')));
    return fromString(a.join(''), 16);
};
// Pases a buffer with Big Endian Representation
export const fromRprBE = (buff, o, n8) => {
    n8 = n8 || buff.byteLength;
    o = o || 0;
    const v = new DataView(buff.buffer, buff.byteOffset + o, n8);
    const a = new Array(n8 / 4);
    for (let i = 0; i < n8 / 4; i++) {
        a[i] = v
            .getUint32(i * 4, false)
            .toString(16)
            .padStart(8, '0');
    }
    return fromString(a.join(''), 16);
};
export const toString = (a, radix = 10) => {
    return a.toString(radix);
};
export const toLEBuff = (a) => {
    const buff = new Uint8Array(Math.floor((bitLength(a) - 1) / 8) + 1);
    toRprLE(buff, 0, a, buff.byteLength);
    return buff;
};
export const zero = BigInt(0);
export const one = BigInt(1);
//# sourceMappingURL=scalar.js.map