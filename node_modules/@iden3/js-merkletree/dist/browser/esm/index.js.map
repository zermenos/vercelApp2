{"version":3,"file":"index.js","sources":["../../../src/constants/hash.ts","../../../src/constants/node.ts","../../../src/constants/data.ts","../../../src/constants/proof.ts","../../../src/constants/field.ts","../../../node_modules/tslib/tslib.es6.js","../../../src/lib/utils/crypto.ts","../../../src/lib/utils/bytes.ts","../../../src/lib/utils/merkletree.ts","../../../src/lib/utils/bigint.ts","../../../src/lib/hash/hash.ts","../../../src/lib/db/inMemory.ts","../../../src/lib/utils/node.ts","../../../src/lib/node/node.ts","../../../src/lib/db/localStorage.ts","../../../node_modules/idb-keyval/dist/index.js","../../../src/lib/db/indexedDB.ts","../../../src/lib/entry/elemBytes.ts","../../../src/lib/entry/data.ts","../../../src/lib/entry/entry.ts","../../../src/lib/errors/merkletree.ts","../../../src/lib/errors/db.ts","../../../src/lib/merkletree/circom.ts","../../../src/lib/errors/proof.ts","../../../src/lib/merkletree/proof.ts","../../../src/lib/merkletree/merkletree.ts"],"sourcesContent":["export const HASH_BYTES_LENGTH = 32;\n","// middle node.ts with children\nimport { NodeType } from '../types';\n\nexport const NODE_TYPE_MIDDLE: NodeType = 0;\n// Leaf node.ts with a key and a value\nexport const NODE_TYPE_LEAF: NodeType = 1;\n// empty node.ts\nexport const NODE_TYPE_EMPTY: NodeType = 2;\n\nexport const NODE_VALUE_BYTE_ARR_LENGTH = 65;\n\nexport const EMPTY_NODE_VALUE = new Uint8Array(NODE_VALUE_BYTE_ARR_LENGTH);\n\nexport const EMPTY_NODE_STRING = 'empty';\n","export const ELEM_BYTES_LEN = 32;\nexport const DATA_LEN = 8;\nexport const DATA_LEN_BYTES = DATA_LEN * ELEM_BYTES_LEN;\n","import { ELEM_BYTES_LEN } from './data';\nexport const PROOF_FLAG_LEN = 2;\nexport const NOT_EMPTIES_LEN = ELEM_BYTES_LEN - PROOF_FLAG_LEN;\n","const qString = '21888242871839275222246405745257275088548364400416034343698204186575808495617';\n\nexport const FIELD_SIZE = BigInt(qString);\nexport const MAX_NUM_IN_FIELD = FIELD_SIZE - BigInt('1');\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n","import { FIELD_SIZE } from '../../constants/field';\n\nexport const checkBigIntInField = (bigNum: bigint): boolean => {\n  return bigNum < FIELD_SIZE;\n};\n","import { HASH_BYTES_LENGTH } from '../../constants';\nimport { Bytes } from '../../types/bytes';\nimport { checkBigIntInField } from './crypto';\n\nexport const bytesEqual: (b1: Bytes, b2: Bytes) => boolean = (b1, b2) => {\n  return b1.every((ele, idx) => ele === b2[idx]);\n};\n\n// TODO: might be make this generic over typed arrays?\nexport const swapEndianness = (bytes: Bytes): Bytes => {\n  return bytes.slice().reverse();\n};\n\nexport const bytes2BinaryString = (bytes: Bytes): string => {\n  return '0b' + bytes.reduce((acc, i) => acc + i.toString(2).padStart(8, '0'), '');\n};\n\nexport const testBit = (bitMap: Bytes, n: number): boolean => {\n  return (bitMap[parseInt((n / 8).toString())] & (1 << n % 8)) !== 0;\n};\n\nexport const testBitBigEndian = (bitMap: Bytes, n: number): boolean => {\n  return (bitMap[bitMap.length - parseInt(`${n / 8}`) - 1] & (1 << n % 8)) !== 0;\n};\n\n// SetBitBigEndian sets the bit n in the bitmap to 1, in Big Endian.\nexport const setBitBigEndian = (bitMap: Bytes, n: number): void => {\n  bitMap[bitMap.length - parseInt(`${n / 8}`) - 1] |= 1 << n % 8;\n};\n\nconst hextable = '0123456789abcdef';\nexport const bytes2Hex = (u: Bytes): string => {\n  const arr = new Array(u.length * 2);\n  let j = 0;\n  u.forEach((v) => {\n    arr[j] = hextable[parseInt((v >> 4).toString(10))];\n    arr[j + 1] = hextable[parseInt((v & 15).toString(10))];\n    j += 2;\n  });\n\n  return arr.join('');\n};\n\n// NOTE: `bytes` should be big endian\n// bytes recieved from Hash.value getter are safe to use since their endianness is swapped, for the same reason the private Hash.bytes { stored in little endian } should never be used\nexport const newBigIntFromBytes = (bytes: Bytes): bigint => {\n  if (bytes.length !== HASH_BYTES_LENGTH) {\n    throw `Expected 32 bytes, found ${bytes.length} bytes`;\n  }\n\n  const bigNum = BigInt(bytes2BinaryString(bytes));\n  if (!checkBigIntInField(bigNum)) {\n    throw 'NewBigIntFromHashBytes: Value not inside the Finite Field';\n  }\n\n  return bigNum;\n};\n\nexport const str2Bytes = (str: string): Bytes =>\n  new Uint8Array(str.length * 2).map((_, i) => str.charCodeAt(i));\n","// const siblingBytes = bs.slice(this.notEmpties.length + PROOF_FLAG_LEN);\nimport { HASH_BYTES_LENGTH } from '../../constants';\nimport { Bytes } from '../../types';\nimport { Path, Siblings } from '../../types/merkletree';\nimport { testBit } from './bytes';\n\nexport const getPath = (numLevels: number, k: Bytes): Path => {\n  const path = new Array<boolean>(numLevels);\n\n  for (let idx = 0; idx < numLevels; idx += 1) {\n    path[idx] = testBit(k, idx);\n  }\n  return path;\n};\n\nexport const siblings2Bytes = (siblings: Siblings): Bytes => {\n  const siblingBytesBuff = new ArrayBuffer(HASH_BYTES_LENGTH * siblings.length);\n  const siblingBytes = new Uint8Array(siblingBytesBuff);\n  siblings.forEach((v, i) => {\n    siblingBytes.set(v.value, i * HASH_BYTES_LENGTH);\n  });\n\n  return siblingBytes;\n};\n","import { HASH_BYTES_LENGTH } from '../../constants';\nimport { Bytes } from '../../types';\n\nexport const bigint2Array = (bigNum: bigint, radix?: number): Array<number> => {\n  return bigNum\n    .toString(radix ? radix : 10)\n    .split('')\n    .map((n) => {\n      return parseInt(n);\n    });\n};\n\nexport const bigIntToUINT8Array = (bigNum: bigint): Bytes => {\n  const n256 = BigInt(256);\n  const bytes = new Uint8Array(HASH_BYTES_LENGTH);\n  let i = 0;\n  while (bigNum > BigInt(0)) {\n    bytes[HASH_BYTES_LENGTH - 1 - i] = Number(bigNum % n256);\n    bigNum = bigNum / n256;\n    i += 1;\n  }\n  return bytes;\n};\n","import { HASH_BYTES_LENGTH } from '../../constants';\nimport {\n  bytesEqual,\n  swapEndianness,\n  bytes2Hex,\n  bytes2BinaryString,\n  checkBigIntInField,\n  bigIntToUINT8Array\n} from '../utils';\nimport { Bytes, IHash, Siblings } from '../../types';\nimport { Hex, poseidon } from '@iden3/js-crypto';\n\nexport class Hash implements IHash {\n  // little endian\n  bytes: Bytes;\n\n  constructor(_bytes?: Bytes) {\n    if (_bytes?.length) {\n      if (_bytes.length !== HASH_BYTES_LENGTH) {\n        throw new Error(`Expected ${HASH_BYTES_LENGTH} bytes, found ${_bytes.length} bytes`);\n      }\n      this.bytes = _bytes;\n    } else {\n      this.bytes = new Uint8Array(HASH_BYTES_LENGTH);\n    }\n  }\n\n  // returns a new copy, in little endian\n  get value(): Bytes {\n    return this.bytes;\n  }\n\n  // bytes should be in big-endian\n  set value(bytes: Bytes) {\n    if (bytes.length !== HASH_BYTES_LENGTH) {\n      throw `Expected 32 bytes, found ${bytes.length} bytes`;\n    }\n    this.bytes = swapEndianness(bytes);\n  }\n\n  string(): string {\n    return this.bigInt().toString(10);\n  }\n\n  hex(): string {\n    return bytes2Hex(this.bytes);\n  }\n\n  equals(hash: Hash): boolean {\n    return bytesEqual(this.value, hash.value);\n  }\n\n  bigInt(): bigint {\n    const bytes = swapEndianness(this.value);\n    return BigInt(bytes2BinaryString(bytes));\n  }\n\n  static fromString(s: string): Hash {\n    try {\n      return Hash.fromBigInt(BigInt(s));\n    } catch (e) {\n      const deserializedHash = JSON.parse(s);\n      const bytes = Uint8Array.from(Object.values(deserializedHash.bytes));\n      return new Hash(bytes);\n    }\n  }\n  static fromBigInt(i: bigint): Hash {\n    if (!checkBigIntInField(i)) {\n      throw new Error('NewBigIntFromHashBytes: Value not inside the Finite Field');\n    }\n\n    const bytes = bigIntToUINT8Array(i);\n\n    return new Hash(swapEndianness(bytes));\n  }\n\n  static fromHex(h: string | undefined): Hash {\n    if (!h) {\n      return ZERO_HASH;\n    }\n    return new Hash(Hex.decodeString(h));\n  }\n\n  toJSON() {\n    return this.string();\n  }\n}\n\nexport const ZERO_HASH = new Hash();\n\n/**\n * @deprecated The method should not be used and will be removed in the next major version,\n * please use Hash.fromBigInt instead\n */\nexport const newHashFromBigInt = (bigNum: bigint): Hash => {\n  return Hash.fromBigInt(bigNum);\n};\n\n/**\n * @deprecated The method should not be used and will be removed in the next major version,\n * please use Hash.fromBigInt instead\n */\nexport const newHashFromHex = (h: string): Hash => {\n  return Hash.fromHex(h);\n};\n\n/**\n * @deprecated The method should not be used and will be removed in the next major version,\n * please use Hash.fromBigString instead\n */\nexport const newHashFromString = (decimalString: string): Hash => {\n  return Hash.fromString(decimalString);\n};\n\nexport const hashElems = (e: Array<bigint>): Hash => {\n  const hashBigInt = poseidon.hash(e);\n  return Hash.fromBigInt(hashBigInt);\n};\n\nexport const hashElemsKey = (k: bigint, e: Array<bigint>): Hash => {\n  const hashBigInt = poseidon.hash([...e, k]);\n  return Hash.fromBigInt(hashBigInt);\n};\n\nexport const circomSiblingsFromSiblings = (siblings: Siblings, levels: number): Siblings => {\n  for (let i = siblings.length; i < levels; i += 1) {\n    siblings.push(ZERO_HASH);\n  }\n  return siblings;\n};\n","// in Memory Database implementation\n\nimport { Bytes, Node } from '../../types';\nimport { ITreeStorage } from '../../types/storage';\nimport { Hash, ZERO_HASH } from '../hash/hash';\n\nexport class InMemoryDB implements ITreeStorage {\n  prefix: Bytes;\n  #kvMap: {\n    [k in string]: Node;\n  };\n  #currentRoot: Hash;\n\n  constructor(_prefix: Bytes) {\n    this.prefix = _prefix;\n    this.#kvMap = {};\n    this.#currentRoot = ZERO_HASH;\n  }\n\n  async get(k: Bytes): Promise<Node | undefined> {\n    const kBytes = new Uint8Array([...this.prefix, ...k]);\n    const val = this.#kvMap[kBytes.toString()] ? this.#kvMap[kBytes.toString()] : undefined;\n    return val;\n  }\n\n  async put(k: Bytes, n: Node): Promise<void> {\n    const kBytes = new Uint8Array([...this.prefix, ...k]);\n    this.#kvMap[kBytes.toString()] = n;\n  }\n\n  async getRoot(): Promise<Hash> {\n    return this.#currentRoot;\n  }\n\n  async setRoot(r: Hash): Promise<void> {\n    this.#currentRoot = r;\n  }\n}\n","// LeafKey computes the key of a leaf node given the hIndex and hValue of the\n// entry of the leaf.\nimport { Hash, hashElemsKey } from '../hash/hash';\n\nimport { NODE_VALUE_BYTE_ARR_LENGTH } from '../../constants';\nimport { bigIntToUINT8Array } from './bigint';\nimport { Bytes, NodeType } from '../../types';\n\nexport const leafKey = async (k: Hash, v: Hash): Promise<Hash> => {\n  return hashElemsKey(BigInt(1), [k.bigInt(), v.bigInt()]);\n};\n\nexport const nodeValue = (type: NodeType, a: Hash, b: Hash): Bytes => {\n  const bytes = new Uint8Array(NODE_VALUE_BYTE_ARR_LENGTH);\n  const kBytes = bigIntToUINT8Array(a.bigInt());\n  const vBytes = bigIntToUINT8Array(b.bigInt());\n  bytes[0] = type;\n\n  for (let idx = 1; idx < 33; idx += 1) {\n    bytes[idx] = kBytes[idx - 1];\n  }\n\n  for (let idx = 33; idx <= NODE_VALUE_BYTE_ARR_LENGTH; idx += 1) {\n    bytes[idx] = vBytes[idx - 33];\n  }\n\n  return bytes;\n};\n","import { Bytes, Node, NodeType } from '../../types';\nimport { Hash, ZERO_HASH, hashElems } from '../hash/hash';\n\nimport {\n  EMPTY_NODE_STRING,\n  EMPTY_NODE_VALUE,\n  NODE_TYPE_EMPTY,\n  NODE_TYPE_LEAF,\n  NODE_TYPE_MIDDLE\n} from '../../constants';\nimport { leafKey, nodeValue } from '../utils/node';\n\nexport class NodeLeaf implements Node {\n  type: NodeType;\n  entry: [Hash, Hash];\n  // cache used to avoid recalculating key\n  #key: Hash;\n\n  constructor(k: Hash, v: Hash) {\n    this.type = NODE_TYPE_LEAF;\n    this.entry = [k, v];\n    this.#key = ZERO_HASH;\n  }\n\n  async getKey(): Promise<Hash> {\n    if (this.#key === ZERO_HASH) {\n      return await leafKey(this.entry[0], this.entry[1]);\n    }\n    return this.#key;\n  }\n\n  get value(): Bytes {\n    return nodeValue(this.type, this.entry[0], this.entry[1]);\n  }\n\n  get string(): string {\n    return `Leaf I:${this.entry[0]} D:${this.entry[1]}`;\n  }\n}\n\nexport class NodeMiddle implements Node {\n  type: NodeType;\n  childL: Hash;\n  childR: Hash;\n  #key: Hash;\n\n  constructor(cL: Hash, cR: Hash) {\n    this.type = NODE_TYPE_MIDDLE;\n    this.childL = cL;\n    this.childR = cR;\n    this.#key = ZERO_HASH;\n  }\n\n  async getKey(): Promise<Hash> {\n    if (this.#key === ZERO_HASH) {\n      return hashElems([this.childL.bigInt(), this.childR.bigInt()]);\n    }\n    return this.#key;\n  }\n\n  get value(): Bytes {\n    return nodeValue(this.type, this.childL, this.childR);\n  }\n\n  get string(): string {\n    return `Middle L:${this.childL} R:${this.childR}`;\n  }\n}\n\nexport class NodeEmpty implements Node {\n  type: NodeType;\n  #key: Hash;\n\n  constructor() {\n    this.type = NODE_TYPE_EMPTY;\n    this.#key = ZERO_HASH;\n  }\n\n  async getKey(): Promise<Hash> {\n    return ZERO_HASH;\n  }\n\n  get value(): Bytes {\n    return EMPTY_NODE_VALUE;\n  }\n\n  get string(): string {\n    return EMPTY_NODE_STRING;\n  }\n}\n","/* eslint-disable no-case-declarations */\n\nimport { Bytes, Node } from '../../types';\nimport { ITreeStorage } from '../../types/storage';\nimport { Hash, ZERO_HASH } from '../hash/hash';\nimport { NODE_TYPE_EMPTY, NODE_TYPE_LEAF, NODE_TYPE_MIDDLE } from '../../constants';\nimport { NodeEmpty, NodeLeaf, NodeMiddle } from '../node/node';\nimport { bytes2Hex } from '../utils';\n\nexport class LocalStorageDB implements ITreeStorage {\n  #currentRoot: Hash;\n\n  constructor(private readonly _prefix: Bytes) {\n    const rootStr = localStorage.getItem(bytes2Hex(_prefix));\n    if (rootStr) {\n      const bytes: number[] = JSON.parse(rootStr);\n\n      this.#currentRoot = new Hash(Uint8Array.from(bytes));\n    } else {\n      this.#currentRoot = ZERO_HASH;\n    }\n  }\n\n  async get(k: Bytes): Promise<Node | undefined> {\n    const kBytes = new Uint8Array([...this._prefix, ...k]);\n    const key = bytes2Hex(kBytes);\n    const val = localStorage.getItem(key);\n\n    if (val === null) {\n      return undefined;\n    }\n\n    const obj = JSON.parse(val);\n    switch (obj.type) {\n      case NODE_TYPE_EMPTY:\n        return new NodeEmpty();\n      case NODE_TYPE_MIDDLE:\n        const cL = new Hash(Uint8Array.from(obj.childL));\n        const cR = new Hash(Uint8Array.from(obj.childR));\n\n        return new NodeMiddle(cL, cR);\n      case NODE_TYPE_LEAF:\n        const k = new Hash(Uint8Array.from(obj.entry[0]));\n        const v = new Hash(Uint8Array.from(obj.entry[1]));\n\n        return new NodeLeaf(k, v);\n    }\n\n    throw `error: value found for key ${bytes2Hex(kBytes)} is not of type Node`;\n  }\n\n  async put(k: Bytes, n: Node): Promise<void> {\n    const kBytes = new Uint8Array([...this._prefix, ...k]);\n    const key = bytes2Hex(kBytes);\n    const toSerialize: Record<string, unknown> = {\n      type: n.type\n    };\n    if (n instanceof NodeMiddle) {\n      toSerialize.childL = Array.from(n.childL.bytes);\n      toSerialize.childR = Array.from(n.childR.bytes);\n    } else if (n instanceof NodeLeaf) {\n      toSerialize.entry = [Array.from(n.entry[0].bytes), Array.from(n.entry[1].bytes)];\n    }\n    const val = JSON.stringify(toSerialize);\n    localStorage.setItem(key, val);\n  }\n\n  async getRoot(): Promise<Hash> {\n    return this.#currentRoot;\n  }\n\n  async setRoot(r: Hash): Promise<void> {\n    this.#currentRoot = r;\n    localStorage.setItem(bytes2Hex(this._prefix), JSON.stringify(Array.from(r.bytes)));\n  }\n}\n","function promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n        // @ts-ignore - file size hacks\n        request.oncomplete = request.onsuccess = () => resolve(request.result);\n        // @ts-ignore - file size hacks\n        request.onabort = request.onerror = () => reject(request.error);\n    });\n}\nfunction createStore(dbName, storeName) {\n    const request = indexedDB.open(dbName);\n    request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n    const dbp = promisifyRequest(request);\n    return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));\n}\nlet defaultGetStoreFunc;\nfunction defaultGetStore() {\n    if (!defaultGetStoreFunc) {\n        defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n    }\n    return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction get(key, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => promisifyRequest(store.get(key)));\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction set(key, value, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.put(value, key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic â€“ if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction setMany(entries, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        entries.forEach((entry) => store.put(entry[1], entry[0]));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction getMany(keys, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction update(key, updater, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => \n    // Need to create the promise manually.\n    // If I try to chain promises, the transaction closes in browsers\n    // that use a promise polyfill (IE10/11).\n    new Promise((resolve, reject) => {\n        store.get(key).onsuccess = function () {\n            try {\n                store.put(updater(this.result), key);\n                resolve(promisifyRequest(store.transaction));\n            }\n            catch (err) {\n                reject(err);\n            }\n        };\n    }));\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction del(key, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.delete(key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Delete multiple keys at once.\n *\n * @param keys List of keys to delete.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction delMany(keys, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        keys.forEach((key) => store.delete(key));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction clear(customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.clear();\n        return promisifyRequest(store.transaction);\n    });\n}\nfunction eachCursor(store, callback) {\n    store.openCursor().onsuccess = function () {\n        if (!this.result)\n            return;\n        callback(this.result);\n        this.result.continue();\n    };\n    return promisifyRequest(store.transaction);\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction keys(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAllKeys) {\n            return promisifyRequest(store.getAllKeys());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);\n    });\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction values(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAll) {\n            return promisifyRequest(store.getAll());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.value)).then(() => items);\n    });\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction entries(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        // (although, hopefully we'll get a simpler path some day)\n        if (store.getAll && store.getAllKeys) {\n            return Promise.all([\n                promisifyRequest(store.getAllKeys()),\n                promisifyRequest(store.getAll()),\n            ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));\n        }\n        const items = [];\n        return customStore('readonly', (store) => eachCursor(store, (cursor) => items.push([cursor.key, cursor.value])).then(() => items));\n    });\n}\n\nexport { clear, createStore, del, delMany, entries, get, getMany, keys, promisifyRequest, set, setMany, update, values };\n","import { Bytes, Node } from '../../types';\nimport { ITreeStorage } from '../../types/storage';\nimport { Hash, ZERO_HASH } from '../hash/hash';\nimport { bytes2Hex } from '../utils';\nimport { get, set, UseStore, createStore } from 'idb-keyval';\nimport { NODE_TYPE_EMPTY, NODE_TYPE_LEAF, NODE_TYPE_MIDDLE } from '../../constants';\nimport { NodeEmpty, NodeLeaf, NodeMiddle } from '../node/node';\n\nexport class IndexedDBStorage implements ITreeStorage {\n  public static readonly storageName = 'merkle-tree';\n\n  private readonly _prefixHash: string;\n  private readonly _store: UseStore;\n\n  #currentRoot: Hash;\n\n  constructor(private readonly _prefix: Bytes, databaseName?: string) {\n    this.#currentRoot = ZERO_HASH;\n    this._prefixHash = bytes2Hex(_prefix);\n    this._store = createStore(\n      `${databaseName ?? IndexedDBStorage.storageName}-db`,\n      IndexedDBStorage.storageName\n    );\n  }\n\n  async get(k: Bytes): Promise<Node | undefined> {\n    const kBytes = new Uint8Array([...this._prefix, ...k]);\n    const key = bytes2Hex(kBytes);\n    const obj = await get(key, this._store);\n    if (obj === null || obj === undefined) {\n      return undefined;\n    }\n    if (obj.type === NODE_TYPE_EMPTY) {\n      return new NodeEmpty();\n    }\n    if (obj.type === NODE_TYPE_MIDDLE) {\n      const cL = new Hash(Uint8Array.from(obj.childL.bytes));\n      const cR = new Hash(Uint8Array.from(obj.childR.bytes));\n      return new NodeMiddle(cL, cR);\n    }\n    if (obj.type === NODE_TYPE_LEAF) {\n      const k = new Hash(Uint8Array.from(obj.entry[0].bytes));\n      const v = new Hash(Uint8Array.from(obj.entry[1].bytes));\n\n      return new NodeLeaf(k, v);\n    }\n    throw new Error(`error: value found for key ${key} is not of type Node`);\n  }\n\n  async put(k: Bytes, n: Node): Promise<void> {\n    const kBytes = new Uint8Array([...this._prefix, ...k]);\n    const key = bytes2Hex(kBytes);\n    await set(key, n, this._store);\n  }\n\n  async getRoot(): Promise<Hash> {\n    if (!this.#currentRoot.equals(ZERO_HASH)) {\n      return this.#currentRoot;\n    }\n    const root = await get(this._prefixHash, this._store);\n\n    if (!root) {\n      this.#currentRoot = ZERO_HASH;\n    } else {\n      this.#currentRoot = new Hash(root.bytes);\n    }\n    return this.#currentRoot;\n  }\n\n  async setRoot(r: Hash): Promise<void> {\n    await set(this._prefixHash, r, this._store);\n    this.#currentRoot = r;\n  }\n}\n","import { ELEM_BYTES_LEN } from '../../constants';\nimport { Bytes } from '../../types';\nimport { bytes2Hex, newBigIntFromBytes, swapEndianness } from '../utils';\n\nexport class ElemBytes {\n  // Little Endian\n  #bytes: Bytes;\n\n  constructor() {\n    this.#bytes = new Uint8Array(ELEM_BYTES_LEN);\n  }\n\n  get value(): Bytes {\n    return this.#bytes;\n  }\n\n  set value(b: Bytes) {\n    this.#bytes = b;\n  }\n\n  bigInt(): bigint {\n    return newBigIntFromBytes(swapEndianness(this.#bytes));\n  }\n\n  string(): string {\n    const hexStr = bytes2Hex(this.#bytes.slice(0, 4));\n    return `${hexStr}...`;\n  }\n}\n","import { ElemBytes } from './elemBytes';\nimport { DATA_LEN, DATA_LEN_BYTES, ELEM_BYTES_LEN } from '../../constants';\nimport { bytesEqual } from '../utils';\nimport { Bytes } from '../../types';\n\nexport class Data {\n  #value: Array<ElemBytes>;\n\n  constructor() {\n    this.#value = new Array<ElemBytes>(DATA_LEN);\n  }\n\n  get value(): Array<ElemBytes> {\n    return this.#value;\n  }\n\n  set value(_v: ElemBytes[]) {\n    if (_v.length !== DATA_LEN) {\n      throw `expected bytes length to be ${DATA_LEN}, got ${_v.length}`;\n    }\n    this.#value = _v;\n  }\n\n  bytes(): Bytes {\n    const b = new Uint8Array(DATA_LEN * ELEM_BYTES_LEN);\n\n    for (let idx = 0; idx < DATA_LEN; idx += 1) {\n      this.#value[idx].value.forEach((v, _idx) => {\n        b[idx * ELEM_BYTES_LEN + _idx] = v;\n      });\n    }\n    return b;\n  }\n\n  equal(d2: Data): boolean {\n    return (\n      bytesEqual(this.#value[0].value, d2.value[0].value) &&\n      bytesEqual(this.#value[1].value, d2.value[1].value) &&\n      bytesEqual(this.#value[2].value, d2.value[2].value) &&\n      bytesEqual(this.#value[3].value, d2.value[3].value)\n    );\n  }\n}\n\nexport const newDataFromBytes = (bytes: Bytes): Data => {\n  if (bytes.length !== DATA_LEN_BYTES) {\n    throw `expected bytes length to be ${DATA_LEN_BYTES}, got ${bytes.length}`;\n  }\n  const d = new Data();\n  const arr = new Array<ElemBytes>(DATA_LEN_BYTES);\n\n  for (let i = 0; i < DATA_LEN; i += 1) {\n    const tmp = new ElemBytes();\n    tmp.value = bytes.slice(i * ELEM_BYTES_LEN, (i + 1) * DATA_LEN_BYTES);\n    arr[i] = tmp;\n  }\n\n  d.value = arr;\n  return d;\n};\n","import { Data } from '../entry/data';\nimport { Hash, ZERO_HASH, hashElems } from '../hash/hash';\nimport { checkBigIntInField } from '../utils';\n\nimport { ElemBytes } from './elemBytes';\n\nexport class Entry {\n  #data: Data;\n  #hIndex: Hash;\n  #hValue: Hash;\n\n  constructor(_data?: Data) {\n    this.#data = _data ? _data : new Data();\n    this.#hIndex = ZERO_HASH;\n    this.#hValue = ZERO_HASH;\n  }\n\n  get data(): Data {\n    return this.#data;\n  }\n\n  get index(): Array<ElemBytes> {\n    return this.#data.value.slice(0, 4);\n  }\n\n  get value(): Array<ElemBytes> {\n    return this.#data.value.slice(4, 8);\n  }\n\n  async hIndex(): Promise<Hash> {\n    if (this.#hIndex === ZERO_HASH) {\n      return hashElems(elemBytesToBigInts(this.index));\n    }\n    return this.#hIndex;\n  }\n\n  async hValue(): Promise<Hash> {\n    if (this.#hValue === ZERO_HASH) {\n      return hashElems(elemBytesToBigInts(this.value));\n    }\n    return this.#hValue;\n  }\n\n  hiHv(): Promise<{ hi: Hash; hv: Hash }> {\n    return (async () => {\n      const hi = await this.hIndex();\n      const hv = await this.hValue();\n      return { hi, hv };\n    })();\n  }\n\n  bytes(): Array<ElemBytes> {\n    return this.#data.value;\n  }\n\n  equal(e2: Entry): boolean {\n    return this.#data.equal(e2.data);\n  }\n\n  clone(): Entry {\n    return new Entry(this.#data);\n  }\n}\n\nexport const elemBytesToBigInts = (es: Array<ElemBytes>): Array<bigint> => {\n  const bigInts = es.map((e) => {\n    return e.bigInt();\n  });\n\n  return bigInts;\n};\n\nexport const checkEntryInField = (e: Entry): boolean => {\n  const bigInts = elemBytesToBigInts(e.data.value);\n  let flag = true;\n\n  bigInts.forEach((b) => {\n    if (!checkBigIntInField(b)) {\n      flag = false;\n    }\n  });\n\n  return flag;\n};\n","export const ErrNodeKeyAlreadyExists = 'key already exists';\n// ErrKeyNotFound is used when a key is not found in the MerkleTree.\nexport const ErrKeyNotFound = 'Key not found in the MerkleTree';\n// ErrNodeBytesBadSize is used when the data of a node has an incorrect\n// size and can't be parsed.\nexport const ErrNodeBytesBadSize = 'node data has incorrect size in the DB';\n// ErrReachedMaxLevel is used when a traversal of the MT reaches the\n// maximum level.\nexport const ErrReachedMaxLevel = 'reached maximum level of the merkle tree';\n// ErrInvalidNodeFound is used when an invalid node is found and can't\n// be parsed.\nexport const ErrInvalidNodeFound = 'found an invalid node in the DB';\n// ErrInvalidProofBytes is used when a serialized proof is invalid.\nexport const ErrInvalidProofBytes = 'the serialized proof is invalid';\n// ErrInvalidDBValue is used when a value in the key value DB is\n// invalid (for example, it doen't contain a byte header and a []byte\n// body of at least len=1.\nexport const ErrInvalidDBValue = 'the value in the DB is invalid';\n// ErrEntryIndexAlreadyExists is used when the entry index already\n// exists in the tree.\nexport const ErrEntryIndexAlreadyExists = 'the entry index already exists in the tree';\n// ErrNotWritable is used when the MerkleTree is not writable and a\n// write function is called\nexport const ErrNotWritable = 'Merkle Tree not writable';\n","export const ErrNotFound = 'key not found';\n","import { ICircomProcessorProof, ICircomVerifierProof, Siblings } from '../../types/merkletree';\nimport { Hash, ZERO_HASH } from '../hash/hash';\n\nexport class CircomVerifierProof implements ICircomVerifierProof {\n  root: Hash;\n  siblings: Siblings;\n  oldKey: Hash;\n  oldValue: Hash;\n  isOld0: boolean;\n  key: Hash;\n  value: Hash;\n  // 0: inclusion, 1: non inclusion\n  fnc: number;\n\n  constructor(\n    _root: Hash = ZERO_HASH,\n    _siblings: Siblings = [],\n    _oldKey: Hash = ZERO_HASH,\n    _oldValue: Hash = ZERO_HASH,\n    _isOld0 = false,\n    _key: Hash = ZERO_HASH,\n    _value: Hash = ZERO_HASH,\n    _fnc = 0\n  ) {\n    this.root = _root;\n    this.siblings = _siblings;\n    this.oldKey = _oldKey;\n    this.oldValue = _oldValue;\n    this.isOld0 = _isOld0;\n    this.key = _key;\n    this.value = _value;\n    this.fnc = _fnc;\n  }\n}\n\nexport class CircomProcessorProof implements ICircomProcessorProof {\n  oldRoot: Hash;\n  newRoot: Hash;\n  siblings: Siblings;\n  oldKey: Hash;\n  oldValue: Hash;\n  newKey: Hash;\n  newValue: Hash;\n  isOld0: boolean;\n  // 0: NOP, 1: Update, 2: Insert, 3: Delete\n  fnc: number;\n\n  constructor(\n    _oldRoot: Hash = ZERO_HASH,\n    _newRoot: Hash = ZERO_HASH,\n    _siblings: Siblings = [],\n    _oldKey: Hash = ZERO_HASH,\n    _oldValue: Hash = ZERO_HASH,\n    _newKey: Hash = ZERO_HASH,\n    _newValue: Hash = ZERO_HASH,\n    _isOld0 = false,\n    _fnc = 0\n  ) {\n    this.oldRoot = _oldRoot;\n    this.newRoot = _newRoot;\n    this.siblings = _siblings;\n    this.oldKey = _oldKey;\n    this.oldValue = _oldValue;\n    this.newKey = _newKey;\n    this.newValue = _newValue;\n    this.isOld0 = _isOld0;\n    this.fnc = _fnc;\n  }\n}\n","export const ErrNodeAuxNonExistAgainstHIndex =\n  'non-existence proof being checked against hIndex equal to nodeAux';\n","import { NodeAux, Siblings } from '../../types/merkletree';\nimport { ELEM_BYTES_LEN, NOT_EMPTIES_LEN, PROOF_FLAG_LEN } from '../../constants';\nimport { bytesEqual, getPath, setBitBigEndian, siblings2Bytes, testBitBigEndian } from '../utils';\nimport { Hash, ZERO_HASH } from '../hash/hash';\nimport { NodeMiddle } from '../node/node';\nimport { leafKey } from '../utils/node';\nimport { ErrNodeAuxNonExistAgainstHIndex } from '../errors/proof';\nimport { Bytes } from '../../types';\n\nexport interface ProofJSON {\n  existence: boolean;\n  siblings: string[];\n  node_aux?: NodeAuxJSON; // this is a right representation of auxiliary node field according to the specification, nodeAux will be deprecated.\n  /**\n   * @deprecated old version is deprecated, do not use it.\n   */\n  nodeAux?: NodeAuxJSON; // old version of representation of auxiliary node.\n}\n\nexport interface NodeAuxJSON {\n  key: string;\n  value: string;\n}\n\nexport class Proof {\n  existence: boolean;\n  private depth: number;\n  // notempties is a bitmap of non-empty siblings found in siblings\n  private notEmpties: Bytes;\n  private siblings: Siblings;\n  nodeAux: NodeAux | undefined;\n\n  constructor(obj?: { siblings: Siblings; nodeAux: NodeAux | undefined; existence: boolean }) {\n    this.existence = obj?.existence ?? false;\n    this.depth = 0;\n    this.nodeAux = obj?.nodeAux;\n\n    const { siblings, notEmpties } = this.reduceSiblings(obj?.siblings);\n    this.siblings = siblings;\n    this.notEmpties = notEmpties;\n  }\n\n  bytes(): Bytes {\n    let bsLen = PROOF_FLAG_LEN + this.notEmpties.length + ELEM_BYTES_LEN * this.siblings.length;\n\n    if (typeof this.nodeAux !== 'undefined') {\n      bsLen += 2 * ELEM_BYTES_LEN;\n    }\n\n    const arrBuff = new ArrayBuffer(bsLen);\n    const bs = new Uint8Array(arrBuff);\n\n    if (!this.existence) {\n      bs[0] |= 1;\n    }\n    bs[1] = this.depth;\n    bs.set(this.notEmpties, PROOF_FLAG_LEN);\n    const siblingBytes = siblings2Bytes(this.siblings);\n    bs.set(siblingBytes, this.notEmpties.length + PROOF_FLAG_LEN);\n\n    if (typeof this.nodeAux !== 'undefined') {\n      bs[0] |= 2;\n      bs.set(this.nodeAux.key.value, bs.length - 2 * ELEM_BYTES_LEN);\n      bs.set(this.nodeAux.value.value, bs.length - 1 * ELEM_BYTES_LEN);\n    }\n    return bs;\n  }\n\n  toJSON() {\n    return {\n      existence: this.existence,\n      siblings: this.allSiblings().map((s) => s.toJSON()),\n      node_aux: this.nodeAux\n        ? {\n            key: this.nodeAux.key.toJSON(),\n            value: this.nodeAux.value.toJSON()\n          }\n        : undefined\n    };\n  }\n\n  private reduceSiblings(siblings?: Siblings): { notEmpties: Uint8Array; siblings: Siblings } {\n    const reducedSiblings: Siblings = [];\n    const notEmpties = new Uint8Array(NOT_EMPTIES_LEN);\n\n    if (!siblings) {\n      return { siblings: reducedSiblings, notEmpties };\n    }\n    for (let i = 0; i < siblings.length; i++) {\n      const sibling = siblings[i];\n      if (JSON.stringify(siblings[i]) !== JSON.stringify(ZERO_HASH)) {\n        setBitBigEndian(notEmpties, i);\n        reducedSiblings.push(sibling);\n        this.depth = i + 1;\n      }\n    }\n    return { notEmpties, siblings: reducedSiblings };\n  }\n\n  public static fromJSON(obj: ProofJSON): Proof {\n    let nodeAux: NodeAux | undefined = undefined;\n    const nodeAuxJson: NodeAuxJSON | undefined = obj.node_aux ?? obj.nodeAux; // we keep backward compatibility and support both representations\n    if (nodeAuxJson) {\n      nodeAux = {\n        key: Hash.fromString(nodeAuxJson.key),\n        value: Hash.fromString(nodeAuxJson.value)\n      };\n    }\n    const existence = obj.existence ?? false;\n\n    const siblings: Siblings = obj.siblings.map((s) => Hash.fromString(s));\n\n    return new Proof({ existence, nodeAux, siblings });\n  }\n\n  allSiblings(): Siblings {\n    return Proof.buildAllSiblings(this.depth, this.notEmpties, this.siblings);\n  }\n\n  public static buildAllSiblings(\n    depth: number,\n    notEmpties: Uint8Array,\n    siblings: Hash[]\n  ): Siblings {\n    let sibIdx = 0;\n    const allSiblings: Siblings = [];\n\n    for (let i = 0; i < depth; i += 1) {\n      if (testBitBigEndian(notEmpties, i)) {\n        allSiblings.push(siblings[sibIdx]);\n        sibIdx += 1;\n      } else {\n        allSiblings.push(ZERO_HASH);\n      }\n    }\n    return allSiblings;\n  }\n}\n\n/**\n * @deprecated The method should not be used and will be removed in the next major version,\n * please use proof.allSiblings instead\n */\nexport const siblignsFroomProof = (proof: Proof): Siblings => {\n  return proof.allSiblings();\n};\n\nexport const verifyProof = async (\n  rootKey: Hash,\n  proof: Proof,\n  k: bigint,\n  v: bigint\n): Promise<boolean> => {\n  try {\n    const rFromProof = await rootFromProof(proof, k, v);\n    return bytesEqual(rootKey.value, rFromProof.value);\n  } catch (err) {\n    if (err === ErrNodeAuxNonExistAgainstHIndex) {\n      return false;\n    }\n    throw err;\n  }\n};\n\nexport const rootFromProof = async (proof: Proof, k: bigint, v: bigint): Promise<Hash> => {\n  const kHash = Hash.fromBigInt(k);\n  const vHash = Hash.fromBigInt(v);\n  let midKey: Hash;\n\n  if (proof.existence) {\n    midKey = await leafKey(kHash, vHash);\n  } else {\n    if (typeof proof.nodeAux === 'undefined') {\n      midKey = ZERO_HASH;\n    } else {\n      const nodeAux = proof.nodeAux as unknown as NodeAux;\n      if (bytesEqual(kHash.value, nodeAux.key.value)) {\n        throw ErrNodeAuxNonExistAgainstHIndex;\n      }\n      midKey = await leafKey(nodeAux.key, nodeAux.value);\n    }\n  }\n\n  const siblings = proof.allSiblings();\n\n  const path = getPath(siblings.length, kHash.value);\n\n  for (let i = siblings.length - 1; i >= 0; i -= 1) {\n    if (path[i]) {\n      midKey = await new NodeMiddle(siblings[i], midKey).getKey();\n    } else {\n      midKey = await new NodeMiddle(midKey, siblings[i]).getKey();\n    }\n  }\n\n  return midKey;\n};\n","import { ITreeStorage } from '../../types/storage';\nimport { Hash, ZERO_HASH, circomSiblingsFromSiblings } from '../hash/hash';\n\nimport { Node } from '../../types';\nimport { NODE_TYPE_EMPTY, NODE_TYPE_LEAF, NODE_TYPE_MIDDLE } from '../../constants';\nimport { NodeEmpty, NodeLeaf, NodeMiddle } from '../node/node';\nimport { bytesEqual, getPath } from '../utils';\nimport { NodeAux, Siblings } from '../../types/merkletree';\nimport { checkBigIntInField } from '../utils/crypto';\nimport { CircomProcessorProof, CircomVerifierProof } from './circom';\nimport {\n  ErrEntryIndexAlreadyExists,\n  ErrInvalidNodeFound,\n  ErrKeyNotFound,\n  ErrNotFound,\n  ErrNotWritable,\n  ErrReachedMaxLevel\n} from '../errors';\nimport { Proof } from './proof';\nimport { Entry, checkEntryInField } from '../entry';\n\nexport class Merkletree {\n  #db: ITreeStorage;\n  #root!: Hash;\n  #writable: boolean;\n  #maxLevel: number;\n\n  constructor(_db: ITreeStorage, _writable: boolean, _maxLevels: number) {\n    this.#db = _db;\n    this.#writable = _writable;\n    this.#maxLevel = _maxLevels;\n  }\n\n  async root(): Promise<Hash> {\n    if (!this.#root) {\n      this.#root = await this.#db.getRoot();\n    }\n    return this.#root;\n  }\n\n  get maxLevels(): number {\n    return this.#maxLevel;\n  }\n\n  async add(k: bigint, v: bigint): Promise<void> {\n    if (!this.#writable) {\n      throw ErrNotWritable;\n    }\n\n    this.#root = await this.root();\n    const kHash = Hash.fromBigInt(k);\n    const vHash = Hash.fromBigInt(v);\n\n    const newNodeLeaf = new NodeLeaf(kHash, vHash);\n    const path = getPath(this.maxLevels, kHash.value);\n\n    const newRootKey = await this.addLeaf(newNodeLeaf, this.#root, 0, path);\n    this.#root = newRootKey;\n    await this.#db.setRoot(this.#root);\n  }\n\n  async updateNode(n: Node): Promise<Hash> {\n    if (!this.#writable) {\n      throw ErrNotWritable;\n    }\n\n    if (n.type === NODE_TYPE_EMPTY) {\n      return await n.getKey();\n    }\n\n    const k = await n.getKey();\n\n    await this.#db.put(k.value, n);\n    return k;\n  }\n\n  async addNode(n: Node): Promise<Hash> {\n    if (!this.#writable) {\n      throw ErrNotWritable;\n    }\n    if (n.type === NODE_TYPE_EMPTY) {\n      return await n.getKey();\n    }\n\n    const k = await n.getKey();\n    // if (typeof this.#db.get(k.value) !== 'undefined') {\n    //   throw ErrNodeKeyAlreadyExists;\n    // }\n\n    await this.#db.put(k.value, n);\n    return k;\n  }\n\n  async addEntry(e: Entry): Promise<void> {\n    if (!this.#writable) {\n      throw ErrNotWritable;\n    }\n\n    if (!checkEntryInField(e)) {\n      throw 'elements not inside the finite field over r';\n    }\n    this.#root = await this.#db.getRoot();\n    const hIndex = await e.hIndex();\n    const hValue = await e.hValue();\n\n    const newNodeLeaf = new NodeLeaf(hIndex, hValue);\n    const path = getPath(this.maxLevels, hIndex.value);\n\n    const newRootKey = await this.addLeaf(newNodeLeaf, this.#root, 0, path);\n    this.#root = newRootKey;\n    await this.#db.setRoot(this.#root);\n  }\n\n  async pushLeaf(\n    newLeaf: Node,\n    oldLeaf: Node,\n    lvl: number,\n    pathNewLeaf: Array<boolean>,\n    pathOldLeaf: Array<boolean>\n  ): Promise<Hash> {\n    if (lvl > this.#maxLevel - 2) {\n      throw new Error(ErrReachedMaxLevel);\n    }\n\n    let newNodeMiddle: NodeMiddle;\n\n    if (pathNewLeaf[lvl] === pathOldLeaf[lvl]) {\n      const nextKey = await this.pushLeaf(newLeaf, oldLeaf, lvl + 1, pathNewLeaf, pathOldLeaf);\n      if (pathNewLeaf[lvl]) {\n        newNodeMiddle = new NodeMiddle(new Hash(), nextKey);\n      } else {\n        newNodeMiddle = new NodeMiddle(nextKey, new Hash());\n      }\n\n      return await this.addNode(newNodeMiddle);\n    }\n\n    const oldLeafKey = await oldLeaf.getKey();\n    const newLeafKey = await newLeaf.getKey();\n\n    if (pathNewLeaf[lvl]) {\n      newNodeMiddle = new NodeMiddle(oldLeafKey, newLeafKey);\n    } else {\n      newNodeMiddle = new NodeMiddle(newLeafKey, oldLeafKey);\n    }\n\n    await this.addNode(newLeaf);\n    return await this.addNode(newNodeMiddle);\n  }\n\n  async addLeaf(newLeaf: NodeLeaf, key: Hash, lvl: number, path: Array<boolean>): Promise<Hash> {\n    if (lvl > this.#maxLevel - 1) {\n      throw new Error(ErrReachedMaxLevel);\n    }\n\n    const n = await this.getNode(key);\n    if (typeof n === 'undefined') {\n      throw ErrNotFound;\n    }\n\n    switch (n.type) {\n      case NODE_TYPE_EMPTY:\n        return this.addNode(newLeaf);\n      case NODE_TYPE_LEAF: {\n        const nKey = (n as NodeLeaf).entry[0];\n        const newLeafKey = newLeaf.entry[0];\n\n        if (bytesEqual(nKey.value, newLeafKey.value)) {\n          throw ErrEntryIndexAlreadyExists;\n        }\n\n        const pathOldLeaf = getPath(this.maxLevels, nKey.value);\n        return this.pushLeaf(newLeaf, n, lvl, path, pathOldLeaf);\n      }\n      case NODE_TYPE_MIDDLE: {\n        n as NodeMiddle;\n        let newNodeMiddle: NodeMiddle;\n\n        if (path[lvl]) {\n          const nextKey = await this.addLeaf(newLeaf, (n as NodeMiddle).childR, lvl + 1, path);\n          newNodeMiddle = new NodeMiddle((n as NodeMiddle).childL, nextKey);\n        } else {\n          const nextKey = await this.addLeaf(newLeaf, (n as NodeMiddle).childL, lvl + 1, path);\n          newNodeMiddle = new NodeMiddle(nextKey, (n as NodeMiddle).childR);\n        }\n\n        return this.addNode(newNodeMiddle);\n      }\n      default: {\n        throw ErrInvalidNodeFound;\n      }\n    }\n  }\n\n  async get(k: bigint): Promise<{ key: bigint; value: bigint; siblings: Siblings }> {\n    const kHash = Hash.fromBigInt(k);\n    const path = getPath(this.maxLevels, kHash.value);\n\n    let nextKey = await this.root();\n    const siblings: Siblings = [];\n\n    for (let i = 0; i < this.maxLevels; i++) {\n      const n = await this.getNode(nextKey);\n      if (typeof n === 'undefined') {\n        throw ErrKeyNotFound;\n      }\n\n      switch (n.type) {\n        case NODE_TYPE_EMPTY:\n          return {\n            key: BigInt('0'),\n            value: BigInt('0'),\n            siblings\n          };\n        case NODE_TYPE_LEAF:\n          // if (bytesEqual(kHash.value, (n as NodeLeaf).entry[0].value)) {\n          //   return {\n          //     key: (n as NodeLeaf).entry[0].BigInt(),\n          //     value: (n as NodeLeaf).entry[1].BigInt(),\n          //     siblings,\n          //   };\n          // }\n          return {\n            key: (n as NodeLeaf).entry[0].bigInt(),\n            value: (n as NodeLeaf).entry[1].bigInt(),\n            siblings\n          };\n        case NODE_TYPE_MIDDLE:\n          if (path[i]) {\n            nextKey = (n as NodeMiddle).childR;\n            siblings.push((n as NodeMiddle).childL);\n          } else {\n            nextKey = (n as NodeMiddle).childL;\n            siblings.push((n as NodeMiddle).childR);\n          }\n          break;\n        default:\n          throw ErrInvalidNodeFound;\n      }\n    }\n\n    throw new Error(ErrReachedMaxLevel);\n  }\n\n  async update(k: bigint, v: bigint): Promise<CircomProcessorProof> {\n    if (!this.#writable) {\n      throw ErrNotWritable;\n    }\n\n    if (!checkBigIntInField(k)) {\n      throw 'key not inside the finite field';\n    }\n    if (!checkBigIntInField(v)) {\n      throw 'key not inside the finite field';\n    }\n\n    const kHash = Hash.fromBigInt(k);\n    const vHash = Hash.fromBigInt(v);\n\n    const path = getPath(this.maxLevels, kHash.value);\n\n    const cp = new CircomProcessorProof();\n\n    cp.fnc = 1;\n    cp.oldRoot = await this.root();\n    cp.oldKey = kHash;\n    cp.newKey = kHash;\n    cp.newValue = vHash;\n\n    let nextKey = await this.root();\n    const siblings: Siblings = [];\n\n    for (let i = 0; i < this.maxLevels; i += 1) {\n      const n = await this.getNode(nextKey);\n      if (typeof n === 'undefined') {\n        throw ErrNotFound;\n      }\n\n      switch (n.type) {\n        case NODE_TYPE_EMPTY:\n          throw ErrKeyNotFound;\n        case NODE_TYPE_LEAF:\n          if (bytesEqual(kHash.value, (n as NodeLeaf).entry[0].value)) {\n            cp.oldValue = (n as NodeLeaf).entry[1];\n            cp.siblings = circomSiblingsFromSiblings([...siblings], this.maxLevels);\n            const newNodeLeaf = new NodeLeaf(kHash, vHash);\n            await this.updateNode(newNodeLeaf);\n\n            const newRootKey = await this.recalculatePathUntilRoot(path, newNodeLeaf, siblings);\n\n            this.#root = newRootKey;\n            await this.#db.setRoot(newRootKey);\n            cp.newRoot = newRootKey;\n            return cp;\n          }\n          break;\n        case NODE_TYPE_MIDDLE:\n          if (path[i]) {\n            nextKey = (n as NodeMiddle).childR;\n            siblings.push((n as NodeMiddle).childL);\n          } else {\n            nextKey = (n as NodeMiddle).childL;\n            siblings.push((n as NodeMiddle).childR);\n          }\n          break;\n        default:\n          throw ErrInvalidNodeFound;\n      }\n    }\n\n    throw ErrKeyNotFound;\n  }\n\n  async getNode(k: Hash): Promise<Node | undefined> {\n    if (bytesEqual(k.value, ZERO_HASH.value)) {\n      return new NodeEmpty();\n    }\n    return await this.#db.get(k.value);\n  }\n\n  async recalculatePathUntilRoot(\n    path: Array<boolean>,\n    node: Node,\n    siblings: Siblings\n  ): Promise<Hash> {\n    for (let i = siblings.length - 1; i >= 0; i -= 1) {\n      const nodeKey = await node.getKey();\n      if (path[i]) {\n        node = new NodeMiddle(siblings[i], nodeKey);\n      } else {\n        node = new NodeMiddle(nodeKey, siblings[i]);\n      }\n      await this.addNode(node);\n    }\n\n    const nodeKey = await node.getKey();\n    return nodeKey;\n  }\n\n  // Delete removes the specified Key from the MerkleTree and updates the path\n  // from the deleted key to the Root with the new values.  This method removes\n  // the key from the MerkleTree, but does not remove the old nodes from the\n  // key-value database; this means that if the tree is accessed by an old Root\n  // where the key was not deleted yet, the key will still exist. If is desired\n  // to remove the key-values from the database that are not under the current\n  // Root, an option could be to dump all the leaves (using mt.DumpLeafs) and\n  // import them in a new MerkleTree in a new database (using\n  // mt.ImportDumpedLeafs), but this will loose all the Root history of the\n  // MerkleTree\n  async delete(k: bigint): Promise<void> {\n    if (!this.#writable) {\n      throw ErrNotWritable;\n    }\n\n    const kHash = Hash.fromBigInt(k);\n    const path = getPath(this.maxLevels, kHash.value);\n\n    let nextKey = this.#root;\n    const siblings: Siblings = [];\n\n    for (let i = 0; i < this.#maxLevel; i += 1) {\n      const n = await this.getNode(nextKey);\n      if (typeof n === 'undefined') {\n        throw ErrNotFound;\n      }\n      switch (n.type) {\n        case NODE_TYPE_EMPTY:\n          throw ErrKeyNotFound;\n        case NODE_TYPE_LEAF:\n          if (bytesEqual(kHash.bytes, (n as NodeLeaf).entry[0].value)) {\n            await this.rmAndUpload(path, kHash, siblings);\n            return;\n          }\n          throw ErrKeyNotFound;\n        case NODE_TYPE_MIDDLE:\n          if (path[i]) {\n            nextKey = (n as NodeMiddle).childR;\n            siblings.push((n as NodeMiddle).childL);\n          } else {\n            nextKey = (n as NodeMiddle).childL;\n            siblings.push((n as NodeMiddle).childR);\n          }\n          break;\n        default:\n          throw ErrInvalidNodeFound;\n      }\n    }\n\n    throw ErrKeyNotFound;\n  }\n\n  async rmAndUpload(path: Array<boolean>, kHash: Hash, siblings: Siblings): Promise<void> {\n    if (siblings.length === 0) {\n      this.#root = ZERO_HASH;\n      await this.#db.setRoot(this.#root);\n      return;\n    }\n\n    const toUpload = siblings[siblings.length - 1];\n    if (siblings.length < 2) {\n      this.#root = siblings[0];\n      await this.#db.setRoot(this.#root);\n    }\n\n    const nearestSibling = await this.#db.get(toUpload.bytes);\n    if (nearestSibling?.type === NODE_TYPE_MIDDLE) {\n      let newNode: Node;\n      if (path[siblings.length - 1]) {\n        newNode = new NodeMiddle(toUpload, ZERO_HASH);\n      } else {\n        newNode = new NodeMiddle(ZERO_HASH, toUpload);\n      }\n      await this.addNode(newNode);\n      const newRootKey = await this.recalculatePathUntilRoot(\n        path,\n        newNode,\n        siblings.slice(0, siblings.length - 1)\n      );\n      this.#root = newRootKey;\n      await this.#db.setRoot(this.#root);\n      return;\n    }\n\n    for (let i = siblings.length - 2; i >= 0; i -= 1) {\n      if (!bytesEqual(siblings[i].value, ZERO_HASH.value)) {\n        let newNode: Node;\n        if (path[i]) {\n          newNode = new NodeMiddle(siblings[i], toUpload);\n        } else {\n          newNode = new NodeMiddle(toUpload, siblings[i]);\n        }\n        await this.addNode(newNode);\n\n        const newRootKey = await this.recalculatePathUntilRoot(path, newNode, siblings.slice(0, i));\n\n        this.#root = newRootKey;\n        await this.#db.setRoot(this.#root);\n        break;\n      }\n\n      if (i === 0) {\n        this.#root = toUpload;\n        await this.#db.setRoot(this.#root);\n        break;\n      }\n    }\n  }\n\n  async recWalk(key: Hash, f: (n: Node) => Promise<void>): Promise<void> {\n    const n = await this.getNode(key);\n    if (typeof n === 'undefined') {\n      throw ErrNotFound;\n    }\n\n    switch (n.type) {\n      case NODE_TYPE_EMPTY:\n        await f(n);\n        break;\n      case NODE_TYPE_LEAF:\n        await f(n);\n        break;\n      case NODE_TYPE_MIDDLE:\n        await f(n);\n        await this.recWalk((n as NodeMiddle).childL, f);\n        await this.recWalk((n as NodeMiddle).childR, f);\n        break;\n      default:\n        throw ErrInvalidNodeFound;\n    }\n  }\n\n  async walk(rootKey: Hash, f: (n: Node) => Promise<void>): Promise<void> {\n    if (bytesEqual(rootKey.value, ZERO_HASH.value)) {\n      rootKey = await this.root();\n    }\n    await this.recWalk(rootKey, f);\n  }\n\n  async generateCircomVerifierProof(k: bigint, rootKey: Hash): Promise<CircomVerifierProof> {\n    const cp = await this.generateSCVerifierProof(k, rootKey);\n    cp.siblings = circomSiblingsFromSiblings(cp.siblings, this.maxLevels);\n    return cp;\n  }\n\n  async generateSCVerifierProof(k: bigint, rootKey: Hash): Promise<CircomVerifierProof> {\n    if (bytesEqual(rootKey.value, ZERO_HASH.value)) {\n      rootKey = await this.root();\n    }\n\n    const { proof, value } = await this.generateProof(k, rootKey);\n    const cp = new CircomVerifierProof();\n    cp.root = rootKey;\n    cp.siblings = proof.allSiblings();\n    if (typeof proof.nodeAux !== 'undefined') {\n      cp.oldKey = proof.nodeAux.key;\n      cp.oldValue = proof.nodeAux.value;\n    } else {\n      cp.oldKey = ZERO_HASH;\n      cp.oldValue = ZERO_HASH;\n    }\n    cp.key = Hash.fromBigInt(k);\n    cp.value = Hash.fromBigInt(value);\n\n    if (proof.existence) {\n      cp.fnc = 0;\n    } else {\n      cp.fnc = 1;\n    }\n\n    return cp;\n  }\n\n  async generateProof(k: bigint, rootKey?: Hash): Promise<{ proof: Proof; value: bigint }> {\n    let siblingKey: Hash;\n\n    const kHash = Hash.fromBigInt(k);\n    const path = getPath(this.maxLevels, kHash.value);\n    if (!rootKey) {\n      rootKey = await this.root();\n    }\n    let nextKey = rootKey;\n\n    let depth = 0;\n    let existence = false;\n    const siblings: Siblings = [];\n    let nodeAux: NodeAux | undefined;\n\n    for (depth = 0; depth < this.maxLevels; depth += 1) {\n      const n = await this.getNode(nextKey);\n      if (typeof n === 'undefined') {\n        throw ErrNotFound;\n      }\n      switch (n.type) {\n        case NODE_TYPE_EMPTY:\n          return {\n            proof: new Proof({\n              existence,\n              nodeAux,\n              siblings\n            }),\n            value: BigInt('0')\n          };\n        case NODE_TYPE_LEAF:\n          if (bytesEqual(kHash.value, (n as NodeLeaf).entry[0].value)) {\n            existence = true;\n\n            return {\n              proof: new Proof({\n                existence,\n                nodeAux,\n                siblings\n              }),\n              value: (n as NodeLeaf).entry[1].bigInt()\n            };\n          }\n          nodeAux = {\n            key: (n as NodeLeaf).entry[0],\n            value: (n as NodeLeaf).entry[1]\n          };\n          return {\n            proof: new Proof({\n              existence,\n              nodeAux,\n              siblings\n            }),\n            value: (n as NodeLeaf).entry[1].bigInt()\n          };\n        case NODE_TYPE_MIDDLE:\n          if (path[depth]) {\n            nextKey = (n as NodeMiddle).childR;\n            siblingKey = (n as NodeMiddle).childL;\n          } else {\n            nextKey = (n as NodeMiddle).childL;\n            siblingKey = (n as NodeMiddle).childR;\n          }\n          break;\n        default:\n          throw ErrInvalidNodeFound;\n      }\n      siblings.push(siblingKey);\n    }\n    throw ErrKeyNotFound;\n  }\n\n  async addAndGetCircomProof(k: bigint, v: bigint): Promise<CircomProcessorProof> {\n    const cp = new CircomProcessorProof();\n    cp.fnc = 2;\n    cp.oldRoot = await this.root();\n    let key = BigInt('0');\n    let value = BigInt('0');\n    let siblings: Siblings = [];\n    try {\n      const res = await this.get(k);\n      key = res.key;\n      value = res.value;\n      siblings = res.siblings;\n    } catch (err) {\n      if (err !== ErrKeyNotFound) {\n        throw err;\n      }\n    }\n\n    if (typeof key === 'undefined' || typeof value === 'undefined') {\n      throw 'key/value undefined';\n    }\n\n    cp.oldKey = Hash.fromBigInt(key);\n    cp.oldValue = Hash.fromBigInt(value);\n\n    if (bytesEqual(cp.oldKey.value, ZERO_HASH.value)) {\n      cp.isOld0 = true;\n    }\n\n    cp.siblings = circomSiblingsFromSiblings(siblings, this.maxLevels);\n    await this.add(k, v);\n\n    cp.newKey = Hash.fromBigInt(k);\n    cp.newValue = Hash.fromBigInt(v);\n    cp.newRoot = await this.root();\n\n    return cp;\n  }\n\n  // NOTE: for now it only prints to console, will be updated in future\n  async graphViz(rootKey: Hash): Promise<void> {\n    let cnt = 0;\n\n    await this.walk(rootKey, async (n: Node) => {\n      const k = await n.getKey();\n      let lr: [string, string];\n      let emptyNodes: string;\n\n      switch (n.type) {\n        case NODE_TYPE_EMPTY:\n          break;\n        case NODE_TYPE_LEAF:\n          // eslint-disable-next-line no-console\n          console.log(`\"${k.string()}\" [style=filled]`);\n          break;\n        case NODE_TYPE_MIDDLE:\n          lr = [(n as NodeMiddle).childL.string(), (n as NodeMiddle).childR.string()];\n          emptyNodes = '';\n\n          lr.forEach((s, i) => {\n            if (s === '0') {\n              lr[i] = `empty${cnt}`;\n              emptyNodes += `\"${lr[i]}\" [style=dashed,label=0];\\n`;\n              cnt += 1;\n            }\n          });\n          // eslint-disable-next-line no-console\n          console.log(`\"${k.string()}\" -> {\"${lr[1]}\"}`);\n          // eslint-disable-next-line no-console\n          console.log(emptyNodes);\n          break;\n        default:\n          break;\n      }\n    });\n\n    // eslint-disable-next-line no-console\n    console.log(`}\\n`);\n  }\n\n  async printGraphViz(rootKey: Hash): Promise<void> {\n    if (bytesEqual(rootKey.value, ZERO_HASH.value)) {\n      rootKey = await this.root();\n    }\n    // eslint-disable-next-line no-console\n    console.log(\n      `--------\\nGraphViz of the MerkleTree with RootKey ${rootKey.bigInt().toString(10)}\\n`\n    );\n    await this.graphViz(ZERO_HASH);\n    // eslint-disable-next-line no-console\n    console.log(\n      `End of GraphViz of the MerkleTree with RootKey ${rootKey.bigInt().toString(10)}\\n--------\\n`\n    );\n  }\n}\n"],"names":["HASH_BYTES_LENGTH","NODE_TYPE_MIDDLE","NODE_TYPE_LEAF","NODE_TYPE_EMPTY","NODE_VALUE_BYTE_ARR_LENGTH","EMPTY_NODE_VALUE","Uint8Array","EMPTY_NODE_STRING","ELEM_BYTES_LEN","DATA_LEN","DATA_LEN_BYTES","PROOF_FLAG_LEN","NOT_EMPTIES_LEN","FIELD_SIZE","BigInt","MAX_NUM_IN_FIELD","__classPrivateFieldGet","receiver","state","kind","f","TypeError","has","call","value","get","__classPrivateFieldSet","set","checkBigIntInField","bigNum","bytesEqual","b1","b2","every","ele","idx","swapEndianness","bytes","slice","reverse","bytes2BinaryString","reduce","acc","i","toString","padStart","testBit","bitMap","n","parseInt","testBitBigEndian","length","setBitBigEndian","hextable","bytes2Hex","u","arr","Array","j","forEach","v","join","newBigIntFromBytes","str2Bytes","str","map","_","charCodeAt","getPath","numLevels","k","path","siblings2Bytes","siblings","siblingBytesBuff","ArrayBuffer","siblingBytes","bigint2Array","radix","split","bigIntToUINT8Array","n256","Number","Hash","constructor","_bytes","Error","this","string","bigInt","hex","equals","hash","fromString","s","fromBigInt","e","deserializedHash","JSON","parse","from","Object","values","fromHex","h","Hex","decodeString","ZERO_HASH","toJSON","newHashFromBigInt","newHashFromHex","newHashFromString","decimalString","hashElems","hashBigInt","poseidon","hashElemsKey","circomSiblingsFromSiblings","levels","push","InMemoryDB","_prefix","_InMemoryDB_kvMap","_InMemoryDB_currentRoot","prefix","kBytes","undefined","put","getRoot","setRoot","r","leafKey","async","nodeValue","type","a","b","vBytes","NodeLeaf","_NodeLeaf_key","entry","getKey","NodeMiddle","cL","cR","_NodeMiddle_key","childL","childR","NodeEmpty","_NodeEmpty_key","LocalStorageDB","_LocalStorageDB_currentRoot","rootStr","localStorage","getItem","key","val","obj","toSerialize","stringify","setItem","promisifyRequest","request","Promise","resolve","reject","oncomplete","onsuccess","result","onabort","onerror","error","createStore","dbName","storeName","indexedDB","open","onupgradeneeded","createObjectStore","dbp","txMode","callback","then","db","transaction","objectStore","defaultGetStoreFunc","defaultGetStore","customStore","store","IndexedDBStorage","databaseName","_IndexedDBStorage_currentRoot","_prefixHash","_store","storageName","root","ElemBytes","_ElemBytes_bytes","Data","_Data_value","_v","_idx","equal","d2","newDataFromBytes","d","tmp","Entry","_data","_Entry_data","_Entry_hIndex","_Entry_hValue","data","index","hIndex","elemBytesToBigInts","hValue","hiHv","hi","hv","e2","clone","es","checkEntryInField","bigInts","flag","ErrNodeKeyAlreadyExists","ErrKeyNotFound","ErrNodeBytesBadSize","ErrReachedMaxLevel","ErrInvalidNodeFound","ErrInvalidProofBytes","ErrInvalidDBValue","ErrEntryIndexAlreadyExists","ErrNotWritable","ErrNotFound","CircomVerifierProof","_root","_siblings","_oldKey","_oldValue","_isOld0","_key","_value","_fnc","oldKey","oldValue","isOld0","fnc","CircomProcessorProof","_oldRoot","_newRoot","_newKey","_newValue","oldRoot","newRoot","newKey","newValue","ErrNodeAuxNonExistAgainstHIndex","Proof","existence","depth","nodeAux","notEmpties","reduceSiblings","bsLen","arrBuff","bs","allSiblings","node_aux","reducedSiblings","sibling","fromJSON","nodeAuxJson","buildAllSiblings","sibIdx","siblignsFroomProof","proof","verifyProof","rootKey","rFromProof","rootFromProof","err","kHash","vHash","midKey","Merkletree","_db","_writable","_maxLevels","_Merkletree_db","_Merkletree_root","_Merkletree_writable","_Merkletree_maxLevel","maxLevels","add","newNodeLeaf","newRootKey","addLeaf","updateNode","addNode","addEntry","pushLeaf","newLeaf","oldLeaf","lvl","pathNewLeaf","pathOldLeaf","newNodeMiddle","nextKey","oldLeafKey","newLeafKey","getNode","nKey","update","cp","recalculatePathUntilRoot","node","nodeKey","rmAndUpload","toUpload","nearestSibling","newNode","recWalk","walk","generateCircomVerifierProof","generateSCVerifierProof","generateProof","siblingKey","addAndGetCircomProof","res","graphViz","cnt","lr","emptyNodes","console","log","printGraphViz"],"mappings":"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","x_google_ignoreList":[5,15]}