"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerDidMethodNetwork = exports.chainIDfromDID = exports.getChainId = exports.registerChainId = exports.registerDidMethod = exports.registerNetwork = exports.registerBlockchain = void 0;
const constants_1 = require("./constants");
const did_1 = require("./did");
const registerBlockchain = (blockchain) => {
    constants_1.Blockchain[blockchain] = blockchain;
};
exports.registerBlockchain = registerBlockchain;
const registerNetwork = (network) => {
    constants_1.NetworkId[network] = network;
};
exports.registerNetwork = registerNetwork;
const registerDidMethod = (method, byte) => {
    const max = constants_1.DidMethodByte[constants_1.DidMethod.Other];
    if (byte >= max) {
        throw new Error(`Can't register DID method byte: current '${byte.toString(2)}', maximum byte allowed: '${(max - 1).toString(2)}'`);
    }
    if (typeof constants_1.DidMethodByte[method] === 'number' && constants_1.DidMethodByte[method] === byte) {
        return;
    }
    if (Object.values(constants_1.DidMethodByte).includes(byte)) {
        throw new Error(`can't register method '${method}' because DID method byte '${byte.toString(2)}' already registered for another method`);
    }
    constants_1.DidMethod[method] = method;
    constants_1.DidMethodByte[method] = byte;
};
exports.registerDidMethod = registerDidMethod;
/**
 * Register chain ID for a blockchain and network.
 *
 * @param {string} blockchain
 * @param {string} network
 * @param {number} [chainId]
 * @returns {void}
 */
const registerChainId = (blockchain, network, chainId) => {
    const key = `${blockchain}:${network}`;
    if (typeof constants_1.ChainIds[key] === 'number' && constants_1.ChainIds[key] === chainId) {
        return;
    }
    if (Object.values(constants_1.ChainIds).includes(chainId)) {
        throw new Error(`can't register chainId ${chainId} for '${blockchain}:${network}' because it's already registered for another chain id`);
    }
    constants_1.ChainIds[key] = chainId;
};
exports.registerChainId = registerChainId;
/**
 * Get chain ID by a blockchain and network.
 *
 * @param {string} blockchain
 * @param {string} [network]
 * @returns {number}
 */
const getChainId = (blockchain, network) => {
    if (network) {
        blockchain += `:${network}`;
    }
    const chainId = constants_1.ChainIds[blockchain];
    if (!chainId) {
        throw new Error(`chainId not found for ${blockchain}`);
    }
    return chainId;
};
exports.getChainId = getChainId;
/**
 * ChainIDfromDID returns chain name from w3c.DID
 *
 * @param {DID} did
 * @returns {number}
 */
const chainIDfromDID = (did) => {
    const id = did_1.DID.idFromDID(did);
    const blockchain = did_1.DID.blockchainFromId(id);
    const networkId = did_1.DID.networkIdFromId(id);
    const chainId = constants_1.ChainIds[`${blockchain}:${networkId}`];
    if (typeof chainId !== 'number') {
        throw new Error(`chainId not found for ${blockchain}:${networkId}`);
    }
    return chainId;
};
exports.chainIDfromDID = chainIDfromDID;
/**
 * Register a DID method with a byte value.
 * https://docs.iden3.io/getting-started/identity/identity-types/#regular-identity
 * @param {{
 *   method: DidMethodName;  DID method name
 *   methodByte?: number; put DID method byte value in case you want to register new DID method
 *   blockchain: BlockchainName;  blockchain name
 *   network: NetworkName;  network name
 *   networkFlag: number;  network flag
 *   chainId?: number;  put  chain ID in case you need to use it
 * }} {
 *   method,
 *   methodByte,
 *   blockchain,
 *   network,
 *   chainId,
 *   networkFlag
 * }
 */
const registerDidMethodNetwork = ({ method, methodByte, blockchain, network, chainId, networkFlag }) => {
    (0, exports.registerBlockchain)(blockchain);
    (0, exports.registerNetwork)(network);
    if (typeof methodByte === 'number') {
        (0, exports.registerDidMethod)(method, methodByte);
    }
    if (!constants_1.DidMethodNetwork[method]) {
        constants_1.DidMethodNetwork[method] = {};
    }
    if (typeof chainId === 'number') {
        (0, exports.registerChainId)(blockchain, network, chainId);
    }
    const key = `${blockchain}:${network}`;
    const existedFlag = constants_1.DidMethodNetwork[method][key];
    if (typeof existedFlag === 'number' && existedFlag === networkFlag) {
        return;
    }
    if (Object.values(constants_1.DidMethodNetwork[method]).includes(networkFlag)) {
        throw new Error(`DID network flag ${networkFlag.toString(2)} is already registered for the another network id for '${method}' method`);
    }
    constants_1.DidMethodNetwork[method][key] = networkFlag;
};
exports.registerDidMethodNetwork = registerDidMethodNetwork;
